C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE RESIDU(NBL,M,M2,NGL,ISSB,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,
     + CH,CP,A1,D1,A1XA,A1YA,A1ZA,A2,D2,A2XA,A2YA,A2ZA,A3,D3,A3XA,A3YA,
     + A3ZA,XC,YC,ZC,DISTW,XCO,YCO,ZCO,DTL,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + DT,GAMMA,RGAS,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,OHMI,DELTA,ICP,JCP,KCP,
     + IJMASK,IMAX,JMAX,KMAX,INTERI,INTERJ,INTERK,IDERI,
     + JBOT,JTOP,IDI1,IDI2,IDI3,
     + IT,IL,IK,IPRINT,ICMAX,MPRINT,ICYCLE,ITIMES,T,
     + PR,PRT,LUSGS,CFL,CX,CY,CZ,CMX,CMY,CMZ,
     + DX,DY,DZ,QX,QY,QZ,TOMEGA,OMEGA,OMEX,OMEY,OMEZ,
     + ICON,NPATCH,XMOM,YMOM,ZMOM,
     + IBOT,ITOP,KBOT,KTOP,LAMIN,IFLUX,
     + UBI,VBI,WBI,UBJ,VBJ,WBJ,UBK,VBK,WBK,UTI,VTI,WTI,
     + UTJ,VTJ,WTJ,UTK,VTK,WTK,UROT,VROT,WROT,RCON,RK,REPS,
     + DDEPS,DRK,DEPS,SRK,SEPS,PTUR,F1RK,F1EPS,TURLIM,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,JSTATE,
     + ITURB,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,
     + HAT1,HAT2,HAT3,HAT4,RLOLIM,TIMEL,GRAVIL,
     + ROLE2,RMLE2,RNLE2,RWLE2,ELE2,RKLE2,EPSLE2,FILE2,XLE2,YLE2,ZLE2,
     + ROLE3,RMLE3,RNLE3,RWLE3,ELE3,RKLE3,EPSLE3,FILE3,XLE3,YLE3,ZLE3,
     + W12,SIJ,GRADT,GRADK,GREPS,MAX11,NCHIM,
     + ROFOR,RMFOR,RNFOR,RWFOR,EFOR,PDFOR,RKSI,FIFOR,RKFOR,REFOR,
     + MPFOR,FULLNS,
     + QMFIN,QVFIN,QMEIN,QMFOUT,QVFOUT,QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,
     + QMZIN,QMZOUT,CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,
     + IPRESC,ZZZ,MAXW,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,BOUNE,BOUNP,
     + BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,BOUNA1,BOUNA2,IBF,
     + PRO,VAR,BLKS,MULPHL,PRC,XXTRAL,FRESUL,IFSBC,F1H,WAVEH,IWAVEB,
     + FREDIF,IGRID,BUX,BUY,BUZ,VMXB,VMYB,VMZB,FRSSIE,RNUT,VORT,SHEAR,
     + STRAIN,PSEUCO,RJK2,RJK4,TURDESL,KOVER,INCHIML,ENTROPY_FIX,
     + QGFIN,QGEIN,QGFOUT,QGEOUT,
     + TRANSL,TRM,BOUNG,BOUNRET,PLE2,PLE3,IDIMSG,JDIMSG,CDIFF,
     + VELLAP,QSAS,IUPPTL,BOUNU1,BOUNU2,BOUNV1,BOUNV2,BOUNW1,BOUNW2,
     + SURFPX,SURFPY,SURFPZ,QLFIN,QLEIN,QLFOUT,QLEOUT,UTAUM,EPSOLD)

      USE TYPE_ARRAYS
      USE CHARACTERS
      USE CONSTANTS, ONLY : EPS,PII,CB1,CB2,SRNU,CV1,CW1,CW2,CW3
      USE NS3CO, ONLY : IN, JN, KN, IC9, GX, GY, GZ
      USE INTEGERS, ONLY  : MAXFS,MAXB

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,ISTRID,JSTRID,KSTRID,KMAXP,NBL,
     2 M,M2,NGL,INTERI,INTERJ,INTERK,IDERI,IBOT,ITOP,JBOT,JTOP,KBOT,
     3 KTOP,IDI1,IDI2,IDI3,IT,IL,IK,IPRINT,ICMAX,MPRINT,ICYCLE,ITIMES,
     4 NPATCH,LUSGS,LAMIN,IFLUX,ISTATE,ITURB,MAXSB,NSCAL,MAX11,NCHIM,
     5 IPRESC,MAXW,IBF,ISTR,JSTR,KSTR,NTOT,IDM1,IDM2,IDM3,NS,IFSBC,
     6 ISLAB,IGRID,III,KOVER,IUPPTL

      REAL :: XCO(*),YCO(*),ZCO(*),XLE2(*),YLE2(*),ZLE2(*),
     2 XLE3(*),YLE3(*),ZLE3(*),ZC(*),YC(*),XC(*),XCP(*),YCP(*),ZCP(*)

      INTEGER :: ISSB(*),IHF(*),ICP(*),JCP(*),
     &           KCP(*),IJMASK(*),ICON(IC9,*),JSTATE(*),IWAVEB(*),
     &           IDIMSG(*),JDIMSG(*)

      REAL :: RO(*),RM(*),RN(*),E(*),P(*),U(*),V(*),C(*),A1(*),A1XA(*),
     2 A1YA(*),A1ZA(*),A2(*),A2XA(*),A2YA(*),A2ZA(*),DISTW(*),
     3 A3(*),A3XA(*),A3YA(*),A3ZA(*),DRO(*),DM(*),DN(*),DE(*),VOL(*),
     4 F1R(*),F1RM(*),F1RN(*),F1E(*),F1RW(*),D1(*),CH(*),TEMP(*),
     5 VIS(*),EPS2(*),VIST(*),CP(*),
     6 UWALL(*),VWALL(*),WWALL(*),CPWALL(*),TWALL(*),QWALL(*),
     7 QWFRIC(*),TAUW1(*),TAUW2(*),SURFX(*),SURFY(*),SURFZ(*),
     8 TAUWX(*),TAUWY(*),TAUWZ(*),SURLE(*),DSURLE(*),WMFLUX(*),
     9 POROS(*),WHSTAG(*),WTEMP(*),RSDIRX(*),RSDIRY(*),RSDIRZ(*),
     1 RBK(*),HFLUX(*),RW(*),W(*),DW(*),D2(*),
     2 D3(*),OHMI(*),STRAIN(*),UROT(*),VROT(*),WROT(*),DRDH(*),DRDP(*),
     3 PSIGSC(*),PSIGS2(*),CX(*),CY(*),CZ(*),CMX(*),
     4 CMY(*),CMZ(*),DX(*),DY(*),DZ(*),QX(*),QY(*),QZ(*),TOMEGA(*),
     5 UBI(*),VBI(*),WBI(*),UBJ(*),VBJ(*),WBJ(*),UBK(*),VBK(*),WBK(*),
     6 UTI(*),VTI(*),WTI(*),UTJ(*),VTJ(*),WTJ(*),UTK(*),VTK(*),WTK(*),
     7 FI(MAXSB,MAX(1,NSCAL)),F1FI(MAXSB,MAX(1,NSCAL)),
     8 DFI(MAXSB,MAX(1,NSCAL)),SFI(MAXSB,MAX(1,NSCAL)),
     9 HAT1(*),HAT2(*),HAT3(*),HAT4(*),PDIFF(*),RLOLIM(*),
     1 ROLE2(*),RMLE2(*),RNLE2(*),RWLE2(*),ELE2(*),RKLE2(*),EPSLE2(*),
     2 ROLE3(*),RMLE3(*),RNLE3(*),RWLE3(*),ELE3(*),RKLE3(*),EPSLE3(*),
     3 PTUR(*),RCON(IC9,*),
     4 RK(*),REPS(*),DRK(*),DEPS(*),SRK(*),SEPS(*),F1RK(*),F1EPS(*),
     5 ROFOR(*),RMFOR(*),RNFOR(*),RWFOR(*),EFOR(*),PDFOR(*),RKSI(*),
     6 FILE2(MAXSB,MAX(1,NSCAL)),FILE3(MAXSB,MAX(1,NSCAL)),
     7 FIFOR(MAXSB,MAX(1,NSCAL)),
     8 W12(MAX11,3),SIJ(MAX11,6),GRADT(MAX11,3),GRADK(MAX11,3),
     9 GREPS(MAX11,3),DTL(*),ZZZ(*),BOUNR(*),BOUNU(*),BOUNV(*),
     1 BOUNW(*),BOUNE(*),BOUNT(*),BOUNRK(*),BOUNEP(*),BOUNP(*),
     2 BOUNPD(*),BOUNFI(IBF,MAX(1,NSCAL)),BOUNBI(IBF,*),BOUNMF(*),
     3 BOUNA1(*),
     4 BOUNA2(*),F1H(*),BUX(*),BUY(*),BUZ(*),VMXB(*),VMYB(*),
     5 VMZB(*),RNUT(*),VORT(MAXB,*),SHEAR(MAXB,*),RKFOR(*),REFOR(*),
     6 BOUNG(*),BOUNRET(*),PLE2(*),PLE3(*),VELLAP(*),QSAS(*),
     7 BOUNU1(*),BOUNU2(*),BOUNV1(*),BOUNV2(*),BOUNW1(*),BOUNW2(*),
     8 SURFPX(*),SURFPY(*),SURFPZ(*),UTAUM(*),DDEPS(*),EPSOLD(*)

      REAL, ALLOCATABLE, DIMENSION(:) :: DSUR,WAVE,SCALEJ
      REAL, ALLOCATABLE, DIMENSION(:) :: DDSUR
      REAL, DIMENSION(:) :: WAVEH

      REAL :: XMOM,YMOM,ZMOM

      REAL :: DT,GAMMA,RGAS,E0REF,T0REF,DELTA,T,PR,PRT,
     2 OMEGA,OMEX,OMEY,OMEZ,TURLIM,FRSDEN,CFL,
     3 FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,QMFIN,QMEIN,QMFOUT,QMEOUT,QMXIN,
     4 QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMXOUT,CMYIN,CMYOUT,
     5 CMZIN,CMZOUT,PVISC,QVFIN,QVFOUT,FREDIF,FRSSIE,PSEUCO,RJK2,RJK4,
     6 ARTSSP,QGFIN,QGEIN,QGFOUT,QGEOUT,GXS,GYS,GZS,CDIFF,
     7 QLFIN,QLEIN,QLFOUT,QLEOUT

      TYPE(PROPERTIES)       :: PRO(*)
      TYPE(MPHASE_VARIABLES) :: VAR(*)
      TYPE(MPHASE_FORTIFY)   :: MPFOR(*)
      TYPE(BLOCKS)           :: BLKS(*)
      TYPE(PRE_COR)          :: PRC(*)
      TYPE(INTERMITTENCY)    :: TRM(*)

      LOGICAL :: TIMEL,GRAVIL,FULLNS,MULPHL,XXTRAL,FRESUL,TURDESL,
     2           INCHIML,ENTROPY_FIX,TRANSL

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      KSTRID  = KMAX + 2*KN

      ISTR    = 1
      JSTR    = ISTRID
      KSTR    = ISTRID*JSTRID
      KMAXP   = KMAX + 1

      NTOT    = ISTRID*JSTRID*KSTRID

      ALLOCATE(SCALEJ(NTOT))

      SCALEJ(1:NTOT) = 0.

c ... Scaling for the Jameson type dissipation

      ARTSSP = BLKS(NGL)%ARTSSP

      CALL SCALARD(SCALEJ,A1,A2,A3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,
     + A3XA,A3YA,A3ZA,U,V,W,C,UROT,VROT,WROT,IMAX,JMAX,KMAX,IN,JN,KN,
     + ARTSSP,IPRESC)

C ... Put the surface level into a temporary single precision array WAVE

      IF(FRESUL) THEN
        
         ISLAB   = MAX(ISTRID*JSTRID,ISTRID*KSTRID,JSTRID*KSTRID)

         ALLOCATE(DSUR(NTOT),WAVE(NTOT),DDSUR(ISLAB))
         WAVE  = 0.
         DSUR  = 0.
         DDSUR = 0.

         IF(M2 == 1) THEN
         CALL PATVSP(WAVEH,WAVE,F1R,IMAX,JMAX,KMAX,IN,JN,KN,NGL,M,
     +     NPATCH,ICON,IHF,'FRE',.FALSE.)
         ENDIF

      ELSE IF(MULPHL .AND. ICYCLE == IPRINT) THEN

         ALLOCATE(DSUR(1),WAVE(1),DDSUR(NTOT))
         DDSUR = 0.

      ELSE

         ALLOCATE(DSUR(1),WAVE(1),DDSUR(1))
         WAVE = 0.

      ENDIF

C ... ADJUST CELLS WITH FRICTION TO THE GRID LEVEL USED

      IDM1    = (IDI1-1)/2**(M-1) + 1
      IDM2    = (IDI2-1)/2**(M-1) + 1
c      IDM3    = (IDI3-1)/2**(M-1) + 1
      IDM3    = MAX(1,(IDI3-1)/2**(M-1)) + 1
      IF(IDI3 == 0) IDM3 = 0

C **********************************************************
C                                                          *
C ... CALCULATION OF FLUXES                                *
C                                                          *
C **********************************************************

C     INITIALIZATION OF RESIDUALS. 
    
      CALL ZEROZZ(DRO,    NTOT)
      CALL ZEROZZ(DM,     NTOT)
      CALL ZEROZZ(DN,     NTOT)
      CALL ZEROZZ(DW,     NTOT)
      CALL ZEROZZ(DE,     NTOT)
      CALL ZEROZZ(DEPS,   NTOT)
      IF(IPRESC == 1) THEN
      PRC(1:NTOT)%DRO = 0.
      ENDIF

      DO NS = 1,3
      CALL ZEROZZ(  W12(1,NS),NTOT)
      CALL ZEROZZ(GRADT(1,NS),NTOT)
      CALL ZEROZZ(GRADK(1,NS),NTOT)
      CALL ZEROZZ(GREPS(1,NS),NTOT)
      ENDDO

      DO 7 NS = 1,NSCAL
         CALL ZEROZZ(DFI(1,NS),NTOT)
         CALL ZEROZZ(SFI(1,NS),NTOT)
7     CONTINUE

      IF(ICYCLE == IPRINT) THEN
         CALL PRINYS(3,ROC,     RO,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RMC,     RM,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RNC,     RN,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RWC,     RW,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,UC,       U,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,VC,       V,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,WC,       W,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,PC,       P,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,PDIFC,PDIFF,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,TEMPC, TEMP,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,VISC,   VIS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(ITURB == 9) THEN
         CALL PRINYS(3,RKC,     RK,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RNUTC, REPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF

         CALL PRINYS(3,EPS2C, EPS2,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,VISTC, VIST,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         DO 8170 NS = 1,NSCAL
         CALL PRINYS(3,FIC(NS),FI(1,NS),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
 8170    CONTINUE
      ENDIF

C ... REFLECT VARIABLES SO THAT CENTRAL DIFFERENCE IS APPLIED IN 
C ... THE NEXT FACE FROM THE SOLID WALL

      IF (M == 1) THEN
      CALL REFCEN(U,V,W,VAR,TRM,IMAX,JMAX,KMAX,IBOT,ITOP,JBOT,JTOP,
     +     KBOT,KTOP,IN,JN,KN,FRSDEN,FRSPRE,NPATCH,ICON,RO,P,PDIFF,
     +     E,RM,RN,RW,F1R,F1RM,ITURB,ISTATE,BLKS(NGL)%SOLUTION_TYPE,
     +     TRANSL)
      ENDIF

      IF (FULLNS) THEN ! Calculate derivatives and Sij

      CALL DERFUN(OHMI,W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),
     +     SIJ(1,3),SIJ(1,4),SIJ(1,5),SIJ(1,6),U,V,W,A1,A2,A3,VOL,
     +     D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     +     XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M,STRAIN,VELLAP)

      CALL TEMDER(TEMP,GRADT(1,1),GRADT(1,2),GRADT(1,3),A1,A2,A3,
     + VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     + XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)

      ENDIF
      
C******************************************************************
C                                                                 *
C ... FLUXES IN K-DIRECTION                                       *
C                                                                 *
C******************************************************************
 
      IF(KMAX >= 1) THEN
      CALL FLUCYC(NGL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,CP,
     + A3,D3,A3XA,A3YA,A3ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VIS,TEMP,EPS2,VIST,
     + W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),SIJ(1,3),SIJ(1,4),
     + SIJ(1,5),SIJ(1,6),GRADT(1,1),GRADT(1,2),GRADT(1,3), 
     + RGAS,GAMMA,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,OHMI,KCP,
     + IMAX,JMAX,KMAX,IN,JN,KN,ISTRID,JSTRID,KSTRID,ICYCLE,ICMAX,INTERK,
     + IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,KBOT,KTOP,IFLUX,WROT,IDM3,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,ITURB,
     + HAT1,HAT2,HAT3,HAT4,RLOLIM,UBK,VBK,WBK,UTK,VTK,WTK,
     + IMAX,JMAX,KMAX,IN,JN,KN,KMAXP,ISTR,JSTR,KSTR,3,FULLNS,ZZZ,MAXW,
     + XCO,YCO,ZCO,QMFIN,QVFIN,QMEIN,QMFOUT,QVFOUT,QMEOUT,
     + QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,
     + CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,
     + BOUNU,BOUNV,BOUNW,BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,
     + BOUNEP,BOUNFI,BOUNBI,BOUNA1,BOUNA2,IBF,PRO,VAR,PRC,BLKS,
     + MULPHL,JSTATE,IPRESC,XXTRAL,FRESUL,F1H,WAVE,IFSBC,IWAVEB,FREDIF,
     + BUX,BUY,BUZ,VMXB,VMYB,VMZB,FRSSIE,RK,REPS,RNUT,STRAIN,PSEUCO,
     + RJK2,RJK4,SCALEJ,RKSI,INCHIML,ENTROPY_FIX,QGFIN,QGEIN,QGFOUT,
     + QGEOUT,TRM,TRANSL,BOUNG,BOUNRET,PLE2,PTUR,IDIMSG,JDIMSG,IUPPTL,
     + BOUNU1,BOUNU2,BOUNV1,BOUNV2,BOUNW1,BOUNW2,SURFPX,SURFPY,SURFPZ,
     + QLFIN,QLEIN,QLFOUT,QLEOUT,UTAUM,EPSOLD)
          
      ELSEIF (KMAX  == 1) THEN       ! axisymmetric case
c         CALL FLUXP(F1RM,F1RN,F1RW,RO,RM,RN,RW,P,U,V,W,WROT,A3,
c     &        A3XA,A3YA,A3ZA,VOL,RK,EPS2,VIS,IMAX,JMAX,KMAX,
c     &        ISTR,JSTR,KSTR,IN,JN,KN,KSTR,1,IDM3)
         CALL ZEROZZ(F1R,NTOT)
         CALL ZEROZZ(F1E,NTOT)
         CALL ZEROZZ(F1EPS,NTOT)
         IF(IPRESC == 1) CALL ZEROZZ(HAT1,NTOT)
         DO NS = 1,NSCAL
            CALL ZEROZZ(F1FI(1,NS), NTOT)
         ENDDO
      END IF ! KMAX == 1

      IF(M2 == 1 .AND. (ICYCLE == IPRINT .OR.
     +     ICYCLE >= ICMAX .AND. .NOT. TIMEL .OR. 
     +     TIMEL.AND.MOD(ITIMES,MPRINT) == 0.AND.ICYCLE == 3)) THEN

         WRITE(44,1000) ITIMES,T,ISSB(7),NGL
         CALL HCHECK(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,P,RO,RM,RN,RW,
     +        RK,REPS,A3,A3XA,A3YA,A3ZA,WROT,IMAX,JMAX,KMAX,IN,JN,KN,
     +        ICYCLE,'K',ISTR,JSTR,KSTR,ITURB,C,TEMP,GAMMA,XCO,YCO,ZCO,
     +        XC,YC,ZC,CH,VIS,PRO,VAR,PR,IPRESC,FRSPRE,FRSDEN,
     +        ISTATE,ISSB(3),BLKS(NGL)%SOLUTION_TYPE,VOL,PDIFF)
         WRITE(44,*)
      ENDIF
 1000 FORMAT(/'  MASS, ENERGY AND ENTHALPY BALANCES IN TIME STEP ',I6,
     +     ' TIME ',E13.5,' IN BLOCK ',2I5)

      CALL SWEEP(DRO,DM,DN,DW,DE,F1R,F1RM,F1RN,F1RW,F1E,VOL,
     2 IMAX,JMAX,KMAX,ISTRID*JSTRID,IN,JN,KN,DT,0)

C ... SWEEP FOR Spalart-Allmaras variable
      IF(ITURB == 9) THEN
         CALL SWEEPS(DEPS,F1EPS,VOL,IMAX,JMAX,KMAX,ISTRID*JSTRID,
     +   IN,JN,KN,DT,1,MAXB,0)
      ENDIF

C ... Save the mass flows for the pressure correction stage (mersu)

      IF(IPRESC == 1) THEN
         PRC(1:NTOT)%F3R = F1R(1:NTOT)
      ENDIF

      IF(FRESUL .AND. M2 == 1 .AND. IGRID >= 5) THEN ! k-direction!
        CALL SWEEPS(DSUR,F1H,VOL,IMAX,JMAX,KMAX,ISTRID*JSTRID,
     +  IN,JN,KN,DT,1,MAXFS,0)
        PRC(1:NTOT)%F3R = F1R(1:NTOT)
      ENDIF
C ... SWEEP FOR SCALARS PPR 11.2.
      IF(NSCAL > 0) THEN
      CALL SWEEPS(DFI,F1FI,VOL,IMAX,JMAX,KMAX,ISTRID*JSTRID,
     2 IN,JN,KN,DT,NSCAL,MAXSB,0)
      ENDIF

      IF(ICYCLE == IPRINT) THEN

           WRITE(3,'(/,A)') 'Mass flows applied for momentum and energy'
           CALL PRINYS(3,F3RC,F1R,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           WRITE(3,'(/,A)') 'Mass flows applied for pressure correction'
           CALL PRINYS(3,F3RC,HAT1, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DROC,DRO,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F3MC,F1RM,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DMC, DM,    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F3NC,F1RN,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DNC,  DN,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F3WC,F1RW,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DWC, DW,    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F3EC,F1E,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DEC,DE,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           IF(ITURB == 9) THEN
           WRITE(3,'(/,A)') 'RESIDUn arvot k-suunnan'
           CALL PRINYS(3,F3RNUC,F1EPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DEPSC,DEPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,NUTC,RNUT, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,ROC, RO,    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ENDIF
           IF(FRESUL .AND. M == 1) THEN
           CALL PRINYS(3,WAVEC,WAVE, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           IF(IFSBC == 4) THEN
           CALL PRINYS(3,F3HC,F1H,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DSURFC,DSUR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ENDIF
           ENDIF
C ... FOR SCALAR EQ PPR 14.2
           DO 8180 NS = 1,NSCAL
           CALL PRINYS(3,F3FIC(NS),F1FI(1,NS),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DFIC(NS), DFI(1,NS), IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
 8180    CONTINUE
      ENDIF
 1    CONTINUE

C******************************************************************
C                                                                 *
C ... FOR THE CALCULATION OF FLUXES IN I-DIRECTION SORT           *
C ... GEOMETRY AND VARIABLES FROM IJK TO JKI                      *
C                                                                 *
C******************************************************************

      CALL FLUCYC(NGL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,CP,
     + A1,D1,A1XA,A1YA,A1ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VIS,TEMP,EPS2,VIST,
     + W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),SIJ(1,3),SIJ(1,4),
     + SIJ(1,5),SIJ(1,6),GRADT(1,1),GRADT(1,2),GRADT(1,3), 
     + RGAS,GAMMA,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,OHMI,ICP,
     + JMAX,KMAX,IMAX,JN,KN,IN,JSTRID,KSTRID,ISTRID,ICYCLE,ICMAX,INTERI,
     + IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,IBOT,ITOP,IFLUX,UROT,IDM1,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,ITURB,
     + HAT1,HAT2,HAT3,HAT4,RLOLIM,UBI,VBI,WBI,UTI,VTI,WTI,
     + IMAX,JMAX,KMAX,IN,JN,KN,KMAX,JSTR,KSTR,ISTR,1,FULLNS,ZZZ,MAXW,
     + XCO,YCO,ZCO,QMFIN,QVFIN,QMEIN,QMFOUT,QVFOUT,QMEOUT,
     + QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,
     + CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,
     + BOUNU,BOUNV,BOUNW,BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,
     + BOUNEP,BOUNFI,BOUNBI,BOUNA1,BOUNA2,IBF,PRO,VAR,PRC,BLKS,
     + MULPHL,JSTATE,IPRESC,XXTRAL,FRESUL,F1H,WAVE,IFSBC,IWAVEB,FREDIF,
     + BUX,BUY,BUZ,VMXB,VMYB,VMZB,FRSSIE,RK,REPS,RNUT,STRAIN,PSEUCO,
     + RJK2,RJK4,SCALEJ,RKSI,INCHIML,ENTROPY_FIX,QGFIN,QGEIN,QGFOUT,
     + QGEOUT,TRM,TRANSL,BOUNG,BOUNRET,PLE2,PTUR,IDIMSG,JDIMSG,IUPPTL,
     + BOUNU1,BOUNU2,BOUNV1,BOUNV2,BOUNW1,BOUNW2,SURFPX,SURFPY,SURFPZ,
     + QLFIN,QLEIN,QLFOUT,QLEOUT,UTAUM,EPSOLD)

      IF(M2 == 1 .AND. (ICYCLE == IPRINT .OR.
     +     ICYCLE >= ICMAX .AND. .NOT. TIMEL .OR. 
     +     TIMEL.AND.MOD(ITIMES,MPRINT) == 0 .AND.ICYCLE == 3)) THEN

         WRITE(44,1000) ITIMES,T,ISSB(7),NGL
         CALL HCHECK(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,P,RO,RM,RN,RW,
     +        RK,REPS,A1,A1XA,A1YA,A1ZA,UROT,JMAX,KMAX,IMAX,JN,KN,IN,
     +        ICYCLE,'I',JSTR,KSTR,ISTR,ITURB,C,TEMP,GAMMA,XCO,YCO,ZCO,
     +        XC,YC,ZC,CH,VIS,PRO,VAR,PR,IPRESC,FRSPRE,FRSDEN,
     +        ISTATE,ISSB(1),BLKS(NGL)%SOLUTION_TYPE,VOL,PDIFF)
         WRITE(44,*)
      ENDIF

      CALL SWEEP(DRO,DM,DN,DW,DE,F1R,F1RM,F1RN,F1RW,F1E,VOL,
     2 IMAX,JMAX,KMAX,1,IN,JN,KN,DT,0)

C ... SWEEP FOR Spalart-Allmaras variable
      IF(ITURB == 9) THEN
         CALL SWEEPS(DEPS,F1EPS,VOL,IMAX,JMAX,KMAX,1,
     +   IN,JN,KN,DT,1,MAXB,0)
      ENDIF

C ... Save the mass flows for the pressure correction stage (mersu)

      IF(IPRESC == 1) THEN
         PRC(1:NTOT)%F1R = F1R(1:NTOT)
      ENDIF

      IF(FRESUL .AND. M2 == 1 .AND. IGRID >= 5) THEN ! i-direction!
        CALL SWEEPS(DSUR,F1H,VOL,IMAX,JMAX,KMAX,1,
     +  IN,JN,KN,DT,1,MAXFS,0)
        PRC(1:NTOT)%F1R = F1R(1:NTOT)
      ENDIF
C ... SWEEP FOR SCALARS PPR 11.2.
      IF(NSCAL > 0) THEN
         CALL SWEEPS(DFI,F1FI,VOL,IMAX,JMAX,KMAX,1,
     +   IN,JN,KN,DT,NSCAL,MAXSB,0)
      ENDIF

      IF(ICYCLE == IPRINT) THEN
           WRITE(3,'(/,A)') 'Mass flows applied for momentum and energy'
           CALL PRINYS(3,F1RC, F1R, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           WRITE(3,'(/,A)') 'Mass flows applied for pressure correction'
           CALL PRINYS(3,F1RC,HAT1, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DROC,DRO,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F1MC, F1RM,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DMC, DM,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F1NC, F1RN,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DNC, DN,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F1WC, F1RW,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DWC,DW,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F1EC, F1E, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,EPS2C,EPS2,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           IF(ITURB == 9) THEN
           WRITE(3,'(/,A)') 'RESIDUn arvot i-suunnan'
           CALL PRINYS(3,F1RNUC,F1EPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DEPSC,DEPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,NUTC,RNUT, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,ROC, RO,    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ENDIF
           IF(FRESUL .AND. M == 1) THEN
           CALL PRINYS(3,WAVEC,WAVE, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           IF(IFSBC == 4) THEN
           CALL PRINYS(3,F1HC,F1H,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DSURFC,DSUR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ENDIF
           ENDIF
C ... PRINT FOR SCALAR EQS PPR 14.2
           DO 8181 NS = 1,NSCAL
           CALL PRINYS(3,F1FIC(NS),F1FI(1,NS),IT,IL,0,IK,
     +     IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DFIC(NS), DFI(1,NS), IT,IL,0,IK,
     +     IMAX,JMAX,KMAX,NGL,M)
 8181      CONTINUE
      ENDIF

C******************************************************************
C                                                                 *
C     CALCULATE FLUXES IN J-DIRECTION                             *
C                                                                 *
C******************************************************************

      CALL FLUCYC(NGL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,CP,
     + A2,D2,A2XA,A2YA,A2ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VIS,TEMP,EPS2,VIST,
     + W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),SIJ(1,3),SIJ(1,4),
     + SIJ(1,5),SIJ(1,6),GRADT(1,1),GRADT(1,2),GRADT(1,3), 
     + RGAS,GAMMA,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,OHMI,JCP,
     + KMAX,IMAX,JMAX,KN,IN,JN,KSTRID,ISTRID,JSTRID,ICYCLE,ICMAX,INTERJ,
     + IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,JBOT,JTOP,IFLUX,VROT,IDM2,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,ITURB,
     + HAT1,HAT2,HAT3,HAT4,RLOLIM,UBJ,VBJ,WBJ,UTJ,VTJ,WTJ,
     + IMAX,JMAX,KMAX,IN,JN,KN,KMAX,KSTR,ISTR,JSTR,2,FULLNS,ZZZ,MAXW,
     + XCO,YCO,ZCO,QMFIN,QVFIN,QMEIN,QMFOUT,QVFOUT,QMEOUT,
     + QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,
     + CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,
     + BOUNU,BOUNV,BOUNW,BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,
     + BOUNEP,BOUNFI,BOUNBI,BOUNA1,BOUNA2,IBF,PRO,VAR,PRC,BLKS,
     + MULPHL,JSTATE,IPRESC,XXTRAL,FRESUL,F1H,WAVE,IFSBC,IWAVEB,FREDIF,
     + BUX,BUY,BUZ,VMXB,VMYB,VMZB,FRSSIE,RK,REPS,RNUT,STRAIN,PSEUCO,
     + RJK2,RJK4,SCALEJ,RKSI,INCHIML,ENTROPY_FIX,QGFIN,QGEIN,QGFOUT,
     + QGEOUT,TRM,TRANSL,BOUNG,BOUNRET,PLE2,PTUR,IDIMSG,JDIMSG,IUPPTL,
     + BOUNU1,BOUNU2,BOUNV1,BOUNV2,BOUNW1,BOUNW2,SURFPX,SURFPY,SURFPZ,
     + QLFIN,QLEIN,QLFOUT,QLEOUT,UTAUM,EPSOLD)

      IF(M2 == 1 .AND. (ICYCLE == IPRINT .OR.
     +     ICYCLE >= ICMAX .AND. .NOT. TIMEL .OR. 
     +     TIMEL.AND.MOD(ITIMES,MPRINT) == 0.AND.ICYCLE == 3)) THEN

         WRITE(44,1000) ITIMES,T,ISSB(7),NGL
         CALL HCHECK(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,P,RO,RM,RN,RW,
     +        RK,REPS,A2,A2XA,A2YA,A2ZA,VROT,KMAX,IMAX,JMAX,KN,IN,JN,
     +        ICYCLE,'J',KSTR,ISTR,JSTR,ITURB,C,TEMP,GAMMA,XCO,YCO,ZCO,
     +        XC,YC,ZC,CH,VIS,PRO,VAR,PR,IPRESC,FRSPRE,FRSDEN,
     +        ISTATE,ISSB(2),BLKS(NGL)%SOLUTION_TYPE,VOL,PDIFF)
         WRITE(44,*)
      ENDIF

      CALL SWEEP(DRO,DM,DN,DW,DE,F1R,F1RM,F1RN,F1RW,F1E,VOL,
     2 IMAX,JMAX,KMAX,ISTRID,IN,JN,KN,DT,1)

C ... SWEEP FOR Spalart-Allmaras variable
      IF(ITURB == 9) THEN
         CALL SWEEPS(DEPS,F1EPS,VOL,IMAX,JMAX,KMAX,ISTRID,
     +   IN,JN,KN,DT,1,MAXB,1)
      ENDIF

C ... Save the mass flows for the pressure correction stage (mersu)

      IF(IPRESC == 1) THEN
         PRC(1:NTOT)%F2R = F1R(1:NTOT)
      ENDIF

      IF(FRESUL .AND. M2 == 1 .AND. IGRID >= 5) THEN ! j-direction!
        CALL SWEEPS(DSUR,F1H,VOL,IMAX,JMAX,KMAX,ISTRID,
     +  IN,JN,KN,DT,1,MAXFS,0)
        PRC(1:NTOT)%F2R = F1R(1:NTOT)
      ENDIF
C ... SWEEP FOR SCALARS PPR 11.2.
      IF(NSCAL > 0) THEN
       CALL SWEEPS(DFI,F1FI,VOL,IMAX,JMAX,KMAX,ISTRID,
     2 IN,JN,KN,DT,NSCAL,MAXSB,1)
      ENDIF

      IF(ICYCLE == IPRINT) THEN
           IF(M == 1) WRITE(44,*)
           WRITE(3,'(/,A)') 'Mass flows applied for momentum and energy'
           CALL PRINYS(3,F2RC, F1R ,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           WRITE(3,'(/,A)') 'Mass flows applied for pressure correction'
           CALL PRINYS(3,F2RC,HAT1, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           IF(IPRESC == 1 .AND. BLKS(NGL)%FLUXCORR) THEN
           WRITE(3,'(/,A)')'RESIDUn DRO (based on previous mass-fluxes)'
           CALL PRINYS(3,DROC,DRO,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           F1R(1:NTOT) =  PRC(1:NTOT)%DRO
           WRITE(3,'(/,A)')'RESIDUn DRO(for pressure correction)'
           CALL PRINYS(3,DROC,F1R,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ENDIF
           CALL PRINYS(3,F2MC,F1RM ,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DMC,DM,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F2NC,F1RN ,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DNC,DN,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F2WC,F1RW ,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DWC,DW,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,F2EC, F1E ,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,EPS2C,EPS2,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           IF(ITURB == 9) THEN
           WRITE(3,'(/,A)') 'RESIDUn arvot j-suunnan'
           CALL PRINYS(3,F2RNUC,F1EPS,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DEPSC,DEPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,NUTC,RNUT, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,ROC, RO,    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ENDIF
           IF(FRESUL .AND. M == 1) THEN
           CALL PRINYS(3,WAVEC,WAVE, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           IF(IFSBC == 4) THEN
           CALL PRINYS(3,F2HC,F1H,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DSURFC,DSUR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ENDIF
           ENDIF
C ... PRINT FOR SCALAR EQS PPR 14.2
           DO 8182 NS = 1,NSCAL
           CALL PRINYS(3,F2FIC(NS),F1FI(1,NS),IT,IL,0,IK,
     +     IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(3,DFIC(NS), DFI(1,NS), IT,IL,0,IK,
     +     IMAX,JMAX,KMAX,NGL,M)
 8182      CONTINUE
      ENDIF
 
C **********************************************************************
C     CALCULATE TURBULENCE QUANTITIES
C ... HOMOGENEOUS PART OF THE SOURCE TERM, ETA AND TRUE EPSILON
C ************************************************************************

C ... VORTICITY AND STRAINS
C ... W12=W12(1,1)    W13=W12(1,2)    W23=W12(1,3)
C ... S11=SIJ(1,1)    S12=SIJ(1,2)    S13=SIJ(1,3)
C ... S22=SIJ(1,4)    S23=SIJ(1,5)    S33=SIJ(1,6)

      IF(ITURB == 9) THEN          ! Spalart-Allmaras source term

      CALL DIVV12(DDEPS,REPS,RO,NTOT)

      CALL TEMDER(DDEPS,GRADK(1,1),GRADK(1,2),GRADK(1,3),A1,A2,A3,
     + VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     + XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)

      CALL TEMDER(REPS,GREPS(1,1),GREPS(1,2),GREPS(1,3),A1,A2,A3,
     + VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     + XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)

       CALL SOURSA(PTUR,RK,REPS,DDEPS,EPS2,VIST,VIS,SRK,SEPS,RO,
     + A1,A2,A3,VOL,DISTW,OHMI,SIJ(1,1),SIJ(1,2),SIJ(1,3),SIJ(1,4),
     + SIJ(1,5),SIJ(1,6),GREPS(1,1),GREPS(1,2),GREPS(1,3),GRADK(1,1),
     + GRADK(1,2),GRADK(1,3),
     + CB1,CB2,SRNU,CV1,CW1,CW2,CW3,IMAX,JMAX,KMAX,IN,JN,KN,ITURB,M,
     + D1,D2,D3,TURDESL,KOVER,NGL)

       IF(ICYCLE == IPRINT) THEN
         WRITE(3,*)' THE FINAL SOURCE TERMS'
         CALL PRINYS(3,PTURC, PTUR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SEPSC, SEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SRKC,   SRK,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
       ENDIF
      ENDIF

C *** ADD SOURCES TO RESIDUALS ****************************************

C ... Add turbulence source terms

      IF(ITURB == 9) THEN
        IF(TRANSL) STOP'Spalart-Allmaras!'
        DDEPS(1:NTOT) = 0.
        CALL ADDSKE(DRK,DEPS,DDEPS,RK,REPS,PTUR,SEPS,VOL,IMAX,JMAX,KMAX,
     +  KSTRID,IN,JN,KN,DT,TRM,TRANSL)
      ENDIF

C ... ROTATIONAL ACCELERATION TERM

      IF(OMEGA /= 0. .AND. .NOT. TIMEL) THEN
       IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI' ) THEN
       CALL SWEEPR(DRO,DM,DN,DW,DE,RO,U,V,W,VOL,IMAX,JMAX,KMAX,
     2 OMEGA,OMEX,OMEY,OMEZ,IN,JN,KN,DT)
       ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI' ) THEN
       CALL SWEEPRMF(VAR,PRO,VOL,IMAX,JMAX,KMAX,
     2 OMEGA,OMEX,OMEY,OMEZ,IN,JN,KN,DT,BLKS(NGL)%NPHASE)
       ENDIF
      ENDIF

C ... SCALAR SOURCES

      IF(NSCAL > 0) THEN
         CALL ADDSSC(DFI,SFI,VOL,IMAX,JMAX,KMAX,KSTRID,
     +   IN,JN,KN,DT,MAXSB,NSCAL)
      ENDIF

C ... GRAVITATIONAL ACCELERATION

      IF(GRAVIL) THEN
        CALL GRAVIT(DM,DN,DW,DE,U,V,W,RO,VOL,FRSDEN,PRO,VAR,BLKS,
     2  NGL,IMAX,JMAX,KMAX,IN,JN,KN,DT)
      ENDIF

C ... TIME-DERIVATIVE

      IF(TIMEL) THEN
         CALL TIMDER(DRO,DM,DN,DW,DE,RO,RM,RN,RW,E,ROLE2,RMLE2,RNLE2,
     +   RWLE2,ELE2,ROLE3,RMLE3,RNLE3,RWLE3,ELE3,VOL,IMAX,JMAX,KMAX,
     +   IN,JN,KN,DT,NGL,PDIFF,PLE2,PLE3)
         IF(NSCAL > 0) THEN
            CALL TIMDSC(DFI,FI,FILE2,FILE3,VOL,IMAX,JMAX,KMAX,KSTRID,
     +      IN,JN,KN,DT,MAXSB,NSCAL)
         ENDIF
      ENDIF

C ... FORTIFIED ALGORITHM

      IF(NCHIM > 0) THEN
      IF(LUSGS == 0) PVISC = 1.8     !  TESTED 1.5.1990
      IF(LUSGS == 1) PVISC = 1.8     !  WILL BE TESTED SOON

      CALL TIME3(A1,A2,A3,D1,D2,D3,VOL,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,
     + A3XA,A3YA,A3ZA,DTL,DT,RO,U,V,W,C,P,IMAX,JMAX,KMAX,CFL,VIS,VIST,
     + UROT,VROT,WROT,FRSDEN,FRSVEL,PR,PRT,IDM1,IDM2,IDM3,M,TIMEL,
     + PVISC,ZZZ,1,FRSPRE,CDIFF)
      IF(ITURB /= 9) THEN ! Laminar or algebraic
      CALL FORT(DRO,DM,DN,DW,DE,RO,RM,RN,RW,E,ROFOR,RMFOR,
     +     RNFOR,RWFOR,EFOR,PDFOR,IMAX,JMAX,KMAX,IN,JN,KN,IPRESC,
     +     VOL,RKSI,DTL)
      ELSEIF(ITURB == 9) THEN ! Spalart-Allmaras
      CALL FORTKE(DRO,DM,DN,DW,DE,DRK,DEPS,RO,RM,RN,RW,E,RK,REPS,
     +   ROFOR,RMFOR,RNFOR,RWFOR,EFOR,PDFOR,RKFOR,REFOR,MPFOR,TRM,
     +   TRANSL,VAR,PRO,IMAX,JMAX,KMAX,IN,JN,KN,IPRESC,VOL,RKSI,DTL)
      ENDIF

      ENDIF

C ... Free-surface algorithm

      IF(FRESUL .AND. M2 == 1 .AND. IGRID >= 5) THEN 

c         DSUR(1:NTOT) = DSUR(1:NTOT)   !/VOL(1:NTOT)!*RO(1:NTOT))
*         DSUR(1:NTOT) = DSUR(1:NTOT) + W(1:NTOT)*RO(1:NTOT)*VOL(1:NTOT)
*     +                - WAVE(1:NTOT)*DRO(1:NTOT)*VOL(1:NTOT)

         GXS = ABS(GX/SQRT(GX**2+GY**2+GZ**2))
         GYS = ABS(GY/SQRT(GX**2+GY**2+GZ**2))
         GZS = ABS(GZ/SQRT(GX**2+GY**2+GZ**2))

         DSUR(1:NTOT) = DSUR(1:NTOT) 
     +                + GXS*U(1:NTOT)*RO(1:NTOT)*VOL(1:NTOT)
     +                + GYS*V(1:NTOT)*RO(1:NTOT)*VOL(1:NTOT)
     +                + GZS*W(1:NTOT)*RO(1:NTOT)*VOL(1:NTOT)
     +                - WAVE(1:NTOT)*DRO(1:NTOT)*VOL(1:NTOT)

         CALL PATVSP(DDSUR,DSUR,DSURLE,IMAX,JMAX,KMAX,IN,JN,KN,NGL,M,
     +     NPATCH,ICON,IHF,'FRE',.TRUE.)
  
      ENDIF
      
C *** END OF SOURCES ***************************************************

      IF(ICYCLE == IPRINT) THEN ! PRINT RESIDUALS
         WRITE(3,*)
         WRITE(3,*)' RESULTS AFTER UPDATING THE SOURCE TERM'
         CALL PRINYS(3,DROC,  DRO,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,    DM,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,    DN,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,    DW,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DEC,    DE,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,VISC,  VIS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,CHC,    CH,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(ITURB == 9) THEN
         CALL PRINYS(3,DEPSC,DEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
         IF(FRESUL .AND. M2 == 1) THEN
             CALL PRINYS(3,DSURFC,DSUR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
         DO NS = 1,NSCAL
            CALL PRINYS(3,DFIC(NS),DFI(1,NS), IT,IL,0,IK,
     +      IMAX,JMAX,KMAX,NGL,M)
         ENDDO
      ENDIF

      DEALLOCATE (DSUR,DDSUR,WAVE,SCALEJ)

      RETURN
      END SUBROUTINE RESIDU
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE TURBML(NBL,M,RO,U,V,W,C,CH,A1,D1,A1XA,
     1 A1YA,A1ZA,A2,D2,A2XA,A2YA,A2ZA,A3,D3,A3XA,A3YA,A3ZA,XC,YC,ZC,
     3 DT,GAMMA,DRO,DM,DN,DW,DE,VOL,
     3 F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,OHMI,DELTA,ICP,JCP,KCP,
     4 IJMASK,IMAX,JMAX,KMAX,ICYCLE,INTERI,INTERJ,INTERK,IDERI,
     5 JBOT,JTOP,
     6 IDI1,IDI2,IDI3,IT,IL,IK,IPRINT,PR,PRT,CX,CY,CZ,
     7 CMX,CMY,CMZ,DX,DY,DZ,TOMEGA,XMOM,YMOM,ZMOM,
     8 IBOT,ITOP,KBOT,KTOP,LAMIN,IFLUX,
     9 UBI,VBI,WBI,UBJ,VBJ,WBJ,UBK,VBK,WBK,UTI,VTI,WTI,
     1 UTJ,VTJ,WTJ,UTK,VTK,WTK,
     2 UROT,VROT,WROT,W12,SIJ,MAX11,TURLIM,
     3 FRSDEN,FRSPRE,FRSVEL,T0,DRDH,DRDP,ITURB,PSIGSC,PSIGS2,
     4 FI,F1FI,DFI,SFI,MAXSB,NSCAL,
     5 HAT1,HAT2,HAT3,HAT4,S11,MAXSS,STRESL,ZZZ,MAXW,VORT,SHEAR,
     6 STRAIN,RKSI,VELLAP)
C ... LAST LINE IS FOR SCALARS PPR 11.2.

      USE CHARACTERS
      USE INTEGERS,  ONLY : MAXB 
      USE NS3CO, ONLY : IN, JN, KN

      IMPLICIT NONE

      INTEGER :: MAXSS,ISTRID,JSTRID,KSTRID,IMAX,JMAX,KMAX,IDI1,
     & IDI2,IDI3,IDM1,IDM2,IDM3,LAMIN1,LAMIN2,LAMIN3,LAMIN,ITURB,M,NTOT,
     & III,MAXW,MAW,IDERI,NBL,KBOT,KTOP,ICYCLE,IPRINT,IT,IL,IK,IBOT,
     & ITOP,JBOT,JTOP,INTERI,INTERJ,INTERK,MAX11,MAXSB,NSCAL,IFLUX

      REAL :: PR,PRT,TURLIM,DT,GAMMA,DELTA,CX,CY,CZ,CMX,CMY,CMZ,
     &        DX,DY,DZ,TOMEGA,FRSDEN,FRSPRE,FRSVEL,T0

      REAL :: ZC(*),YC(*),XC(*)

      INTEGER :: ICP(*),JCP(*),KCP(*),IJMASK(*)

      REAL :: RO(*),U(*),V(*),C(*),A1(*),A1XA(*),
     2 A1YA(*),A1ZA(*),A2(*),A2XA(*),A2YA(*),A2ZA(*),
     3 A3(*),A3XA(*),A3YA(*),A3ZA(*),DRO(*),DM(*),DN(*),DE(*),VOL(*),
     4 F1R(*),F1RM(*),F1RN(*),F1E(*),F1RW(*),D1(*),CH(*),TEMP(*),
     5 VIS(*),EPS2(*),VIST(*),
     6 W(*),DW(*),D2(*),D3(*),
     7 OHMI(*),STRAIN(*),UROT(*),VROT(*),WROT(*),DRDH(*),
     8 DRDP(*),PSIGSC(*),PSIGS2(*),RKSI(*),
     1 UBI(*),VBI(*),WBI(*),UBJ(*),VBJ(*),WBJ(*),UBK(*),VBK(*),WBK(*),
     2 UTI(*),VTI(*),WTI(*),UTJ(*),VTJ(*),WTJ(*),UTK(*),VTK(*),WTK(*),
     3 FI(*),F1FI(*),DFI(*),SFI(*),HAT1(*),HAT2(*),HAT3(*),HAT4(*),
     4 W12(MAX11,3),SIJ(MAX11,6),S11(MAXSS,6),VORT(MAXB,*),
     5 SHEAR(MAXB,*),VELLAP(*)

      REAL :: ZZZ(*)
      REAL :: XMOM,YMOM,ZMOM

      LOGICAL :: STRESL

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      KSTRID  = KMAX + 2*KN

C ... ADJUST CELLS WITH FRICTION TO THE GRID LEVEL USED

      IDM1    = (IDI1-1)/2**(M-1) + 1
      IDM2    = (IDI2-1)/2**(M-1) + 1
      IDM3    = MAX(1,(IDI3-1)/2**(M-1)) + 1
      IF(IDI3 == 0) IDM3 = 0

C ... SEPARATE COORDINATE DIRECTIONS FROM LAMIN

      IF (ITURB == 0) THEN
         LAMIN1  = 0
         LAMIN2  = 0
         LAMIN3  = 0
      ELSE
         LAMIN1  =  LAMIN/100
         LAMIN2  = (LAMIN - LAMIN1*100)/10
         LAMIN3  =  LAMIN - LAMIN1*100 - LAMIN2*10
      ENDIF

C *************************************************************************
C                                                                         *
C ... CALLING ROUTINE FOR ALGEBRAIC (MIXING LENGTH) TURBULENCE MODELS     *
C                                                                         *
C *************************************************************************

      NTOT   = ISTRID*JSTRID*KSTRID

      IF(M == 1) THEN
       CALL ADJUIN(EPS2,1.,IMAX,JMAX,KMAX,IN,JN,KN)
       CALL ADJUIN(VIST,0.,IMAX,JMAX,KMAX,IN,JN,KN)
      ENDIF

      IF(LAMIN /= 0) THEN

      CALL DERFUN(OHMI,W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),
     +     SIJ(1,3),SIJ(1,4),SIJ(1,5),SIJ(1,6),U,V,W,A1,A2,A3,VOL,
     +     D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     +     XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M,STRAIN,VELLAP)

      DO III = 1,3
        VORT(1:NTOT,III)  = W12(1:NTOT,III)
      ENDDO
      DO III = 1,6
        SHEAR(1:NTOT,III) = SIJ(1:NTOT,III)
      ENDDO

C **********************************************************************
      IF (M == 1) THEN
C **********************************************************************

C ... TURBULENT VISCOSITY

      IF(LAMIN3 /= 0) THEN
      CALL DOMAW(MAXW,IMAX,JMAX,IN,JN,MAW)
      IF(ITURB == 1) THEN
         CALL TURBBL(EPS2,VIST,VIS,OHMI,U,V,W,RO,D3,F1R,F1RM,
     2   PR,PRT,IMAX,JMAX,KMAX,IN,JN,KN,KBOT,KTOP,KCP,M,TURLIM,
     3   UBK,VBK,WBK,UTK,VTK,WTK,nbl,ZZZ,MAW,MAXW,RKSI)
      ELSE IF(ITURB == 2) THEN
         CALL TURBCS(EPS2,VIST,VIS,OHMI,U,V,W,RO,D3,F1R,F1RM,
     2   PR,PRT,IMAX,JMAX,KMAX,IN,JN,KN,KBOT,KTOP,KCP,M,TURLIM,
     3   UBK,VBK,WBK,UTK,VTK,WTK,nbl,ZZZ,MAW,MAXW,RKSI)
      ELSE IF(LAMIN3 == 3) THEN
         CALL TURBSC(EPS2,VIST,VIS,OHMI,U,V,W,RO,D3,
     2   PR,PRT,IMAX,JMAX,KMAX,IN,JN,KN,KBOT,KTOP,KCP,M,TURLIM,
     3   ZZZ,MAW,MAXW,RKSI)
      ENDIF
         IF(ICYCLE == IPRINT) THEN
            WRITE(3,*)
            WRITE(3,*) ' AFTER K-DIRECTION'
            CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
         ENDIF
      ENDIF

      IF(LAMIN1 /= 0) THEN
      CALL DOMAW(MAXW,JMAX,KMAX,JN,KN,MAW)

      CALL SORT41(EPS2,VIST,VIS,OHMI,D1,ISTRID,JSTRID,KSTRID,1,ZZZ)
      CALL SORT40(U,V,W,RO,F1R,F1RM,    ISTRID,JSTRID,KSTRID,1,ZZZ)
      IF(ITURB == 1) THEN
         CALL TURBBL(EPS2,VIST,VIS,OHMI,V,W,U,RO,D1,F1R,F1RM,
     2   PR,PRT,JMAX,KMAX,IMAX,JN,KN,IN,IBOT,ITOP,ICP,M,TURLIM,
     3   VBI,WBI,UBI,VTI,WTI,UTI,nbl,ZZZ,MAW,MAXW,RKSI)
      ELSE IF(ITURB == 2) THEN
         CALL TURBCS(EPS2,VIST,VIS,OHMI,V,W,U,RO,D1,F1R,F1RM,
     2   PR,PRT,JMAX,KMAX,IMAX,JN,KN,IN,IBOT,ITOP,ICP,M,TURLIM,
     3   VBI,WBI,UBI,VTI,WTI,UTI,nbl,ZZZ,MAW,MAXW,RKSI)
      ELSE IF(LAMIN1 == 3) THEN
         CALL TURBSC(EPS2,VIST,VIS,OHMI,V,W,U,RO,D1,
     2   PR,PRT,JMAX,KMAX,IMAX,JN,KN,IN,IBOT,ITOP,ICP,M,TURLIM,
     3   ZZZ,MAW,MAXW,RKSI)
      ENDIF
      CALL SORT41(EPS2,VIST,VIS,OHMI,D1,JSTRID,KSTRID,ISTRID,2,ZZZ)
      CALL SORT40(U,V,W,RO,F1R,F1RM,    JSTRID,KSTRID,ISTRID,2,ZZZ)
         IF(ICYCLE == IPRINT) THEN
            WRITE(3,*)
            WRITE(3,*) ' AFTER I-DIRECTION'
            CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
         ENDIF
      ENDIF

      IF(LAMIN2 /= 0) THEN
      CALL DOMAW(MAXW,KMAX,IMAX,KN,IN,MAW)
      CALL SORT41(EPS2,VIST,VIS,OHMI,D2,ISTRID,JSTRID,KSTRID,2,ZZZ)
      CALL SORT40(U,V,W,RO,F1R,F1RM,    ISTRID,JSTRID,KSTRID,2,ZZZ)
      IF(ITURB == 1) THEN
         CALL TURBBL(EPS2,VIST,VIS,OHMI,W,U,V,RO,D2,F1R,F1RM,
     2   PR,PRT,KMAX,IMAX,JMAX,KN,IN,JN,JBOT,JTOP,JCP,M,TURLIM,
     3   WBJ,UBJ,VBJ,WTJ,UTJ,VTJ,nbl,ZZZ,MAW,MAXW,RKSI)
      ELSE IF(ITURB == 2) THEN
         CALL TURBCS(EPS2,VIST,VIS,OHMI,W,U,V,RO,D2,F1R,F1RM,
     2   PR,PRT,KMAX,IMAX,JMAX,KN,IN,JN,JBOT,JTOP,JCP,M,TURLIM,
     3   WBJ,UBJ,VBJ,WTJ,UTJ,VTJ,nbl,ZZZ,MAW,MAXW,RKSI)
      ELSE IF(LAMIN2 == 3) THEN
         CALL TURBSC(EPS2,VIST,VIS,OHMI,W,U,V,RO,D2,
     2   PR,PRT,KMAX,IMAX,JMAX,KN,IN,JN,JBOT,JTOP,JCP,M,TURLIM,
     3   ZZZ,MAW,MAXW,RKSI)
      ENDIF

      CALL SORT41(EPS2,VIST,VIS,OHMI,D2,KSTRID,ISTRID,JSTRID,1,ZZZ)
      CALL SORT40(U,V,W,RO,F1R,F1RM,    KSTRID,ISTRID,JSTRID,1,ZZZ)
         IF(ICYCLE == IPRINT) THEN
            WRITE(3,*)
            WRITE(3,*) ' AFTER J-DIRECTION AT THE END OF THE CYCLE'
            WRITE(3,*) ' THESE ARE APPLIED THROUGHOUT THE NEXT CYCLE'
            CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
         ENDIF
      ENDIF

      ENDIF

      ENDIF

      RETURN
      END SUBROUTINE TURBML
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SWEEP(DRO,DM,DN,DW,DE,F3R,F3RM,F3RN,F3RW,F3E,VOL,
     2 IMAX,JMAX,KMAX,KSTRID,IN,JN,KN,DT,IDO)

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,IDO,ISTRID,JSTRID,KSTRID,
     2     I,K,N,IA,IL,IJ,J1
      REAL :: VOL(*),DRO(*),DM(*),DN(*),DE(*),F3R(*),
     2     F3RM(*),F3RN(*),F3RW(*),F3E(*),DW(*)
      REAL :: DT,DT1
C
C ... EXPLICIT STEP OF THE LU-FACTORED METHOD
C
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      IF(IDO == 0) THEN         ! first two sweeps
      DO 1000 K = 1,KMAX
      IA      = (KN+K-1)*IL + JN*ISTRID + IN
         DO 1000 IJ = 1,IMAX*JMAX
         J1 = (IJ-1)/IMAX    ! J1 = J-1
         N  = IJ + J1*2*IN + IA
         DRO(N)  = DRO(N)- (F3R(N+KSTRID)  - F3R(N) )
         DM(N)   = DM(N) - (F3RM(N+KSTRID) - F3RM(N))
         DN(N)   = DN(N) - (F3RN(N+KSTRID) - F3RN(N))
         DW(N)   = DW(N) - (F3RW(N+KSTRID) - F3RW(N))
         DE(N)   = DE(N) - (F3E(N+KSTRID)  - F3E(N) )
1000  CONTINUE
      ELSEIF(IDO == 1) THEN     ! last sweep
      DO 2000 K = 1,KMAX
      IA      = (KN+K-1)*IL + JN*ISTRID + IN
         DO 2000 IJ = 1,IMAX*JMAX
         J1 = (IJ-1)/IMAX    ! J1 = J-1
         N  = IJ + J1*2*IN + IA
         DT1     = 1./VOL(N)
         DRO(N)  = (DRO(N)- (F3R(N+KSTRID)  - F3R(N) ))*DT1
         DM(N)   = (DM(N) - (F3RM(N+KSTRID) - F3RM(N)))*DT1
         DN(N)   = (DN(N) - (F3RN(N+KSTRID) - F3RN(N)))*DT1
         DW(N)   = (DW(N) - (F3RW(N+KSTRID) - F3RW(N)))*DT1
         DE(N)   = (DE(N) - (F3E(N+KSTRID)  - F3E(N) ))*DT1
2000  CONTINUE
      ENDIF
      RETURN
      END SUBROUTINE SWEEP
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE FORT(DRO,DM,DN,DW,DE,RO,RM,RN,RW,E,ROFOR,RMFOR,
     +     RNFOR,RWFOR,EFOR,PDFOR,IMAX,JMAX,KMAX,IN,JN,KN,IPRESC,
     +     VOL,RKSI,DTL)

      REAL :: DRO(*),DM(*),DN(*),DW(*),DE(*),RO(*),RM(*),
     + RN(*),RW(*),E(*),ROFOR(*),RMFOR(*),RNFOR(*),
     + RWFOR(*),EFOR(*),PDFOR(*),VOL(*),RKSI(*),DTL(*)
C
C ... ADD FORTIFIED SOURCE TERM WITH ALGEBRAIC MODEL. *FOR CONTAINS
C ... THE INTERPOLATED VALUES, RKSI IS IN THE RANGE 1...1.e+10.
C
      EPS     = 1.E-20
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      DO 1000 K = 1,KMAX
      IA      = (KN+K-1)*IL + JN*ISTRID
      DO 1000 I = 1,JMAX*ISTRID
      N       = IA + I
      YPDT    = RKSI(N)/(DTL(N)+EPS)
      DRO(N)  = DRO(N)  + YPDT*(ROFOR(N)  - RO(N)) ! *VOL(N)  
      DM(N)   = DM(N)   + YPDT*(RMFOR(N)  - RM(N)) ! *VOL(N)  
      DN(N)   = DN(N)   + YPDT*(RNFOR(N)  - RN(N)) ! *VOL(N) 
      DW(N)   = DW(N)   + YPDT*(RWFOR(N)  - RW(N)) ! *VOL(N)  
      DE(N)   = DE(N)   + YPDT*(EFOR(N)   - E(N))  ! *VOL(N)
1000  CONTINUE

      RETURN
      END SUBROUTINE FORT
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE FIN(TEMP,U,V,W,PDIFF,DTEMP,DU,DV,DW,DP,TOLD,UOLD,VOLD,
     2     WOLD,POLD,RK,REPS,DRK,DEPS,RKOLD,EPSOLD,RKLIM,EPSLIM,PRO,VAR,
     3     FI,DFI,FIOLD,RLOLIM,UPPLIM,IMAX,JMAX,KMAX,MAXSB,NSCAL,NSCA2,
     4     ITURB,IPRESC,TURLIM,VIS,TRANSL,TRM,BLKS,NGL,ICYCLE)

      USE TYPE_ARRAYS
      USE NS3CO, ONLY : IN, JN, KN

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,MAXSB,NSCAL,NSCA2,ITURB,IPRESC,
     &           ISTRID,JSTRID,I,J,K,IL,KA,JJ,N,NS,IPHASE,NTOT,
     &           IUPTEM,NGL,ISTATE,ICYCLE
      REAL :: TEMP(*),U(*),V(*),W(*),PDIFF(*),DTEMP(*),DU(*),DV(*),
     &        DW(*),DP(*),TOLD(*),UOLD(*),VOLD(*),WOLD(*),POLD(*),
     &        RK(*),REPS(*),DRK(*),DEPS(*),RKOLD(*),EPSOLD(*),VIS(*)
      REAL :: FI(MAXSB,MAX(1,NSCAL)),DFI(MAXSB,MAX(1,NSCAL)),
     &        FIOLD(MAXSB,MAX(1,NSCAL)),UPPLIM(*),RLOLIM(*)
      REAL :: RKLIM,EPSLIM,RKOLDN,EPOLDN,ABSDRK,ABSDEP,XOLDN,DPSAT,
     2     DPMIN,DPMAX,TURLIM,ABSDU2,ABSDV2,ABSDW2,UOLDN,VOLDN,WOLDN

      TYPE(PROPERTIES)       :: PRO(*)
      TYPE(MPHASE_VARIABLES) :: VAR(*)
      TYPE(INTERMITTENCY)    :: TRM(*)
      TYPE(BLOCKS)           :: BLKS(*)

      CHARACTER (LEN=10) :: SOLUTION_TYPE
      LOGICAL :: TRANSL

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
      NTOT    = IL*(KMAX+2*KN)
      SOLUTION_TYPE = BLKS(NGL)%SOLUTION_TYPE
C
C ... VALUES AFTER THE INTEGRATION STEP
      
      IF(ITURB <= 2 .OR. ITURB == 8) THEN ! Algebraic (single-phase) model

      DO 1000 K = 1,KMAX
      KA      = (KN+K-1)*IL
      DO 1000 J = 1,JMAX
      JJ      = (JN+J-1)*ISTRID + IN + KA
      DO 1000 I = 1,IMAX
         N       = JJ + I
         TEMP(N) = TOLD(N)  + DTEMP(N)
         U(N)    = UOLD(N)  + DU(N)
         V(N)    = VOLD(N)  + DV(N)
         W(N)    = WOLD(N)  + DW(N)
         PDIFF(N)= POLD(N)  + DP(N)
1000  CONTINUE

      ELSEIF(ITURB >= 3 .AND. ITURB /= 8) THEN ! Single-phase or cavitation model

      DO K = 1,KMAX
      KA      = (KN+K-1)*IL
      DO J = 1,JMAX
      JJ      = (JN+J-1)*ISTRID + IN + KA
      DO I = 1,IMAX
         N       = JJ + I

         IF(SOLUTION_TYPE == 'CAVIT') THEN ! Check the phase boundary
c         DPSAT   = ABS(POLD(N) - PRO(N)%DPSAT)
         DPSAT   = ABS((TEMP(N)-PRO(N)%TSAT)*PRO(I)%DPSDT)
c        write(777,*) iphase,n,PRO(N)%PSAT,PRO(N)%DPSAT,DPSAT
         DPMIN   = -1.5*DPSAT
         DPMAX   = -DPMIN
c         DP(N)   = MAX(DP(N),DPMIN)
c         DP(N)   = MIN(DP(N),DPMAX)
         DO IPHASE = 1,NPHASES
         IUPTEM  = BLKS(NGL)%IUPTEM(IPHASE)
         IF(IUPTEM == 1) THEN ! Saturated
         PRO(N)%TEMP(IPHASE) = PRO(N)%TSAT
         PRO(N)%DTEMP(IPHASE)= PRO(N)%TSAT
         ELSEIF(IUPTEM == 2) THEN ! Update properties
         PRO(N)%TEMP(IPHASE) = VAR(N)%TOLD(IPHASE)+VAR(N)%DTEMP(IPHASE)
         PRO(N)%DTEMP(IPHASE)= VAR(N)%DTOLD(IPHASE)+VAR(N)%DTEMP(IPHASE)
         ENDIF ! IUPTEM
         XOLDN   = VAR(N)%XOLD(IPHASE)+VAR(N)%DX(IPHASE)
         XOLDN   = MIN(1.,XOLDN) 
         XOLDN   = MAX(0.,XOLDN)
         VAR(N)%X(IPHASE)  = .1*VAR(N)%XOLD(IPHASE)+.9*XOLDN
cc        PRO(N)%ALPO(IPHASE)  = VAR(N)%XOLD(IPHASE)+VAR(N)%DX(IPHASE)
cc        TEMP(N) = TOLD(N)  + DTEMP(N) !/(1.+ABSDT/TOLDN)
         ENDDO

         VAR(N)%X(1)  = 1.- VAR(N)%X(2)

c         IF(VAR(N)%X(1) >= .5) THEN
c
c            PRO(N)%TEMP(2)  = PRO(N)%TSAT
c            PRO(N)%DTEMP(2) = PRO(N)%TSAT
c         ELSE
c            PRO(N)%TEMP(1)  = PRO(N)%TSAT
c            PRO(N)%DTEMP(1) = PRO(N)%TSAT
c         ENDIF
c         DO IPHASE = 1,NPHASES
c         PRO(I)%TEMP(2) = W1/(LOG(P(I)) - V1)

c         ENDDO
         ELSE
c        TOLDN   = 0.05*ABS(TOLD(N))
c        ABSDT   = ABS(DTEMP(N))
         ISTATE  = BLKS(NGL)%ISTATE(1)
         IF(ISTATE == 10 .OR. ISTATE == 11) DTEMP(N) = 0. ! Fully incompressible
         TEMP(N) = TOLD(N)  + DTEMP(N) !/(1.+ABSDT/TOLDN)
         ENDIF ! FLUID and CAVIT, the following for both

         U(N)    = UOLD(N)   + DU(N)
         V(N)    = VOLD(N)   + DV(N)
         W(N)    = WOLD(N)   + DW(N)
         PDIFF(N)= POLD(N)   + DP(N)
         RKOLDN  = .45*RKOLD(N)   ! Oli .45
         IF(ITURB /= 9) THEN
            EPOLDN  = .90*EPSOLD(N)  ! Oli .90 PSEUCOlla
         ELSEIF(ITURB == 9) THEN
            EPOLDN  = MIN(.45*EPSOLD(N),0.1*TURLIM*VIS(N))
         ENDIF
         ABSDRK  = ABS(DRK(N))
         ABSDEP  = ABS(DEPS(N))
         RK(N)   = RKOLD(N)  + DRK(N) /(1.+ABSDRK/RKOLDN)
         REPS(N) = EPSOLD(N) + DEPS(N)/(1.+ABSDEP/EPOLDN)

      ENDDO; ENDDO; ENDDO 

      CALL LOLIM(  RK,IMAX,JMAX,KMAX,IN,JN,KN,RKLIM)
      IF(ITURB < 8) THEN 
         CALL LOLIM(REPS,IMAX,JMAX,KMAX,IN,JN,KN,EPSLIM)
      ELSE IF(ITURB == 9) THEN ! SPALART_Allmaras
         CALL LOLIM(REPS,IMAX,JMAX,KMAX,IN,JN,KN,0.1*EPSLIM)
      ENDIF


      IF(SOLUTION_TYPE == 'MULTI') THEN ! Multi-phase model

      DO K = 1,KMAX
      KA      = (KN+K-1)*IL
      DO J = 1,JMAX
      JJ      = (JN+J-1)*ISTRID + IN + KA
      DO I = 1,IMAX
         N       = JJ + I
         DO IPHASE = 1,NPHASES
         IUPTEM  = BLKS(NGL)%IUPTEM(IPHASE)
         IF(IUPTEM == 1) THEN ! Saturated
         PRO(N)%TEMP(IPHASE) = PRO(N)%TSAT
         PRO(N)%DTEMP(IPHASE)= PRO(N)%TSAT
         ELSEIF(IUPTEM == 2) THEN ! Update properties
         PRO(N)%TEMP(IPHASE) = VAR(N)%TOLD(IPHASE) +VAR(N)%DTEMP(IPHASE)
         PRO(N)%DTEMP(IPHASE)= VAR(N)%DTOLD(IPHASE)+VAR(N)%DTEMP(IPHASE)
         ENDIF ! IUPTEM
         XOLDN   = VAR(N)%XOLD(IPHASE)+VAR(N)%DX(IPHASE)
         XOLDN   = MIN(1.,XOLDN)
         XOLDN   = MAX(0.,XOLDN)
         VAR(N)%X(IPHASE)  = .1*VAR(N)%XOLD(IPHASE)+.9*XOLDN
         ENDDO

         VAR(N)%X(1)  = 1.- VAR(N)%X(2)

         U(N)    = UOLD(N)   + DU(N)
         V(N)    = VOLD(N)   + DV(N)
         W(N)    = WOLD(N)   + DW(N)

         VAR(N)%U= VAR(N)%UOLD + VAR(N)%DM
         VAR(N)%V= VAR(N)%VOLD + VAR(N)%DN
         VAR(N)%W= VAR(N)%WOLD + VAR(N)%DW

         IF(VAR(N)%ALFA(1) < 1.E-6) THEN
            VAR(N)%U(1) = VAR(N)%U(2)
            VAR(N)%V(1) = VAR(N)%V(2)
            VAR(N)%W(1) = VAR(N)%W(2)
         PRO(N)%TEMP(1) = PRO(N)%TSAT
         PRO(N)%DTEMP(1)= PRO(N)%TSAT
         ENDIF 
         IF(VAR(N)%ALFA(2) < 1.E-6) THEN
            VAR(N)%U(2) = VAR(N)%U(1)
            VAR(N)%V(2) = VAR(N)%V(1)
            VAR(N)%W(2) = VAR(N)%W(1)
         PRO(N)%TEMP(2) = PRO(N)%TSAT
         PRO(N)%DTEMP(2)= PRO(N)%TSAT
         ENDIF 

         PDIFF(N)= POLD(N)   + DP(N)

         RKOLDN  = .45*RKOLD(N)   ! Oli .45
         IF(ITURB /= 9) THEN
            EPOLDN  = .90*EPSOLD(N)  ! Oli .90 PSEUCOlla
         ELSEIF(ITURB == 9) THEN
            EPOLDN  = MIN(.45*EPSOLD(N),0.1*TURLIM*VIS(N))
         ENDIF
         ABSDRK  = ABS(DRK(N))
         ABSDEP  = ABS(DEPS(N))
         RK(N)   = RKOLD(N)  + DRK(N) /(1.+ABSDRK/RKOLDN)
         REPS(N) = EPSOLD(N) + DEPS(N)/(1.+ABSDEP/EPOLDN)
      ENDDO; ENDDO; ENDDO

      CALL LOLIM(  RK,IMAX,JMAX,KMAX,IN,JN,KN,RKLIM)
      IF(ITURB < 8) THEN 
         CALL LOLIM(REPS,IMAX,JMAX,KMAX,IN,JN,KN,EPSLIM)
      ELSE IF(ITURB == 9) THEN ! SPALART_Allmaras
         CALL LOLIM(REPS,IMAX,JMAX,KMAX,IN,JN,KN,0.1*EPSLIM)
      ENDIF

      ENDIF ! MULTI


	IF (TRANSL) THEN  !Intermittency variables

      DO K = 1,KMAX
      KA      = (KN+K-1)*IL
      DO J = 1,JMAX
      JJ      = (JN+J-1)*ISTRID + IN + KA
      DO I = 1,IMAX
         N       = JJ + I
         TRM(N)%G   = TRM(N)%GOLD   + TRM(N)%DG
         TRM(N)%RET = TRM(N)%RETOLD + TRM(N)%DRET
         TRM(N)%G   = MAX(TRM(N)%G,   0.)
         TRM(N)%RET = MAX(TRM(N)%RET, 0.)
	ENDDO ; ENDDO ; ENDDO
	ENDIF

      ENDIF !End first IF sentence


C ... FOR SCALAR EQS PPR 14.2
      IF(NSCAL > 0) THEN
      DO 1200 NS = 1,NSCAL
      DO 1200 K = 1,KMAX
      KA      = (KN+K-1)*IL
      DO 1200 J = 1,JMAX
      JJ      = (JN+J-1)*ISTRID + IN + KA
      DO 1200 I = 1,IMAX
         N        = JJ + I
         FI(N,NS) = FIOLD(N,NS)  + DFI(N,NS)
1200  CONTINUE

      ENDIF

      IF(NSCA2 > 0) THEN
      CALL LOLISC(FI,IMAX,JMAX,KMAX,IN,JN,KN,RLOLIM,UPPLIM,MAXSB,NSCA2)
      ENDIF

      IF(ITURB >= 21) THEN      ! realizability 
      DO  K = 1,KMAX
      KA      = (KN+K-1)*IL
      DO  J = 1,JMAX
      JJ      = (JN+J-1)*ISTRID + IN + KA
      DO  I = 1,IMAX
         N        = JJ + I

         FI(N,2)=SIGN(MIN(ABS(FI(N,2)),SQRT(FI(N,1)*FI(N,4))),FI(N,2))
         FI(N,3)=SIGN(MIN(ABS(FI(N,3)),SQRT(FI(N,1)*FI(N,6))),FI(N,3))
         FI(N,5)=SIGN(MIN(ABS(FI(N,5)),SQRT(FI(N,4)*FI(N,6))),FI(N,5))
      ENDDO
      ENDDO
      ENDDO
      ENDIF

      RETURN
      END SUBROUTINE FIN
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
C	************ MODIFIED 7.6.2012 by Juho N ********************
      SUBROUTINE SWEEPK(DRO,DM,DN,DW,DE,DRK,DEPS,F3R,F3RM,F3RN,F3RW,
     2 F3E,F3RK,F3EPS,VOL,VAR,TRM,IMAX,JMAX,KMAX,KSTRID,IN,JN,KN,
     3 DT,IDO,MULPHL,TRANSL,MULPHC,PRC)

      USE TYPE_ARRAYS

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,ISTRID,JSTRID,KSTRID,
     +           IDO,I,K,N,IA,IL,IPHASE,IJ,J1,mm,nn,ll 
      REAL    :: VOL(*),DRO(*),DM(*),DN(*),DE(*),DRK(*),DEPS(*),F3R(*),
     +           F3RM(*),F3RN(*),F3RW(*),F3E(*),DW(*),F3RK(*),F3EPS(*)
      REAL    :: DT1,DT,VARA
      LOGICAL :: MULPHL, TRANSL

      TYPE(MPHASE_VARIABLES) :: VAR(*)
      TYPE(INTERMITTENCY)    :: TRM(*)
      TYPE(PRE_COR)          :: PRC(*)
      CHARACTER(*)           :: MULPHC
C
C ... EXPLICIT STEP OF THE LU-FACTORED METHOD
C
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      IF(IDO == 0) THEN         ! first two  sweeps
      DO 1000 K = 1,KMAX
      IA = (KN+K-1)*IL + JN*ISTRID + IN
         DO 1000 IJ = 1,IMAX*JMAX
         J1 = (IJ-1)/IMAX    ! J1 = J-1
         N  = IJ + J1*2*IN + IA 	!index
         DRO(N)  = DRO(N)- (F3R(N+KSTRID)  - F3R(N) )	   ! Residuaalit D__(N)
         DM(N)   = DM(N) - (F3RM(N+KSTRID) - F3RM(N))
         DN(N)   = DN(N) - (F3RN(N+KSTRID) - F3RN(N))
         DW(N)   = DW(N) - (F3RW(N+KSTRID) - F3RW(N))
         DE(N)   = DE(N) - (F3E(N+KSTRID)  - F3E(N) )
         DRK(N)  = DRK(N) -(F3RK(N+KSTRID) - F3RK(N))
         DEPS(N) = DEPS(N)-(F3EPS(N+KSTRID)- F3EPS(N))
         IF(MULPHL) THEN
         DO IPHASE = 1,NPHASES
         VAR(N)%DX(IPHASE) = VAR(N)%DX(IPHASE) -
     &        (VAR(N+KSTRID)%FRO(IPHASE) - VAR(N)%FRO(IPHASE))
         VAR(N)%DE(IPHASE) = VAR(N)%DE(IPHASE) -
     &        (VAR(N+KSTRID)%FE(IPHASE)  - VAR(N)%FE(IPHASE))
         ENDDO

         IF(MULPHC == 'MULTI') THEN

         PRC(N)%DPDX = PRC(N)%DPDX -(PRC(N+KSTRID)%FPM - PRC(N)%FPM)
         PRC(N)%DPDY = PRC(N)%DPDY -(PRC(N+KSTRID)%FPN - PRC(N)%FPN)
         PRC(N)%DPDZ = PRC(N)%DPDZ -(PRC(N+KSTRID)%FPW - PRC(N)%FPW)

         DO IPHASE = 1,NPHASES

         VAR(N)%DM(IPHASE) = VAR(N)%DM(IPHASE) -
     &        (VAR(N+KSTRID)%FRM(IPHASE) - VAR(N)%FRM(IPHASE))
         VAR(N)%DN(IPHASE) = VAR(N)%DN(IPHASE) -
     &        (VAR(N+KSTRID)%FRN(IPHASE) - VAR(N)%FRN(IPHASE))
         VAR(N)%DW(IPHASE) = VAR(N)%DW(IPHASE) -
     &        (VAR(N+KSTRID)%FRW(IPHASE) - VAR(N)%FRW(IPHASE))
         ENDDO
         ENDIF ! MULPHC
         ENDIF ! MULPHL

         IF(TRANSL) THEN   !Intermittency variables
         TRM(N)%DG   = TRM(N)%DG   -(TRM(N+KSTRID)%FG   -TRM(N)%FG)
         TRM(N)%DRET = TRM(N)%DRET -(TRM(N+KSTRID)%FRET -TRM(N)%FRET)
         ENDIF

1000  CONTINUE

      ELSEIF(IDO == 1) THEN     ! last sweep
      DO 2000 K = 1,KMAX
      IA = (KN+K-1)*IL + JN*ISTRID + IN
         DO 2000 IJ = 1,IMAX*JMAX
         J1 = (IJ-1)/IMAX    ! J1 = J-1
         N  = IJ + J1*2*IN + IA
         DT1     = 1./VOL(N)
         DRO(N)  = (DRO(N)- (F3R(N+KSTRID)  - F3R(N) )) *DT1
         DM(N)   = (DM(N) - (F3RM(N+KSTRID) - F3RM(N))) *DT1
         DN(N)   = (DN(N) - (F3RN(N+KSTRID) - F3RN(N))) *DT1
         DW(N)   = (DW(N) - (F3RW(N+KSTRID) - F3RW(N))) *DT1
         DE(N)   = (DE(N) - (F3E(N+KSTRID)  - F3E(N) )) *DT1
         DRK(N)  = (DRK(N) -(F3RK(N+KSTRID) - F3RK(N))) *DT1
         DEPS(N) = (DEPS(N)-(F3EPS(N+KSTRID)- F3EPS(N)))*DT1
         IF(MULPHL) THEN
         DO IPHASE = 1,NPHASES
         VARA = VAR(N)%DX(IPHASE)
         VAR(N)%DX(IPHASE) = (VAR(N)%DX(IPHASE) -
     2  (VAR(N+KSTRID)%FRO(IPHASE) - VAR(N)%FRO(IPHASE))) *DT1
         VAR(N)%DE(IPHASE) = (VAR(N)%DE(IPHASE) -
     2  (VAR(N+KSTRID)%FE(IPHASE)  - VAR(N)%FE(IPHASE)))  *DT1
         ENDDO
         IF(MULPHC == 'MULTI') THEN

         PRC(N)%DPDX =-(PRC(N)%DPDX -(PRC(N+KSTRID)%FPM-PRC(N)%FPM))*DT1
         PRC(N)%DPDY =-(PRC(N)%DPDY -(PRC(N+KSTRID)%FPN-PRC(N)%FPN))*DT1
         PRC(N)%DPDZ =-(PRC(N)%DPDZ -(PRC(N+KSTRID)%FPW-PRC(N)%FPW))*DT1

         DO IPHASE = 1,NPHASES
         VAR(N)%DM(IPHASE) = (VAR(N)%DM(IPHASE) -
     &        (VAR(N+KSTRID)%FRM(IPHASE) - VAR(N)%FRM(IPHASE))) *DT1
         VAR(N)%DN(IPHASE) = (VAR(N)%DN(IPHASE) -
     &        (VAR(N+KSTRID)%FRN(IPHASE) - VAR(N)%FRN(IPHASE))) *DT1
         VAR(N)%DW(IPHASE) = (VAR(N)%DW(IPHASE) -
     &        (VAR(N+KSTRID)%FRW(IPHASE) - VAR(N)%FRW(IPHASE))) *DT1

         ENDDO
         ENDIF ! MULPHC
         ENDIF ! MULPHL

         IF(TRANSL) THEN   !Intermittency variables 
         TRM(N)%DG  =(TRM(N)%DG  -(TRM(N+KSTRID)%FG  -TRM(N)%FG)  )*DT1
         TRM(N)%DRET=(TRM(N)%DRET-(TRM(N+KSTRID)%FRET-TRM(N)%FRET))*DT1
         ENDIF

2000  CONTINUE
      ENDIF

C ... nan trappi
*      CALL NATRAP(DM,IMAX,JMAX,KMAX,IN,JN,KN,NBL,IDO,'dRM/S')

      RETURN
      END SUBROUTINE SWEEPK
C	************ MOD ENDS 7.6.2012 by Juho N *************************
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE ADDSKE(DRK,DEPS,SRK,RK,REPS,PTUR,SEPS,VOL,
     + IMAX,JMAX,KMAX,KSTRID,IN,JN,KN,DT,TRM,TRANSL)

      USE TYPE_ARRAYS

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,ISTRID,JSTRID,KSTRID,
     +           IL,IJ,K,J1,IA,N
      REAL :: DT,EPS,PEG,POT
      REAL :: VOL(*),DRK(*),DEPS(*),SRK(*),SEPS(*),REPS(*),PTUR(*),RK(*)

      TYPE(INTERMITTENCY) :: TRM(*)

      LOGICAL :: TRANSL

C
C ... ADD SOURCE TERM TO K-EPSILON
C
      EPS    = 1.E-20
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID

      DO K = 1,KMAX
         IA = (KN+K-1)*IL + JN*ISTRID + IN
         DO IJ = 1,IMAX*JMAX
            J1 = (IJ-1)/IMAX     ! J1 = J-1
            N  = IJ + J1*2*IN + IA
            DRK(N)  = DRK(N)  + SRK(N)  
            DEPS(N) = DEPS(N) + SEPS(N) 
         ENDDO
      ENDDO

      IF(TRANSL) THEN
         DO K = 1,KMAX
            IA = (KN+K-1)*IL + JN*ISTRID + IN
            DO IJ = 1,IMAX*JMAX
               J1 = (IJ-1)/IMAX  ! J1 = J-1
               N  = IJ + J1*2*IN + IA
               PEG         = TRM(N)%SG   + TRM(N)%ZG
               POT         = TRM(N)%SRET + TRM(N)%ZRET
               TRM(N)%DG   = TRM(N)%DG   + PEG     
               TRM(N)%DRET = TRM(N)%DRET + POT
            ENDDO 
         ENDDO  ! Antakee mersu 2000
      ENDIF

      RETURN
      END SUBROUTINE ADDSKE
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE FORTKE(DRO,DM,DN,DW,DE,DRK,DEPS,RO,RM,RN,RW,E,RK,REPS,
     + ROFOR,RMFOR,RNFOR,RWFOR,EFOR,PDFOR,RKFOR,REFOR,MPFOR,TRM,TRANSL,
     + VAR,PRO,IMAX,JMAX,KMAX,IN,JN,KN,IPRESC,VOL,RKSI,DTL)

      USE TYPE_ARRAYS

      USE NS3CO, ONLY : MULPHL

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,IPRESC,I,J,K,N,IPHASE,JJ,KA,
     & ISTRID,JSTRID,KSTRID,IL,NTOT

      REAL :: EPS,YPDT

      REAL :: DRO(*),DM(*),DN(*),DW(*),DE(*),DRK(*),DEPS(*),RO(*),RM(*),
     + RN(*),RW(*),E(*),RK(*),REPS(*),ROFOR(*),RMFOR(*),RNFOR(*),
     + RWFOR(*),EFOR(*),PDFOR(*),RKFOR(*),REFOR(*),
     + VOL(*),RKSI(*),DTL(*)

      LOGICAL :: TRANSL ! ,MULPHL ! FMI machine requires this ?!

      TYPE(INTERMITTENCY)    :: TRM(*)
      TYPE(PROPERTIES)       :: PRO(*)
      TYPE(MPHASE_VARIABLES) :: VAR(*)
      TYPE(MPHASE_FORTIFY)   :: MPFOR(*)

C
C ... ADD FORTIFIED SOURCE TERM TO K-EPSILON MODEL. *FOR CONTAINS
C ... THE INTERPOLATED VALUES, RKSI IS IN THE RANGE 1...1.e+10.
C
C
      EPS     = 1.E-20
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
      NTOT    = IL*(KMAX + 2*KN)

      IF(IPRESC == 0) THEN
c      DO N = 1,NTOT
      DO K = 1,KMAX
      KA   = (KN+K-1)*IL
      DO J = 1,JMAX
      JJ   = (JN+J-1)*ISTRID + IN + KA
      DO I = 1,IMAX
         N       = JJ + I
         YPDT    = RKSI(N)/(DTL(N)+EPS)
         DRO(N)  = DRO(N)  + YPDT*(ROFOR(N)  - RO(N))   ! *VOL(N)  
         DM(N)   = DM(N)   + YPDT*(RMFOR(N)  - RM(N))   ! *VOL(N)  
         DN(N)   = DN(N)   + YPDT*(RNFOR(N)  - RN(N))   ! *VOL(N) 
         DW(N)   = DW(N)   + YPDT*(RWFOR(N)  - RW(N))   ! *VOL(N)  
         DE(N)   = DE(N)   + YPDT*(EFOR(N)   - E(N))    ! *VOL(N) 
         DRK(N)  = DRK(N)  + YPDT*(RKFOR(N)  - RK(N))   ! *VOL(N)  
         DEPS(N) = DEPS(N) + YPDT*(REFOR(N)  - REPS(N)) ! *VOL(N)

         IF(TRANSL) THEN 
            TRM(N)%DG   = TRM(N)%DG  +YPDT*(TRM(N)%GFOR  -TRM(N)%G)   ! *VOL(N)
            TRM(N)%DRET = TRM(N)%DRET+YPDT*(TRM(N)%RETFOR-TRM(N)%RET) ! *VOL(N)
         ENDIF 

         IF(MULPHL) THEN
         WRITE(*,*)' Conflict: Density-based solution with multi-phase.'
         WRITE(*,*)' Exiting in FORTKE...'
         STOP
         ENDIF 

      ENDDO
      ENDDO
      ENDDO

      ELSE IF(IPRESC == 2) THEN

      DO N = 1,NTOT
c           call ijkpai(n,imax,jmax,kmax,mmm,nnn,lll)

         YPDT    = RKSI(N)/(DTL(N)+EPS)
C         DRO(N)  = DRO(N)  + YPDT*(ROFOR(N)  - RO(N))  *VOL(N)  
         DM(N)   = DM(N)   + YPDT*(RMFOR(N)  - RM(N))   ! *VOL(N)  
         DN(N)   = DN(N)   + YPDT*(RNFOR(N)  - RN(N))   ! *VOL(N) 
         DW(N)   = DW(N)   + YPDT*(RWFOR(N)  - RW(N))   ! *VOL(N)  
         DE(N)   = DE(N)   + YPDT*(EFOR(N)   - E(N))    ! *VOL(N) 
         DRK(N)  = DRK(N)  + YPDT*(RKFOR(N)  - RK(N))   ! *VOL(N)  
         DEPS(N) = DEPS(N) + YPDT*(REFOR(N)  - REPS(N)) ! *VOL(N) 

         IF(TRANSL) THEN 
            TRM(N)%DG   = TRM(N)%DG  +YPDT*(TRM(N)%GFOR  -TRM(N)%G)   ! *VOL(N)
            TRM(N)%DRET = TRM(N)%DRET+YPDT*(TRM(N)%RETFOR-TRM(N)%RET) ! *VOL(N)
         ENDIF 

         IF(MULPHL) THEN
            DO IPHASE = 1,NPHASES 
               VAR(N)%DX(IPHASE)    = VAR(N)%DX(IPHASE)    
     &                              + YPDT*(MPFOR(N)%XFOR(IPHASE)  
     &                              - VAR(N)%X(IPHASE))
               VAR(N)%DTEMP(IPHASE) = VAR(N)%DTEMP(IPHASE)    
     &                              + YPDT*(MPFOR(N)%DTEMPFOR(IPHASE)  
     &                              - PRO(N)%DTEMP(IPHASE))
            ENDDO
         ENDIF 

      ENDDO

      ELSE IF(IPRESC == 1) THEN

      DO N = 1,NTOT
c           call ijkpai(n,imax,jmax,kmax,mmm,nnn,lll)

         YPDT    = RKSI(N)
C         DRO(N)  = DRO(N)  + YPDT*(ROFOR(N)  - RO(N))  *VOL(N)  
         DM(N)   = DM(N)   + YPDT*(RMFOR(N)  - RM(N))   ! *VOL(N)  
         DN(N)   = DN(N)   + YPDT*(RNFOR(N)  - RN(N))   ! *VOL(N) 
         DW(N)   = DW(N)   + YPDT*(RWFOR(N)  - RW(N))   ! *VOL(N)  
         DE(N)   = DE(N)   + YPDT*(EFOR(N)   - E(N))    ! *VOL(N) 
         DRK(N)  = DRK(N)  + YPDT*(RKFOR(N)  - RK(N))   ! *VOL(N)  
         DEPS(N) = DEPS(N) + YPDT*(REFOR(N)  - REPS(N)) ! *VOL(N) 

         IF(TRANSL) THEN 
            TRM(N)%DG   = TRM(N)%DG  +YPDT*(TRM(N)%GFOR  -TRM(N)%G)   ! *VOL(N)
            TRM(N)%DRET = TRM(N)%DRET+YPDT*(TRM(N)%RETFOR-TRM(N)%RET) ! *VOL(N)
         ENDIF 

         IF(MULPHL) THEN
            DO IPHASE = 1,NPHASES 
               VAR(N)%DX(IPHASE)    = VAR(N)%DX(IPHASE)    
     &                              + YPDT*(MPFOR(N)%XFOR(IPHASE)  
     &                              - VAR(N)%X(IPHASE))
               VAR(N)%DTEMP(IPHASE) = VAR(N)%DTEMP(IPHASE)    
     &                              + YPDT*(MPFOR(N)%DTEMPFOR(IPHASE)  
     &                              - PRO(N)%DTEMP(IPHASE))
            ENDDO
         ENDIF 

      ENDDO

      ELSE

      WRITE(*,*)' No such IPRESC option, exiting...'
      WRITE(13,*)' No such IPRESC option, use IPRESC = 0..2. Exiting...'

      ENDIF

      RETURN
      END SUBROUTINE FORTKE
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE GRAVIT(DM,DN,DW,DE,U,V,W,RO,VOL,FRSDEN,
     2 PRO,VAR,BLKS,NGL,IMAX,JMAX,KMAX,IN,JN,KN,DT)

      USE TYPE_ARRAYS
      USE NS3CO, ONLY : GX, GY, GZ

      IMPLICIT NONE

      INTEGER :: NGL,IMAX,JMAX,KMAX,IN,JN,KN,
     2           ISTRID,JSTRID,IL,K,IA,IJ,J1,N,IPH,IFLUX
      REAL :: VOL(*),DM(*),DN(*),DW(*),RO(*),U(*),V(*),W(*),DE(*)
      REAL :: FRSDEN,FORCE,DT,FRSDE
      TYPE(PROPERTIES) PRO(*)
      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(BLOCKS) BLKS(*)
C
C ... ADD THE GRATATIONAL ACCELERATION TERM. THE MOMENTUM EQUATION
C ... IS INSTALLED BY SUBSTRACTING THE GRAVITY FIELD
C
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      FRSDE   = 0.

C     This is according to Boussinesq:

      IFLUX   = BLKS(NGL)%IFLUX
      IF(IFLUX == 4 .OR. IFLUX == 6 .OR. IFLUX == 7) FRSDE = FRSDEN

      DO 1000 K = 1,KMAX
      IA = (KN+K-1)*IL + JN*ISTRID + IN
      DO 1000 IJ = 1,IMAX*JMAX
      J1 = (IJ-1)/IMAX    ! J1 = J-1
      N  = IJ + J1*2*IN + IA
C      DT1     = 1./VOL(N)
      FORCE   = (RO(N) - FRSDE) 
      DM(N)   =  DM(N) + GX*FORCE
      DN(N)   =  DN(N) + GY*FORCE
      DW(N)   =  DW(N) + GZ*FORCE

c      DE(N)   = DE(N) - (GX*U(N) + GY*V(N) + GZ*W(N))*RO(N)
C ... works only for INCO flux upwinding 26.5.98 PR
      IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI'  .AND.
     +   BLKS(NGL)%SOLUTION_TYPE /= 'CAVIT') THEN
      DE(N)   = DE(N) + (GX*U(N) + GY*V(N) + GZ*W(N))*RO(N) 
      ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'CAVIT') THEN
         DO IPH = 1,NPHASES
            FORCE   = VAR(N)%ALFA(IPH)*PRO(N)%RO(IPH)
            VAR(N)%DE(IPH) = VAR(N)%DE(IPH) +
     +      (GX*U(N) + GY*V(N) + GZ*W(N))*FORCE
         ENDDO
      ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         DO IPH = 1,NPHASES
c            FRSDE = 0.
            VAR(N)%DE(IPH) = VAR(N)%DE(IPH) + 
     +      VAR(N)%ALFA(IPH)*PRO(N)%RO(IPH)*
     +      (GX*VAR(N)%U(IPH) + GY*VAR(N)%V(IPH) + GZ*VAR(N)%W(IPH))
            FORCE   = VAR(N)%ALFA(IPH)*PRO(N)%RO(IPH) - FRSDE
            VAR(N)%DM(IPH) = VAR(N)%DM(IPH) + GX*FORCE 
            VAR(N)%DN(IPH) = VAR(N)%DN(IPH) + GY*FORCE 
            VAR(N)%DW(IPH) = VAR(N)%DW(IPH) + GZ*FORCE 
         ENDDO
      ENDIF

1000  CONTINUE

      RETURN
      END SUBROUTINE GRAVIT
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE ALFAP(DM,DN,DW,DE,U,V,W,RO,VOL,FRSDEN,
     2 PRO,VAR,BLKS,NGL,IMAX,JMAX,KMAX,IN,JN,KN,DT,
     3 GRADAX,GRADAY,GRADAZ,IPHASE,PDIFF)

      USE TYPE_ARRAYS

      IMPLICIT NONE

      INTEGER :: NGL,IMAX,JMAX,KMAX,IN,JN,KN,mmm,nnn,lll,
     2           ISTRID,JSTRID,IL,K,IA,IJ,J1,N,IPH,IFLUX,IPHASE
      REAL :: VOL(*),DM(*),DN(*),DW(*),RO(*),U(*),V(*),W(*),DE(*),
     2        GRADAX(*),GRADAY(*),GRADAZ(*),PDIFF(*)
      REAL :: FRSDEN,FORCE,DT,FRSDE,ALFA
      TYPE(PROPERTIES) PRO(*)
      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(BLOCKS) BLKS(*)
C
C ... ADD THE GRATATIONAL ACCELERATION TERM. THE MOMENTUM EQUATION
C ... IS INSTALLED BY SUBSTRACTING THE GRAVITY FIELD
C
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      DO 1000 K = 1,KMAX
      IA = (KN+K-1)*IL + JN*ISTRID + IN
      DO 1000 IJ = 1,IMAX*JMAX
      J1 = (IJ-1)/IMAX    ! J1 = J-1
      N  = IJ + J1*2*IN + IA
c            call ijkpai(n,imax,jmax,kmax,mmm,nnn,lll)
c         VAR(N)%DM(IPHASE) = VAR(N)%DM(IPHASE) + PRO(N)%DPSAT*GRADAX(N)
c         VAR(N)%DN(IPHASE) = VAR(N)%DN(IPHASE) + PRO(N)%DPSAT*GRADAY(N)
c         VAR(N)%DW(IPHASE) = VAR(N)%DW(IPHASE) + PRO(N)%DPSAT*GRADAZ(N)
c         VAR(N)%DM(IPHASE) = VAR(N)%DM(IPHASE) + PDIFF(N)*GRADAX(N)
c         VAR(N)%DN(IPHASE) = VAR(N)%DN(IPHASE) + PDIFF(N)*GRADAY(N)
c         VAR(N)%DW(IPHASE) = VAR(N)%DW(IPHASE) + PDIFF(N)*GRADAZ(N)
         ALFA = VAR(N)%ALFA(IPHASE)
         VAR(N)%DM(IPHASE) = VAR(N)%DM(IPHASE) - ALFA*GRADAX(N)
         VAR(N)%DN(IPHASE) = VAR(N)%DN(IPHASE) - ALFA*GRADAY(N)
         VAR(N)%DW(IPHASE) = VAR(N)%DW(IPHASE) - ALFA*GRADAZ(N)
c      write(7200+ngl,*) mmm,nnn,PRO(N)%DPSAT*GRADAY(N),
c     + var(n)%alfa(2),gradax(n),graday(n),gradaz(n)
1000  CONTINUE

      RETURN
      END SUBROUTINE ALFAP
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE ALFAPG(DM,DN,DW,DE,U,V,W,RO,VOL,FRSDEN,
     2 PRO,VAR,BLKS,NGL,IMAX,JMAX,KMAX,IN,JN,KN,DT,
     3 PRC,IPHASE,PDIFF)

      USE TYPE_ARRAYS

      IMPLICIT NONE

      INTEGER :: NGL,IMAX,JMAX,KMAX,IN,JN,KN,mmm,nnn,lll,
     2           ISTRID,JSTRID,IL,K,IA,IJ,J1,N,IPH,IFLUX,IPHASE
      REAL :: VOL(*),DM(*),DN(*),DW(*),RO(*),U(*),V(*),W(*),DE(*),
     2        PDIFF(*)
      REAL :: FRSDEN,FORCE,DT,FRSDE,ALFA

      TYPE(PROPERTIES) PRO(*)
      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(BLOCKS) BLKS(*)
      TYPE(PRE_COR) PRC(*)
C
C ... ADD THE GRATATIONAL ACCELERATION TERM. THE MOMENTUM EQUATION
C ... IS INSTALLED BY SUBSTRACTING THE GRAVITY FIELD
C
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      DO 1000 K = 1,KMAX
      IA = (KN+K-1)*IL + JN*ISTRID + IN
      DO 1000 IJ = 1,IMAX*JMAX
      J1 = (IJ-1)/IMAX    ! J1 = J-1
      N  = IJ + J1*2*IN + IA
c            call ijkpai(n,imax,jmax,kmax,mmm,nnn,lll)
         ALFA = VAR(N)%ALFA(IPHASE)
         VAR(N)%DM(IPHASE) = VAR(N)%DM(IPHASE) - ALFA*PRC(N)%DPDX
         VAR(N)%DN(IPHASE) = VAR(N)%DN(IPHASE) - ALFA*PRC(N)%DPDY
         VAR(N)%DW(IPHASE) = VAR(N)%DW(IPHASE) - ALFA*PRC(N)%DPDZ
c      write(7200+ngl,*) mmm,nnn,PRO(N)%DPSAT*GRADAY(N),
c     + var(n)%alfa(2),gradax(n),graday(n),gradaz(n)
1000  CONTINUE

      RETURN
      END SUBROUTINE ALFAPG
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE CORR_EVAP(PRO,VAR,BLKS,
     + IMAX,JMAX,KMAX,IN,JN,KN,NGL,M)

      USE TYPE_ARRAYS
      USE CONSTANTS, ONLY : PII,EPS6,EPS10

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,I,K,N,ISTRID,JSTRID,IL,IA,
     + IPHASE,NGL,II,JJ,J,ISTR,JSTR,KSTR,IJ,J1,IEVAP,mmm,nnn,lll,
     + M,KA

      REAL :: APU

      TYPE(PROPERTIES) PRO(*)
      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(BLOCKS) BLKS(*)

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
        
      ISTR    = 1
      JSTR    = ISTRID
      KSTR    = IL
C
C ... Add dissipation to evaporation rate
C      

      DO K = 1,KMAX
      KA      = (KN+K-1)*IL
      DO J = 2,JMAX-1
      JJ      = (JN+J-1)*ISTRID + IN + KA
      DO I = 2,IMAX-1

         N = JJ + I

         DO IPHASE = 1,BLKS(NGL)%NPHASE
         IF(KMAX >= 3) THEN
         VAR(N)%DX(IPHASE)  = VAR(N)%DX(IPHASE) -.5*VAR(N)%EVAPR(IPHASE) 
     +   +1/12.*(VAR(N+1)%EVAPR(IPHASE) + VAR(N-1)%EVAPR(IPHASE)
     +      +   VAR(N+JSTR)%EVAPR(IPHASE) + VAR(N-JSTR)%EVAPR(IPHASE)
     +      +   VAR(N+IL)%EVAPR(IPHASE) + VAR(N-IL)%EVAPR(IPHASE))

          VAR(N)%DE(IPHASE)  = VAR(N)%DE(IPHASE) -
     +    .5*VAR(N)%EVAPR(IPHASE) * PRO(N)%HSAT(IPHASE) + 1./12 *
     +      (VAR(N+1)%EVAPR(IPHASE) * PRO(N+1)%HSAT(IPHASE) + 
     +       VAR(N-1)%EVAPR(IPHASE) * PRO(N-1)%HSAT(IPHASE) +
     +       VAR(N+JSTR)%EVAPR(IPHASE) * PRO(N+JSTR)%HSAT(IPHASE) +
     +       VAR(N-JSTR)%EVAPR(IPHASE) * PRO(N-JSTR)%HSAT(IPHASE) + 
     +       VAR(N+IL)%EVAPR(IPHASE) * PRO(N+IL)%HSAT(IPHASE) +
     +       VAR(N-IL)%EVAPR(IPHASE) * PRO(N-IL)%HSAT(IPHASE))
         ELSE ! Two dimensional
         APU = VAR(N)%EVAPR(IPHASE) 
         VAR(N)%DX(IPHASE)  = VAR(N)%DX(IPHASE) -.5*VAR(N)%EVAPR(IPHASE) 
     +   +1./8.*(VAR(N+1)%EVAPR(IPHASE) + VAR(N-1)%EVAPR(IPHASE)
     +      +   VAR(N+JSTR)%EVAPR(IPHASE) + VAR(N-JSTR)%EVAPR(IPHASE))

          VAR(N)%DE(IPHASE)  = VAR(N)%DE(IPHASE) -
     +    .5*VAR(N)%EVAPR(IPHASE) * PRO(N)%HSAT(IPHASE)+ 1./8 *
     +      (VAR(N+1)%EVAPR(IPHASE) * PRO(N+1)%HSAT(IPHASE) + 
     +       VAR(N-1)%EVAPR(IPHASE) * PRO(N-1)%HSAT(IPHASE) +
     +       VAR(N+JSTR)%EVAPR(IPHASE) * PRO(N+JSTR)%HSAT(IPHASE) +
     +       VAR(N-JSTR)%EVAPR(IPHASE) * PRO(N-JSTR)%HSAT(IPHASE))

         ENDIF
         ENDDO

      ENDDO; ENDDO; ENDDO

      END SUBROUTINE CORR_EVAP
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE EVAP(PRO,VAR,BLKS,U,V,W,P,PDIFF,VIS,EPS2,
     + IMAX,JMAX,KMAX,IN,JN,KN,DT,DTL,NGL,M,PRT,VOL)

      USE TYPE_ARRAYS
      USE CONSTANTS, ONLY : PII,EPS6,EPS10,EPS12,EPS20
      USE NS3CO,     ONLY : TWO_FLUIDL

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,I,K,N,ISTRID,JSTRID,IL,IA,
     + IPHASE,NGL,II,JJ,J,ISTR,JSTR,KSTR,IJ,J1,IEVAP,mmm,nnn,lll,
     + M
      REAL :: U(*),V(*),W(*),P(*),DTL(*),PDIFF(*),VIS(*),EPS2(*),VOL(*)
      REAL :: FRSDEN,VEL2,DT,EVAPH,EVAPR,APU,TEMDIF,QILMIN,QIGMAX,
     + HFG,PPSAT,RKF,RKB,FRSVEL,CHLCAV,EVAPOLD,REFCAV,VELKIN,YPLS,
     + RLAM,B1E,ALMAX,ALMIN,PRT,EVAPMAX,QIFOLD(5),EVAPB,EVAPC,
     + BB(2),CC(2),DBUBBLE,HIK,RNBUBBLE,APU2,APU3,RLAMP,RMUT
      REAL :: DRIVET,DFRSTEM,TEMDIV
      TYPE(PROPERTIES) PRO(*)
      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(BLOCKS) BLKS(*)

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
        
      ISTR    = 1
      JSTR    = ISTRID
      KSTR    = IL

      IEVAP   = BLKS(NGL)%EVAP_TYPE
      REFCAV  = BLKS(NGL)%REFCAV
      CHLCAV  = BLKS(NGL)%CHLCAV
      FRSDEN  = BLKS(NGL)%FRSDEN
      FRSVEL  = BLKS(NGL)%FRSVEL
      DFRSTEM = BLKS(NGL)%DFRSTEM
      APU3    = 0.

      DO 1000 K = 1,KMAX
      IA = (K+KN-1)*KSTR + JN*JSTR + (IN-1)*ISTR + 1
      DO 1000 IJ = 1,IMAX*JMAX
            J1 = (IJ-1)/IMAX           ! J1 = J-1
            I  = IJ - J1*IMAX
            N  = IA + J1*JSTR + I*ISTR ! (I-1)*ISTR
            call ijkpai(n,imax,jmax,kmax,mmm,nnn,lll)
            IF(.NOT. TWO_FLUIDL) THEN
            VELKIN = .5*(U(N)**2+V(N)**2+W(N)**2)
            ELSEIF(TWO_FLUIDL) THEN
            VELKIN = .5*(VAR(N)%U(1)*VAR(N)%U(2) +
     +                   VAR(N)%V(1)*VAR(N)%V(2) +
     +                   VAR(N)%W(1)*VAR(N)%W(2))
            ENDIF

      SELECT CASE(IEVAP)

 
      CASE(0)  ! No phase change

      DO IPHASE = 1,BLKS(NGL)%NPHASE
      PRO(N)%QIF(IPHASE)   = 0.
      VAR(N)%EVAPR(IPHASE) = 0.
      ENDDO

C **********************************************************************
      CASE(1,6)  ! Cavitation model of Merkle
C **********************************************************************

      IF(M == 1) THEN ! First level evaluation, second level lumped

      EVAPOLD         = VAR(N)%EVAPR(1)! VAR(N)%EVAPR(1) !Mersu

      IF(BLKS(NGL)%TAUF(1) < EPS10) THEN  ! Liquid is phase 1
         PRO(N)%TAUF(1)  = .01                ! Default value
      ELSE
         PRO(N)%TAUF(1)  = BLKS(NGL)%TAUF(1)
      ENDIF
      IF(BLKS(NGL)%TAUF(2) < EPS10) THEN  ! Gas is phase 2
         PRO(N)%TAUF(2)  = .01                ! Default value
      ELSE
         PRO(N)%TAUF(2)  = BLKS(NGL)%TAUF(2)
      ENDIF

      PPSAT           = REFCAV/CHLCAV * (PDIFF(N)-PRO(N)%DPSAT) /
     +                 (.5*FRSDEN*FRSVEL**2)
      RKF             = MIN(0.,PPSAT/PRO(N)%TAUF(1))
      RKB             = MAX(0.,PPSAT/PRO(N)%TAUF(2))
      VAR(N)%EVAPH(1) = RKF*VAR(N)%ALFA(1)*PRO(N)%RO(1)
c      IF(ABS(EVAPOLD) > 1.E-1) VAR(N)%EVAPH(1)=.5*VAR(N)%EVAPH(1)+
c     +                  .5*EVAPOLD
      VAR(N)%EVAPH(2) = RKB*VAR(N)%ALFA(2)*PRO(N)%RO(2)
      VAR(N)%EVAPR(1) = VAR(N)%EVAPH(1) + VAR(N)%EVAPH(2)


      IF(ABS(EVAPOLD) > 1.E-1) VAR(N)%EVAPR(1)=.5*VAR(N)%EVAPR(1)+
     +                  .5*EVAPOLD
      IF(VAR(N)%ALFA(1) < EPS6) VAR(N)%EVAPR(1) = MAX(0.,
     + VAR(N)%EVAPR(1))
      VAR(N)%EVAPR(2) = -VAR(N)%EVAPR(1)
      VAR(N)%EVAPH(1) = VAR(N)%EVAPR(1) ! kokeilu.mersu
      ENDIF ! M == 1

      PRO(N)%QIF(2) = 1.E6*PRO(N)%CP(2)*(PRO(N)%TSAT-PRO(N)%DTEMP(2)) *
     +                     VAR(N)%ALFA(1)*VAR(N)%ALFA(2)

c      PRO(N)%QIF(2) = 1.E6*PRO(N)%CP(2)*(PRO(N)%TSAT-PRO(N)%TEMP(2)) *
c     +                      VAR(N)%ALFA(2)
c      PRO(N)%QIF(2) = 0.
      PRO(N)%QIF(1) =-(PRO(N)%HSAT(2)-PRO(N)%HSAT(1)) * VAR(N)%EVAPR(2)
     +               - PRO(N)%QIF(2) ! Obs sign for GAMMA_L elsewhere

      DO IPHASE = 1,BLKS(NGL)%NPHASE
      TEMDIV    = MAX(ABS(PRO(N)%DTEMP(IPHASE)-PRO(N)%TSAT),EPS10)
      VAR(N)%EQL(IPHASE) = ABS(PRO(N)%QIF(IPHASE)) / TEMDIV
c     +                     (PRO(N)%DTEMP(IPHASE)-PRO(N)%TSAT+EPS10)


      VAR(N)%DX(IPHASE)  = VAR(N)%DX(IPHASE) + VAR(N)%EVAPR(IPHASE) 

      VAR(N)%DE(IPHASE)  = VAR(N)%DE(IPHASE) + PRO(N)%QIF(IPHASE) +
     +             VAR(N)%EVAPR(IPHASE) * (PRO(N)%HSAT(IPHASE) + VELKIN)
      ENDDO

      IF(TWO_FLUIDL) THEN

c      VAR(N)%DM(1) = VAR(N)%DM(1) + MAX(VAR(N)%EVAPR(1),0.)*VAR(N)%U(2)
c     2                            + MIN(VAR(N)%EVAPR(1),0.)*VAR(N)%U(1)
c      VAR(N)%DN(1) = VAR(N)%DN(1) + MAX(VAR(N)%EVAPR(1),0.)*VAR(N)%V(2)
c     2                            + MIN(VAR(N)%EVAPR(1),0.)*VAR(N)%V(1)
c      VAR(N)%DW(1) = VAR(N)%DW(1) + MAX(VAR(N)%EVAPR(1),0.)*VAR(N)%W(2)
c     2                            + MIN(VAR(N)%EVAPR(1),0.)*VAR(N)%W(1)

c      VAR(N)%DM(2) = VAR(N)%DM(2) + MAX(VAR(N)%EVAPR(2),0.)*VAR(N)%U(1)
c     2                            + MIN(VAR(N)%EVAPR(2),0.)*VAR(N)%U(2)
c      VAR(N)%DN(2) = VAR(N)%DN(2) + MAX(VAR(N)%EVAPR(2),0.)*VAR(N)%V(1)
c     2                            + MIN(VAR(N)%EVAPR(2),0.)*VAR(N)%V(2)
c      VAR(N)%DW(2) = VAR(N)%DW(2) + MAX(VAR(N)%EVAPR(2),0.)*VAR(N)%W(1)
c     2                            + MIN(VAR(N)%EVAPR(2),0.)*VAR(N)%W(2)
      VAR(N)%DM(1) = VAR(N)%DM(1) + 
     2               VAR(N)%EVAPR(1)*.5*(VAR(N)%U(1)+VAR(N)%U(2))
      VAR(N)%DN(1) = VAR(N)%DN(1) + 
     2               VAR(N)%EVAPR(1)*.5*(VAR(N)%V(1)+VAR(N)%V(2))
      VAR(N)%DW(1) = VAR(N)%DW(1) + 
     2               VAR(N)%EVAPR(1)*.5*(VAR(N)%W(1)+VAR(N)%W(2))
      VAR(N)%DM(2) = VAR(N)%DM(2) + 
     2               VAR(N)%EVAPR(2)*.5*(VAR(N)%U(1)+VAR(N)%U(2))
      VAR(N)%DN(2) = VAR(N)%DN(2) + 
     2               VAR(N)%EVAPR(2)*.5*(VAR(N)%V(1)+VAR(N)%V(2))
      VAR(N)%DW(2) = VAR(N)%DW(2) + 
     2               VAR(N)%EVAPR(2)*.5*(VAR(N)%W(1)+VAR(N)%W(2))

c      VAR(N)%DM = VAR(N)%DM + VAR(N)%EVAPR*.5*(VAR(N)%U(1)+VAR(N)%U(2))
c      VAR(N)%DN = VAR(N)%DN + VAR(N)%EVAPR*.5*(VAR(N)%V(1)+VAR(N)%V(2))
c      VAR(N)%DW = VAR(N)%DW + VAR(N)%EVAPR*.5*(VAR(N)%W(1)+VAR(N)%W(2))

      ENDIF

C **********************************************************************
      CASE(2)  ! Cavitation model of Merkle with modified condensation
C **********************************************************************

      IF(M == 1) THEN ! First level evaluation, second level lumped

      EVAPOLD         = VAR(N)%EVAPH(1)

      IF(BLKS(NGL)%TAUF(1) < 1.E-10) THEN  ! Liquid is phase 1
         PRO(N)%TAUF(1)  = 1.                 ! Default value
      ELSE
         PRO(N)%TAUF(1)  = BLKS(NGL)%TAUF(1)
      ENDIF
      IF(BLKS(NGL)%TAUF(2) < 1.E-10) THEN  ! Gas is phase 2
         PRO(N)%TAUF(2)  = 5.                 ! Default value
      ELSE
         PRO(N)%TAUF(2)  = BLKS(NGL)%TAUF(2)
      ENDIF

      PPSAT           = REFCAV/CHLCAV * (PDIFF(N)-PRO(N)%DPSAT) /
     +                 (.5*FRSDEN*REFCAV**2)
      RKF             = MIN(0.,PPSAT/PRO(N)%TAUF(1))
      RKB             = REFCAV/CHLCAV*(VAR(N)%ALFA(1)*VAR(N)%ALFA(2))/
     +                  PRO(N)%TAUF(2)
      VAR(N)%EVAPH(1) = RKF*VAR(N)%ALFA(1)*PRO(N)%RO(1) ! ROG vai ROL?
      IF(ABS(EVAPOLD) > 1.E-1) VAR(N)%EVAPH(1)=.5*VAR(N)%EVAPH(1)+
     +                  .5*EVAPOLD
      VAR(N)%EVAPH(2) = RKB*VAR(N)%ALFA(1)*PRO(N)%RO(1)
      VAR(N)%EVAPR(1) = VAR(N)%EVAPH(1) + VAR(N)%EVAPH(2)
      VAR(N)%EVAPR(2) = -VAR(N)%EVAPR(1)
      ENDIF ! M == 1

      DO IPHASE = 1,BLKS(NGL)%NPHASE
      PRO(N)%QIF(IPHASE)   = 0.
      VAR(N)%DX(IPHASE)  = VAR(N)%DX(IPHASE) + VAR(N)%EVAPR(IPHASE) 
c      VAR(N)%DE(IPHASE)  = 0. ! Energy residual is put to zero
      ENDDO

C **********************************************************************
      CASE(3)  ! Houdayer for the liquid phase
C **********************************************************************

      VEL2    = U(N)**2 +V(N)**2 + W(N)**2
      EVAPH   = ABS((PRO(N)%HSAT(2) - PRO(N)%HSAT(1)))

      DO IPHASE = 1,BLKS(NGL)%NPHASE

      IF(BLKS(NGL)%MATERIAL(IPHASE) == 'WATER') THEN
      PRO(N)%TAUF(IPHASE) = 660./((1.-VAR(N)%ALFA(IPHASE) + 0.02)*
     +                      (VEL2 + 1.)*SQRT(P(N))) ! Houdayer
       
      ELSE IF(BLKS(NGL)%MATERIAL(IPHASE) == 'STEAM') THEN
      PRO(N)%TAUF(2) = .001/(VAR(N)%ALFA(IPHASE) + 0.02) ! Antakee mersu
      ELSE
      WRITE(*,*) 'No rules for phase ',BLKS(NGL)%MATERIAL(IPHASE),
     + 'Exiting in EVAP...'
      STOP
      ENDIF

C ... Increase with small voids

      IF(VAR(N)%ALFA(IPHASE) < 0.1) THEN
      PRO(N)%TAUF(IPHASE) = 1./PRO(N)%TAUF(IPHASE) + 0.01/
     + (VAR(N)%ALFA(IPHASE)+5.E-7)**2
      PRO(N)%TAUF(IPHASE) = 1./PRO(N)%TAUF(IPHASE)
      ENDIF

      APU = 0.
      IF((PRO(N)%TSAT-PRO(N)%DTEMP(IPHASE)) < 0.) APU = 1.E-2
      PRO(N)%QIF(IPHASE) = VAR(N)%ALFA(IPHASE)*PRO(N)%RO(IPHASE)*
     +  PRO(N)%CP(IPHASE)*(PRO(N)%TSAT - PRO(N)%DTEMP(IPHASE)) /
     +  PRO(N)%TAUF(IPHASE) *(1.- VAR(N)%ALFA(IPHASE) + APU)
      ENDDO

      EVAPR          = -(PRO(N)%QIF(1)  + PRO(N)%QIF(2))/
     +                  (PRO(N)%HSAT(1) - PRO(N)%HSAT(2))

C ... Trying to smooth out the evaporation rate history

      APU   = EVAPR*VAR(N)%EVAPR(1)

      IF(VAR(N)%EVAPR(1) /= 0. .AND. APU > 0.) THEN 
         VAR(N)%EVAPR(1)= 0.5*VAR(N)%EVAPR(1) + .5*EVAPR
      ELSE IF(VAR(N)%EVAPR(1) /= 0. .AND. APU < 0.) THEN
         VAR(N)%EVAPR(1)= 0.75*VAR(N)%EVAPR(1) + .25*EVAPR
      ELSE
         VAR(N)%EVAPR(1)= EVAPR
      ENDIF

      VAR(N)%EVAPR(1)= EVAPR  ! pis
      VAR(N)%EVAPR(2)= -VAR(N)%EVAPR(1)

      DO IPHASE = 1,BLKS(NGL)%NPHASE
      VAR(N)%DX(IPHASE)  = VAR(N)%DX(IPHASE) + VAR(N)%EVAPR(IPHASE) 
      VAR(N)%DE(IPHASE)  = VAR(N)%DE(IPHASE) + VAR(N)%EVAPR(IPHASE)*
     +       (VEL2/2. + PRO(N)%HSAT(IPHASE)) + PRO(N)%QIF(IPHASE)
      ENDDO


C **********************************************************************
      CASE(4)  ! Cavitation model for a New Year 2012
C **********************************************************************
          
      IF(M == 1) THEN ! First level evaluation, second level lumped

      EVAPOLD         = VAR(N)%EVAPR(1)! VAR(N)%EVAPR(1) !Mersu

      IF(BLKS(NGL)%TAUF(1) < 1.E-10) THEN  ! Liquid is phase 1
         PRO(N)%TAUF(1)  = .01                ! Default value
      ELSE
         PRO(N)%TAUF(1)  = BLKS(NGL)%TAUF(1)
      ENDIF
      IF(BLKS(NGL)%TAUF(2) < 1.E-10) THEN  ! Gas is phase 2
         PRO(N)%TAUF(2)  = .01                ! Default value
      ELSE
         PRO(N)%TAUF(2)  = BLKS(NGL)%TAUF(2)
      ENDIF

      HFG    = PRO(N)%HSAT(2)-PRO(N)%HSAT(1)

C ... Liquid side

      ALMIN  = 1.E-3
      ALMAX  = .999
      ALMIN  = MAX(VAR(N)%ALFA(2),ALMIN)
      ALMAX  = 1. - ALMIN !MIN(VAR(N)%ALFA(IPH),ALMAX)

      TEMDIF = PRO(N)%TSAT - PRO(N)%TEMP(1)
      IF(VAR(N)%ALFA(1) <= 0.) TEMDIF = 0.
      IF(VAR(N)%ALFA(2) <= 0.) TEMDIF = MIN(0.,TEMDIF)
      RLAM   = (PRO(N)%CH(1) + 
     +         (EPS2(N)-1.)*VIS(N)*PRO(N)%CP(1)/PRT) 

      YPLS   = (36.*PII*(1.E-3+VAR(N)%ALFA(2))**2*BLKS(NGL)%N(2))**.333
      B1E    = 1.E4 ! Heh heh
      PRO(N)%QIF(1) = RLAM*YPLS**2*B1E*ALMIN*ALMAX * TEMDIF
     +   + 100.*RLAM*YPLS**2*TEMDIF
      VAR(N)%EQL(1) = RLAM*YPLS**2*B1E*ALMIN*ALMAX
     +     + 100.*RLAM*YPLS**2

C ... Gas side

      TEMDIF = PRO(N)%TSAT - PRO(N)%TEMP(2)
      IF(VAR(N)%ALFA(1) <= 0.) TEMDIF = MAX(0.,TEMDIF)
      IF(VAR(N)%ALFA(2) <= 0.) TEMDIF = 0.
      RLAM   = (PRO(N)%CH(2) + 
     +         (EPS2(N)-1.)*VIS(N)*PRO(N)%CP(2)/PRT) 
      YPLS   = (36.*PII*(1.E-3+VAR(N)%ALFA(2))**2*BLKS(NGL)%N(1))**.333
      B1E    = 1.E3
      PRO(N)%QIF(2) = RLAM*YPLS**2*B1E*ALMIN*ALMAX * TEMDIF
      IF(VAR(N)%ALFA(2) <= 1.E-5) PRO(N)%QIF(2) = PRO(N)%QIF(2) 
     +   + 1000.*TEMDIF

      VAR(N)%EQL(2) = RLAM*YPLS**2*B1E*ALMIN*ALMAX
      IF(VAR(N)%ALFA(2) <= 1.E-5) VAR(N)%EQL(2) = VAR(N)%EQL(2) 
     +   + 1000.*TEMDIF

      PRO(N)%QIF(2) = 0.
c     + REFCAV/CHLCAV*(VAR(N)%ALFA(1)*VAR(N)%ALFA(2)**2)/
c     +                  PRO(N)%TAUF(2)*PRO(N)%RO(2)*HFG
 
c     +     + 100.*RLAM*YPLS**2/PRO(N)%CP(2)

C ... Evaporation rate

      VAR(N)%EVAPR(1) = (PRO(N)%QIF(1)+PRO(N)%QIF(2)) / HFG
c      VAR(N)%EVAPR(1) = (PRO(N)%QIF(1)) / HFG

c      IF(ABS(EVAPOLD) > 1.E-1) VAR(N)%EVAPH(1)=.5*VAR(N)%EVAPH(1)+
c     +                  .5*EVAPOLD
      IF(ABS(EVAPOLD) > 1.E-1) VAR(N)%EVAPR(1)=.5*VAR(N)%EVAPR(1)+
     +                  .5*EVAPOLD
      IF(EVAPOLD*VAR(N)%EVAPR(1) < 0.) THEN ! On another side
         EVAPMAX = MIN(.5*ABS(EVAPOLD),ABS(VAR(N)%EVAPR(1)))
         VAR(N)%EVAPR(1) = SIGN(EVAPMAX,VAR(N)%EVAPR(1))
      ENDIF

      IF(VAR(N)%ALFA(1) < 1.E-6) VAR(N)%EVAPR(1) = MAX(0.,
     + VAR(N)%EVAPR(1))

      VAR(N)%EVAPR(2) = -VAR(N)%EVAPR(1)
      ENDIF ! M == 1

      DO IPHASE = 1,BLKS(NGL)%NPHASE
      VAR(N)%DX(IPHASE)  = VAR(N)%DX(IPHASE) + VAR(N)%EVAPR(IPHASE) 
      VAR(N)%DE(IPHASE)  = VAR(N)%DE(IPHASE) + PRO(N)%QIF(IPHASE) +
     +             VAR(N)%EVAPR(IPHASE) * (PRO(N)%HSAT(IPHASE) + VELKIN)
      ENDDO


C **********************************************************************
      CASE(5,7)  ! Cavitation model of Merkle using temperatures
C **********************************************************************

      IF(M == 1) THEN ! First level evaluation, second level lumped

      EVAPOLD         = VAR(N)%EVAPR(1)! VAR(N)%EVAPR(1) !Mersu

      IF(BLKS(NGL)%TAUF(1) < EPS10) THEN  ! Liquid is phase 1
         PRO(N)%TAUF(1)  = .01                ! Default value
      ELSE
         PRO(N)%TAUF(1)  = BLKS(NGL)%TAUF(1)
      ENDIF
      IF(BLKS(NGL)%TAUF(2) < EPS10) THEN  ! Gas is phase 2
         PRO(N)%TAUF(2)  = .01                ! Default value
      ELSE
         PRO(N)%TAUF(2)  = BLKS(NGL)%TAUF(2)
      ENDIF

      HFG    = PRO(N)%HSAT(2)-PRO(N)%HSAT(1)

      DO IPHASE = 1,BLKS(NGL)%NPHASE
         QIFOLD(IPHASE)  = PRO(N)%QIF(IPHASE)
      ENDDO

      BB(1) = 1.E-2 ; BB(2) = 0. ; CC(1) = 0. ; CC(2) = 1.E-4 ! Voi mersu

      DO IPHASE = 1,BLKS(NGL)%NPHASE

      IF(IEVAP == 5) THEN
         DRIVET = PRO(N)%DTEMP(IPHASE)
      ELSE IF(IEVAP == 7) THEN
         DRIVET = DFRSTEM
      ENDIF

      PPSAT          = REFCAV/CHLCAV*(DRIVET - PRO(N)%TSAT)/
     +                 (.5*FRSDEN*REFCAV**2)*PRO(N)%DPSDT
      RKF            =-MAX(0.,PPSAT/PRO(N)%TAUF(iphase)) ! il (SIGN) 1
      PPSAT          = REFCAV/CHLCAV*(DRIVET - PRO(N)%TSAT)/
     +                 (.5*FRSDEN*REFCAV**2)*PRO(N)%DPSDT
      RKB            =-MIN(0.,PPSAT/PRO(N)%TAUF(IPHASE)) ! ig (SIGN) 2

c      ALMIN = MIN(1.,VAR(N)%ALFA(2) + BB(IPHASE))

      ALMIN = MAX(VAR(N)%ALFA(2),BB(IPHASE))
      EVAPB =RKF*VAR(N)%ALFA(1)*PRO(N)%RO(IPHASE)*ALMIN! 1 ! viimeksi 1

      ALMAX = MIN(1.,VAR(N)%ALFA(1) + CC(IPHASE))
      EVAPC=RKB*ALMAX*PRO(N)%RO(IPHASE)*VAR(N)%ALFA(2)!2 ! viimeksi 1

      PRO(N)%QIF(IPHASE) = (EVAPB + EVAPC)*HFG

      IF(ABS(DRIVET - PRO(N)%TSAT) <= EPS20) THEN
         TEMDIV = 100. !  1.
      ELSEIF(ABS(DRIVET - PRO(N)%TSAT) > EPS20 .AND.
     +   ABS(DRIVET - PRO(N)%TSAT) < EPS10) THEN
         TEMDIV = SIGN(DRIVET - PRO(N)%TSAT,EPS10)
      ELSE
         TEMDIV = DRIVET - PRO(N)%TSAT
      ENDIF

      VAR(N)%EQL(IPHASE) = MAX(0.,-PRO(N)%QIF(IPHASE)/TEMDIV)

      IF(IEVAP == 7) VAR(N)%EQL(IPHASE) = 0.

      VAR(N)%EVAPH(IPHASE) = PRO(N)%QIF(IPHASE)/HFG

      ENDDO

      VAR(N)%EVAPR(1) = VAR(N)%EVAPH(1)+VAR(N)%EVAPH(2) +
     + VAR(N)%EVAPR(1) ! muista testi !!
      IF(VAR(N)%ALFA(1) <= EPS6) VAR(N)%EVAPR(1) = MAX(0.,  
     + VAR(N)%EVAPR(1))
      VAR(N)%EVAPR(2) = -VAR(N)%EVAPR(1)

      ENDIF ! M == 1


      DO IPHASE = 1,BLKS(NGL)%NPHASE
      VAR(N)%DX(IPHASE)  = VAR(N)%DX(IPHASE) + VAR(N)%EVAPR(IPHASE) 
      VAR(N)%DE(IPHASE)  = VAR(N)%DE(IPHASE) + PRO(N)%QIF(IPHASE) +
     +             VAR(N)%EVAPR(IPHASE) * (PRO(N)%HSAT(IPHASE) + VELKIN)

      ENDDO

C **********************************************************************
      CASE(8)  ! Nusselt-number based bubble model
C **********************************************************************

      IF(M == 1) THEN ! First level evaluation, second level lumped

      EVAPOLD         = VAR(N)%EVAPR(1)! VAR(N)%EVAPR(1) !Mersu

      IF(BLKS(NGL)%TAUF(1) < EPS10) THEN  ! Liquid is phase 1
         PRO(N)%TAUF(1)  = 6.  !6.                ! Default Nu value
      ELSE
         PRO(N)%TAUF(1)  = BLKS(NGL)%TAUF(1)
      ENDIF
      IF(BLKS(NGL)%TAUF(2) < EPS10) THEN  ! Gas is phase 2
         PRO(N)%TAUF(2)  = 6.                ! Default Nu value
      ELSE
         PRO(N)%TAUF(2)  = BLKS(NGL)%TAUF(2)
      ENDIF

      HFG    = PRO(N)%HSAT(2)-PRO(N)%HSAT(1)

      DO IPHASE = 1,BLKS(NGL)%NPHASE
         QIFOLD(IPHASE)  = PRO(N)%QIF(IPHASE)
      ENDDO

      BB(1) = 1.E-2 ; BB(2) = 0. ; CC(1) = 0. ; CC(2) = 1.E-4 ! Voi mersu

      DO IPHASE = 1,BLKS(NGL)%NPHASE

      DRIVET    = PRO(N)%DTEMP(IPHASE)
      DBUBBLE   = 1.E-3 ! Given bubble diameter
      RNBUBBLE  = 1.E 9 ! Given bubble density

      ALMIN = MAX(VAR(N)%ALFA(2),BB(IPHASE))

      ALMAX = MIN(1.,VAR(N)%ALFA(1) + CC(IPHASE))

      IF(IPHASE == 1) THEN
      DBUBBLE = ((ALMAX+EPS10)*6./(3.14159*RNBUBBLE))**.333
      ELSEIF(IPHASE  == 2) THEN
      DBUBBLE = ((ALMIN+EPS10)*6./(3.14159*RNBUBBLE))**.333
      ENDIF

c      RMUT  = (EPS2(I)-1.)*VIS(I) ! Oscillating solution
      RMUT  = 0.
      RLAMP = PRO(I)%CH(IPHASE) + PRO(I)%CP(IPHASE)*RMUT/PRT
      HIK   = PRO(N)%TAUF(IPHASE)/DBUBBLE*RLAMP
      PPSAT          = HIK*(DRIVET - PRO(N)%TSAT)
      RKF            =-MAX(0.,PPSAT) ! 
      RKB            =-MIN(0.,PPSAT) ! 

      EVAPB = 6.*RKF*VAR(N)%ALFA(1)*ALMIN/DBUBBLE
      EVAPC = 6.*RKB*ALMAX*VAR(N)%ALFA(2)/DBUBBLE

      PRO(N)%QIF(IPHASE) = EVAPB + EVAPC

      IF(J == 1) PRO(N)%QIF(IPHASE) = -VAR(N)%EVAPR(IPHASE)*HFG*
     + VAR(N)%X(IPHASE)

      VAR(N)%EVAPH(IPHASE) = PRO(N)%QIF(IPHASE)/HFG

      IF(ABS(DRIVET - PRO(N)%TSAT) <= EPS20) THEN
         TEMDIV = 100. !  1.
      ELSEIF(ABS(DRIVET - PRO(N)%TSAT) > EPS20 .AND.
     +   ABS(DRIVET - PRO(N)%TSAT) < EPS10) THEN
         TEMDIV = SIGN(DRIVET - PRO(N)%TSAT,EPS10)
      ELSE
         TEMDIV = DRIVET - PRO(N)%TSAT
      ENDIF

      VAR(N)%EQL(IPHASE) = MAX(0.,-PRO(N)%QIF(IPHASE)/TEMDIV)

      ENDDO

      IF(J /=  1) THEN
      VAR(N)%EVAPR(1) = VAR(N)%EVAPH(1)+VAR(N)%EVAPH(2) +
     2 VAR(N)%EVAPR(1) ! muista testi !!
      ENDIF
      IF(VAR(N)%ALFA(1) <= EPS6) VAR(N)%EVAPR(1) = MAX(0.,  
     + VAR(N)%EVAPR(1))
      VAR(N)%EVAPR(2) = -VAR(N)%EVAPR(1)

      ENDIF ! M == 1

      DO IPHASE = 1,BLKS(NGL)%NPHASE
      VAR(N)%DX(IPHASE)  = VAR(N)%DX(IPHASE) + VAR(N)%EVAPR(IPHASE) 
      VAR(N)%DE(IPHASE)  = VAR(N)%DE(IPHASE) + PRO(N)%QIF(IPHASE) +
     +             VAR(N)%EVAPR(IPHASE) * (PRO(N)%HSAT(IPHASE) + VELKIN)

      ENDDO
 
C **********************************************************************

      END SELECT

1000  CONTINUE
        
      RETURN
      END SUBROUTINE EVAP
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE INTF(PRO,VAR,BLKS,U,V,W,P,PDIFF,VIS,EPS2,DALFAX,
     + DALFAY,DALFAZ,IMAX,JMAX,KMAX,IN,JN,KN,DT,DTL,NGL,M,PRT,VOL,RO)

      USE TYPE_ARRAYS
      USE CONSTANTS, ONLY : PII,EPS6,EPS10,EPS12,EPS20

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,I,K,N,ISTRID,JSTRID,IL,
     +           NGL,II,JJ,J,ISTR,JSTR,KSTR,IDRAG,M,ITURD

      REAL :: U(*),V(*),W(*),P(*),DTL(*),PDIFF(*),VIS(*),EPS2(*),VOL(*),
     +     RO(*),DALFAX(*),DALFAY(*),DALFAZ(*)

      REAL :: FRSDEN,DFRSTEM,DT,FRSVEL,CHLCAV,REFCAV,PRT,
     +        DBUBBLE,AAA,RK,ABSVEL,CD,RED,RKMAX,
     +        DBMAX,ALFA1,ALFA2,BBB,RINTF,RKIFLG,VELXI,VELYI,VELZI,
     +        EKIFLG,CDELLIPSE,CDCAP,CCC,TURVIS,DDD

      TYPE(PROPERTIES) PRO(*)
      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(BLOCKS) BLKS(*)

C ... Interfacial drag. Positive sign for the gas phase
C ... Wal force is added to the residuals here

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
        
      ISTR    = 1
      JSTR    = ISTRID
      KSTR    = IL

      IDRAG   = BLKS(NGL)%DRAGMUL
      ITURD   = BLKS(NGL)%DISPERMUL
      REFCAV  = BLKS(NGL)%REFCAV
      CHLCAV  = BLKS(NGL)%CHLCAV
      FRSDEN  = BLKS(NGL)%FRSDEN
      FRSVEL  = BLKS(NGL)%FRSVEL
      DFRSTEM = BLKS(NGL)%DFRSTEM
      RINTF   = BLKS(NGL)%RINTF
      DBMAX   = (3./(PII*BLKS(NGL)%N(1)))**.333 ! Max bubble diameter


      DO K = 0,KMAX+1
      JJ      = (KN+K-1)*IL
      DO J = 0,JMAX+1
      II      = (JN+J-1)*ISTRID + JJ + IN
      DO I = 0,IMAX+1
            N = I + II

c      if(k == 1) then
c       write(7100+ngl,*) i,j,VAR(N)%U(1),VAR(N)%U(2),VAR(N)%V(1),
c     + VAR(N)%V(2)
c       endif

      ABSVEL  = (VAR(N)%U(1) - VAR(N)%U(2))**2 +
     +          (VAR(N)%V(1) - VAR(N)%V(2))**2 +
     +          (VAR(N)%W(1) - VAR(N)%W(2))**2
      ABSVEL  = SQRT(ABSVEL) + 1.E-6 ! Oli E-3

      DBUBBLE = MIN(VAR(N)%BUBDIA(1),VAR(N)%BUBDIA(2)) ! Currently
      DBUBBLE = MAX(DBUBBLE,EPS10) ! 


      SELECT CASE(IDRAG)

      CASE(0)  ! Constant value via input

         RK = BLKS(NGL)%RK(2) ! From input
c        RK = BLKS(NGL)%N(2) ! From a given bubble density (mersu)

      CASE(1)  ! Modified Ishii and Zuber (1979)

      RED = RO(N)*ABSVEL*DBUBBLE/VIS(N)

      IF(RED < 1000.) THEN
        CD  = 24./RED*(1 + 0.1*RED**.75)
      ELSE
        CD  = 0.45
      ENDIF

      RK    = 0.75*CD/DBUBBLE
      RKMAX = 0.3375/DBMAX ! 0.75*0.45
      RK    = MAX(RK,RKMAX)

      RK    = MIN(RK,1.E8)  ! Stability limits between 10. 
      RK    = MAX(RK,10.)    ! and 1.E14 in Ogival cylinder case
c      RK = 1.E3  ! Oli maksimissaan 14 tetsissa, min 1.E4

      CASE(2)  ! Modified Ishii and Zuber (1979) and Liao et al. (2019)

      RED   = RO(N)*ABSVEL*DBUBBLE/VIS(N)
      CD    = 24./RED*(1 + 0.1*RED**.75)
      CDELLIPSE = 0.667*SQRT(PRO(N)%EO)
      CDCAP     = 8./3.
      CD    = MAX(CD,MIN(CDELLIPSE,CDCAP))

      RK    = 0.75*CD/DBUBBLE ! Multiplier 3/4 is here
      RKMAX = 0.3375/DBMAX ! 0.75*0.45
      RK    = MAX(RK,RKMAX)

      RK    = MIN(RK,1.E8)   ! Stability limits between 10. 
      RK    = MAX(RK,10.)    ! and 1.E14 in Ogival cylinder case

      CASE(3)

         WRITE(*,*) IDRAG,'No such drag type yet. Exiting from INTF...'
         WRITE(13,*) ' No such drag type yet.'
         WRITE(13,*) ' BLOCK=',NGL,' DRAGMUL=',IDRAG,'Exiting...'
         STOP 
         
       END SELECT

       ALFA1 = MAX(VAR(N)%ALFA(1),EPS6)
       ALFA2 = MAX(VAR(N)%ALFA(2),EPS6)

       AAA   = RK*(PRO(N)%RO(1)+PRO(N)%RO(2))*ABSVEL*ALFA1*ALFA2

       VAR(N)%RKIF(1) = AAA !+ .5*VAR(N)%RKIF(1)! +.1
       VAR(N)%RKIF(2) = AAA
       VAR(N)%RKIF(3) = AAA

c       DDD = RK*(PRO(N)%RO(1)+PRO(N)%RO(2))*ABSVEL*ALFA1*ALFA2
       DDD = BLKS(NGL)%N(2)*(PRO(N)%RO(1)+PRO(N)%RO(2))*ABSVEL
     2       *ALFA1*ALFA2
c      if(var(n)%alfa(2) < 1.E-6) VAR(N)%RKIF(1) = 0.

      SELECT CASE(ITURD)

      CASE(0) ! No turbulent diffusion

      CASE(1)  ! Modified Burns et al. (2004)

         TURVIS= EPS2(N)*VIS(N)/PRT
c         CCC   = RK*ABSVEL*TURVIS*(1.+ MIN(ALFA1/ALFA2,ALFA2/ALFA1))
         CCC   = RK*ABSVEL*TURVIS/MAX(VAR(N)%ALFA(1),VAR(N)%ALFA(2))

         IF(VAR(N)%ALFA(2) <= 0.5) THEN
           PRO(N)%FTD(1) =-CCC*DALFAX(N)
           PRO(N)%FTD(2) =-CCC*DALFAY(N)
           PRO(N)%FTD(3) =-CCC*DALFAZ(N)
         ELSE ! Use the liquid phase gradient
           PRO(N)%FTD(1) =-CCC*DALFAX(N)
           PRO(N)%FTD(2) =-CCC*DALFAY(N)
           PRO(N)%FTD(3) =-CCC*DALFAZ(N)
         ENDIF

      CASE(2:10)

         WRITE(*,*) ITURD,'No such turbulent dispersion. Exiting INTF..'
         WRITE(13,*) ' No such turbulent dispersion type yet.'
         WRITE(13,*) ' BLOCK=',NGL,' DISPERMUL=',ITURD,'Exiting...'
         STOP
         
      END SELECT


C ... Add forces to the residuals

            RKIFLG        =-VAR(N)%RKIF(1)*(VAR(N)%U(2) - VAR(N)%U(1))
            VAR(N)%DM(1)  = VAR(N)%DM(1) - RKIFLG - PRO(N)%FW(1)
     +                    - PRO(N)%FTD(1)- PRO(N)%FL(1)- PRO(N)%FVM(1)
            VAR(N)%DM(2)  = VAR(N)%DM(2) + RKIFLG + PRO(N)%FW(1)
     +                    + PRO(N)%FTD(1)+ PRO(N)%FL(1)+ PRO(N)%FVM(1)
            PRO(N)%FD(1)  = RKIFLG
            RKIFLG        = RKIFLG + PRO(N)%FW(1) + PRO(N)%FTD(1)
     +                    + PRO(N)%FL(1) + PRO(N)%FVM(1)
            VELXI         = RKIFLG*(VAR(N)%U(1) + VAR(N)%U(2))

c            VAR(N)%RKIF(2) = ABSVEL*AAA !+ .5*VAR(N)%RKIF(2)! +.1
c            if(var(n)%alfa(2) < 1.E-6) VAR(N)%RKIF(2) = 0.
            RKIFLG        =-VAR(N)%RKIF(2)*(VAR(N)%V(2) - VAR(N)%V(1))
c            write(666,*) i,j,var(n)%dn(2), rkiflg,PRO(N)%FW(2)
            VAR(N)%DN(1)  = VAR(N)%DN(1) - RKIFLG - PRO(N)%FW(2)
     +                    - PRO(N)%FTD(2)- PRO(N)%FL(2)- PRO(N)%FVM(2)
            VAR(N)%DN(2)  = VAR(N)%DN(2) + RKIFLG + PRO(N)%FW(2)
     +                    + PRO(N)%FTD(2)+ PRO(N)%FL(2)+ PRO(N)%FVM(2)
            PRO(N)%FD(2)  = RKIFLG
            RKIFLG        = RKIFLG + PRO(N)%FW(2) + PRO(N)%FTD(2)
     +                    + PRO(N)%FL(2) + PRO(N)%FVM(2)
            VELYI         = RKIFLG*(VAR(N)%V(1) + VAR(N)%V(2))

c            VAR(N)%RKIF(3) = ABSVEL*AAA !+ .5*VAR(N)%RKIF(3)! +.1
c            if(var(n)%alfa(2) < 1.E-6) VAR(N)%RKIF(3) = 0
            RKIFLG        =-VAR(N)%RKIF(3)*(VAR(N)%W(2) - VAR(N)%W(1))
            VAR(N)%DW(1)  = VAR(N)%DW(1) - RKIFLG - PRO(N)%FW(3)
     +                    - PRO(N)%FTD(3)- PRO(N)%FL(3)- PRO(N)%FVM(3)
            VAR(N)%DW(2)  = VAR(N)%DW(2) + RKIFLG + PRO(N)%FW(3)
     +                    + PRO(N)%FTD(3)+ PRO(N)%FL(3)+ PRO(N)%FVM(3)
            PRO(N)%FD(3)  = RKIFLG
            RKIFLG        = RKIFLG + PRO(N)%FW(3) + PRO(N)%FTD(3)
     +                    + PRO(N)%FL(3) + PRO(N)%FVM(3)
            VELZI         = RKIFLG*(VAR(N)%W(1) + VAR(N)%W(2))

            EKIFLG        = .5*(VELXI + VELYI + VELZI)
            VAR(N)%DE(1)  = VAR(N)%DE(1) - EKIFLG
            VAR(N)%DE(2)  = VAR(N)%DE(2) + EKIFLG


c       BBB   = (PRO(N)%RO(1)+PRO(N)%RO(2))*ALFA1*ALFA2
c       RINTF = 1.5 ! Joo, Inputiin? koe1
c       BBB   = RINTF*VAR(N)%ALFA(1)*PRO(N)%RO(1) ! RINTF*RO(N)
       BBB   = RINTF*RO(N)
       VAR(N)%RKIF(1) = VAR(N)%RKIF(1) + BBB/(DTL(N)+EPS12) ! Koe1 10 ja koe2 ro-inertia
       VAR(N)%RKIF(2) = VAR(N)%RKIF(2) + BBB/(DTL(N)+EPS12)
       VAR(N)%RKIF(3) = VAR(N)%RKIF(3) + BBB/(DTL(N)+EPS12)

c      if(k == 1 .and. i == 19.and. j >= 33 .and.j <= 37) then
c      write(7100+ngl*100+j,*)j,VAR(N)%RKIF(1)*(VAR(N)%V(1)-VAR(N)%V(2)),
c     + VAR(N)%RKIF(2),VAR(N)%V(1),VAR(N)%V(2)
c       write(7200+ngl,*) i,j,AAA,RK,DBUBBLE,ABSVEL
c       endif
      ENDDO; ENDDO; ENDDO

      RETURN
      END SUBROUTINE INTF
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE LIFTF(PRO,VAR,BLKS,U,V,W,P,PDIFF,VIS,EPS2,OMX,
     +   OMY,OMZ,IMAX,JMAX,KMAX,DT,DTL,NGL,M,PRT,VOL,RO)

      USE TYPE_ARRAYS
      USE CONSTANTS, ONLY : PII,EPS6,EPS10,EPS12,EPS20
      USE NS3CO, ONLY : G0,IN,JN,KN


      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,I,K,N,ISTRID,JSTRID,IL,
     +           NGL,II,JJ,J,ILIFT,M
      
      REAL :: U(*),V(*),W(*),P(*),DTL(*),PDIFF(*),VIS(*),EPS2(*),VOL(*),
     +     RO(*),OMX(*),OMY(*),OMZ(*)

      REAL :: FRSDEN,DT,FRSVEL,CHLCAV,REFCAV,PRT,DBHAT,EOHAT,DBUBBLE,
     +        FEO,AAA,ABSVEL,CL,RED,DBMAX,ALFA1,ALFA2,OMXN,OMYN,OMZN

      REAL :: DFRSTEM

      TYPE(PROPERTIES) PRO(*)
      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(BLOCKS) BLKS(*)

C ... Lift force. Positive sign is for gas

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
        
      ILIFT   = BLKS(NGL)%LIFTMUL
      REFCAV  = BLKS(NGL)%REFCAV
      CHLCAV  = BLKS(NGL)%CHLCAV
      FRSDEN  = BLKS(NGL)%FRSDEN
      FRSVEL  = BLKS(NGL)%FRSVEL
      DFRSTEM = BLKS(NGL)%DFRSTEM
      DBMAX   = (3./(PII*BLKS(NGL)%N(1)))**.333 ! Max bubble diameter


      DO K = 0,KMAX+1
      JJ      = (KN+K-1)*IL
      DO J = 0,JMAX+1
      II      = (JN+J-1)*ISTRID + JJ + IN
      DO I = 0,IMAX+1
         N =  I + II

c      if(k == 1) then
c       write(7100+ngl,*) i,j,VAR(N)%U(1),VAR(N)%U(2),VAR(N)%V(1),
c     + VAR(N)%V(2)
c       endif
      ABSVEL  = (VAR(N)%U(1) - VAR(N)%U(2))**2 +
     +          (VAR(N)%V(1) - VAR(N)%V(2))**2 +
     +          (VAR(N)%W(1) - VAR(N)%W(2))**2
      ABSVEL  = SQRT(ABSVEL) + 1.E-3

      SELECT CASE(ILIFT)

      CASE(0)  ! No lift force on bubbles

         CL = 0.
         RETURN

      CASE(1)  ! Tomiyama et al. (2002)

      DBUBBLE = MIN(VAR(N)%BUBDIA(1),VAR(N)%BUBDIA(2)) ! Currently
      DBUBBLE = MAX(DBUBBLE,EPS10) !
      DBHAT   = DBUBBLE*(1.+ 0.163*PRO(N)%EO**0.757)**.333
      EOHAT   = G0*(PRO(N)%RO(1)-PRO(N)%RO(2))*DBHAT**2/PRO(N)%SIGMA
      FEO     = .00105*EOHAT**3 - .0159*EOHAT**2 - .0204*EOHAT + 0.474

      RED   = RO(N)*ABSVEL*DBUBBLE/VIS(N)

      IF(EOHAT < 4.) THEN
        CL = MIN(0.288*TANH(0.121*RED),FEO)
      ELSE IF(EOHAT <= 10.) THEN
        CL = FEO
      ELSE
        CL = -0.27
      ENDIF

      CASE(2)

         WRITE(*,*) ILIFT,'No such lift type yet. Exiting from INTL...'
         WRITE(13,*) ' No such lift type yet.'
         WRITE(13,*) ' BLOCK=',NGL,' LIFTMUL=',ILIFT,'Exiting...'
         STOP
         
      END SELECT

       ALFA1 = MAX(VAR(N)%ALFA(1),EPS6)
       ALFA2 = MAX(VAR(N)%ALFA(2),EPS6)
c      if(ngl == 2) write(666+k,*)i,j,ilift,dbubble,dbhat,eohat,feo,red
c      if(ngl == 2) write(666+k,*)i,j,cl,omx(n),omy(n),omz(n)
C ... 2. is needed because of the definition of the vorticity vector
       AAA   = 2.*CL*(PRO(N)%RO(1)+PRO(N)%RO(2))*ALFA1*ALFA2
       OMXN  = -OMZ(N); OMYN = OMY(N); OMZN = -OMX(N) ! Voi mersu

            PRO(N)%FL(1) = -AAA*(OMZN*(VAR(N)%V(2) - VAR(N)%V(1))
     +                   -       OMYN*(VAR(N)%w(2) - VAR(N)%w(1)))

            PRO(N)%FL(2) = -AAA*(OMXN*(VAR(N)%W(2) - VAR(N)%W(1))
     +                   -       OMZN*(VAR(N)%U(2) - VAR(N)%U(1)))
c      if(ngl == 2)write(666+k,*)i,j,aaa,VAR(N)%U(2)-VAR(N)%U(1)

            PRO(N)%FL(3) = -AAA*(OMYN*(VAR(N)%U(2) - VAR(N)%U(1))
     +                   -       OMXN*(VAR(N)%V(2) - VAR(N)%V(1)))
c      if(ngl == 2)write(666+k,*)i,j,pro(N)%FL(1),pro(N)%FL(2)

c      if(k == 1 .and. i == 19.and. j >= 33 .and.j <= 37) then
c      write(7100+ngl*100+j,*)j,VAR(N)%RKIF(1)*(VAR(N)%V(1)-VAR(N)%V(2)),
c     + VAR(N)%RKIF(2),VAR(N)%V(1),VAR(N)%V(2)
c       write(7200+ngl,*) i,j,AAA,RK,DBUBBLE,ABSVEL
c       endif
      ENDDO; ENDDO; ENDDO

      RETURN
      END SUBROUTINE LIFTF
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE VMASSF(PRO,VAR,BLKS,U,V,W,DUDX,DUDY,DUDZ,IMAX,JMAX,
     +   KMAX,IN,JN,KN,DT,DTL,NGL,M,VOL,IDIR,IPHASE)

      USE TYPE_ARRAYS
      USE CONSTANTS, ONLY : PII,EPS6,EPS10,EPS12,EPS20
      USE NS3CO, ONLY : TIMEL

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,I,K,L,ISTRID,JSTRID,IL,IA,IDIR,
     + IPHASE,NGL,II,JJ,J,ISTR,JSTR,KSTR,IJ,J1,IVMASS,mmm,nnn,lll,M

      REAL :: DT,CVM,TIMDER
      REAL :: U(*),V(*),W(*),VOL(*),DTL(*),DUDX(*),DUDY(*),DUDZ(*)

      TYPE(PROPERTIES) PRO(*)
      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(BLOCKS) BLKS(*)

C ... Calculate the convective part of the virtual mass force

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      IVMASS  = BLKS(NGL)%VMASS

      DO K = 1,KMAX
      JJ      = (KN+K-1)*IL
      DO J = 1,JMAX
      II      = (JN+J-1)*ISTRID + JJ + IN
      DO I = 1,IMAX
         L =  I + II

      SELECT CASE(IVMASS)

      CASE(0)  ! No virtual mass

         PRO(L)%FVM(IDIR) = 0.
         RETURN

      CASE(1)  ! Crowe et al. (2011)
         CVM     = 0.5
         IF(IPHASE == 2) CVM = -.5
         TIMDER  = 0.
         IF(TIMEL) THEN
         SELECT CASE(IDIR)
            CASE(1)
            TIMDER = VAR(L)%U(IPHASE)/DT
            CASE(2)
            TIMDER = VAR(L)%V(IPHASE)/DT
            CASE(3)
            TIMDER = VAR(L)%W(IPHASE)/DT
         END SELECT
         ENDIF ! TIMEL
         PRO(L)%FVM(IDIR) = PRO(L)%FVM(IDIR) +
     +   CVM*VAR(L)%ALFA(2)*PRO(L)%RO(1) * (VAR(L)%U(IPHASE)*DUDX(L) +
     +   VAR(L)%V(IPHASE)*DUDY(L) + VAR(L)%W(IPHASE)*DUDZ(L) + TIMDER)
      END SELECT

      ENDDO; ENDDO; ENDDO

      RETURN
      END SUBROUTINE VMASSF

C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE FWCOEFF(PRO,VAR,BLKS,FWC,U,V,W,
     + IMAX,JMAX,KMAX,IN,JN,KN,DT,NGL,M,RO)

      USE TYPE_ARRAYS
      USE CONSTANTS, ONLY : PII,EPS6,EPS10,EPS12,EPS20

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,I,K,L,ISTRID,JSTRID,IL,
     + NGL,II,JJ,J,ISTR,JSTR,KSTR,IWFORCE,mmm,M

      REAL :: U(*),V(*),W(*),RO(*),FWC(*)
      REAL :: FRSDEN,DT,FRSVEL,CHLCAV,REFCAV,DBUBBLE,ABSVEL,DBMAX

      TYPE(PROPERTIES) PRO(*)
      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(BLOCKS) BLKS(*)

C ... Calculate the wall force

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
        
      ISTR    = 1
      JSTR    = ISTRID
      KSTR    = IL

      IWFORCE = BLKS(NGL)%WFORCEMUL
      REFCAV  = BLKS(NGL)%REFCAV
      CHLCAV  = BLKS(NGL)%CHLCAV
      FRSDEN  = BLKS(NGL)%FRSDEN
      FRSVEL  = BLKS(NGL)%FRSVEL
      DBMAX   = (3./(PII*BLKS(NGL)%N(1)))**.333 ! Max bubble diameter

      DO K = -1,KMAX+2
      JJ      = (KN+K-1)*IL
      DO J = -1,JMAX+2
      II      = (JN+J-1)*ISTRID + JJ + IN
      DO I = -1,IMAX+2

            L = I + II

            ABSVEL  = (VAR(L)%U(1) - VAR(L)%U(2))**2 +
     +                (VAR(L)%V(1) - VAR(L)%V(2))**2 +
     +                (VAR(L)%W(1) - VAR(L)%W(2))**2
            ABSVEL  = ABSVEL + 1.E-3 ! This was under SQRT!

            DBUBBLE = MIN(VAR(L)%BUBDIA(1),VAR(L)%BUBDIA(2))
            DBUBBLE = MAX(DBUBBLE,EPS10) ! Same as in drag force

      SELECT CASE(IWFORCE)

      CASE(1)  ! Hosokawa et al. (2002)

            FWC(L) = 0.5*DBUBBLE*VAR(L)%ALFA(2)*RO(L)*
     +               0.0217*PRO(L)%EO*ABSVEL
c        write(666,*) i,j,fwc(l)
      CASE(2:10)

         WRITE(*,*) IWFORCE,'No such wall force. Exiting from FWCOEFF..'
         WRITE(13,*) ' No such wall force type yet.'
         WRITE(13,*) ' BLOCK=',NGL,' WFORCEMUL =',IWFORCE,'Exiting...'
         STOP
         
       END SELECT

      ENDDO; ENDDO; ENDDO

      RETURN
      END SUBROUTINE FWCOEFF
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE INTPRO(PRO,VAR,BLKS,IMAX,JMAX,KMAX,NGL,M)

      USE TYPE_ARRAYS
      USE CONSTANTS, ONLY : PII,EPS10
      USE NS3CO, ONLY : G0,IN,JN,KN

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,I,K,L,ISTRID,JSTRID,IL,
     + IPHASE,NGL,II,JJ,J,M

      REAL :: ALMAX,ALMIN,BB(2),CC(2),RNBUBBLE,DBUBBLE

      TYPE(PROPERTIES) PRO(*)
      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(BLOCKS) BLKS(*)

C ... Calculate bubble diameter and the Eotvos number

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      BB(1) = 1.E-2 ; BB(2) = 0. ; CC(1) = 0. ; CC(2) = 1.E-4 ! Voi mersu

      DO K = -1,KMAX+2
      JJ      = (KN+K-1)*IL
      DO J = -1,JMAX+2
      II      = (JN+J-1)*ISTRID + JJ + IN
      DO I = -1,IMAX+2

         L = I + II

      DO IPHASE = 1,BLKS(NGL)%NPHASE

      RNBUBBLE  = BLKS(NGL)%N(IPHASE) ! Given bubble density

      ALMIN = MAX(VAR(L)%ALFA(2),BB(IPHASE))
      ALMAX = MIN(1.,VAR(L)%ALFA(1) + CC(IPHASE))

      IF(IPHASE == 1) THEN
      VAR(L)%BUBDIA(IPHASE) = ((ALMAX+EPS10)*6./(PII*RNBUBBLE))**.333
      ELSEIF(IPHASE  == 2) THEN
      VAR(L)%BUBDIA(IPHASE) = ((ALMIN+EPS10)*6./(PII*RNBUBBLE))**.333
      ENDIF

      ENDDO ! IPHASE

C ... Eotvos number for a sphere

      DBUBBLE   = MIN(VAR(L)%BUBDIA(1),VAR(L)%BUBDIA(2))
      PRO(L)%EO = G0*(PRO(L)%RO(1)-PRO(L)%RO(2))*DBUBBLE**2/
     +            PRO(L)%SIGMA

      ENDDO; ENDDO; ENDDO

      RETURN
      END SUBROUTINE INTPRO    
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE TIMDER(DRO,DM,DN,DW,DE,RO,RM,RN,RW,E,ROLE2,RMLE2,
     2 RNLE2,RWLE2,ELE2,ROLE3,RMLE3,RNLE3,RWLE3,ELE3,VOL,
     3 IMAX,JMAX,KMAX,IN,JN,KN,DT,NGL,PDIFF,PLE2,PLE3)
      REAL VOL(*),DRO(*),DM(*),DN(*),DW(*),DE(*),ROLE2(*),RMLE2(*),
     2 RNLE2(*),RWLE2(*),ELE2(*),ROLE3(*),RMLE3(*),RNLE3(*),RWLE3(*),
     3 ELE3(*),RO(*),RM(*),RN(*),RW(*),E(*),PDIFF(*),PLE2(*),PLE3(*)
C
C ... ADD 2-ORDER TIME DERIVATIVE TERM (VOL IS CURRENTLY CONSTANT)
C
      EPS     = 1.E-20
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      DO 1000 K = 1,KMAX
      IA      = (KN+K-1)*IL + JN*ISTRID
      DO 1000 I = 1,JMAX*ISTRID
      N       = IA + I
      PDT     = 1./(VOL(N)*DT)  ! TRAP
      DRO(N)  = DRO(N) + PDT* ! varo
     +         (-1.5*VOL(N)*(RO(N)    - ROLE2(N))
     +          +0.5*VOL(N)*(ROLE2(N) - ROLE3(N)))
c     +         (-1.5*VOL(N)*RO(N)+2.*VOL(N)*ROLE2(N)-.5*VOL(N)*ROLE3(N))
      DM(N)   = DM(N)  + PDT*
     +         (-1.5*VOL(N)*(RM(N)    - RMLE2(N))
     +          +0.5*VOL(N)*(RMLE2(N) - RMLE3(N)))
c     +         (-1.5*VOL(N)*RM(N)+2.*VOL(N)*RMLE2(N)-.5*VOL(N)*RMLE3(N))
      DN(N)   = DN(N)  + PDT*
     +         (-1.5*VOL(N)*(RN(N)    - RNLE2(N))
     +          +0.5*VOL(N)*(RNLE2(N) - RNLE3(N)))
c     +         (-1.5*VOL(N)*RN(N)+2.*VOL(N)*RNLE2(N)-.5*VOL(N)*RNLE3(N))
      DW(N)   = DW(N)  + PDT*
     +         (-1.5*VOL(N)*(RW(N)    - RWLE2(N))
     +          +0.5*VOL(N)*(RWLE2(N) - RWLE3(N)))
c     +         (-1.5*VOL(N)*RW(N)+2.*VOL(N)*RWLE2(N)-.5*VOL(N)*RWLE3(N))
      DE(N)   = DE(N)  + PDT*
     +         (-1.5*VOL(N)*(E(N)     - ELE2(N))
     +          +0.5*VOL(N)*(ELE2(N)  - ELE3(N)))
c     +         (-1.5*VOL(N)*E(N) +2.*VOL(N)*ELE2(N) -.5*VOL(N)*ELE3(N))
 1000 CONTINUE

      RETURN
      END SUBROUTINE TIMDER
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE TIMDKE(DRK,DEPS,RK,REPS,RKLE2,EPSLE2,RKLE3,EPSLE3,
     + VOL,IMAX,JMAX,KMAX,IN,JN,KN,DT)

      REAL :: VOL(*),DRK(*),DEPS(*),RK(*),REPS(*),RKLE2(*),EPSLE2(*),
     2 RKLE3(*),EPSLE3(*)
C
C ... ADD THE TIME DERIVATIVE TERM TO K-E (VOL IS CURRENTLY CONSTANT)
C
      EPS     = 1.E-20
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      DO 1000 K = 1,KMAX
      IA      = (KN+K-1)*IL + JN*ISTRID
      DO 1000 I = 1,JMAX*ISTRID
      N       = IA + I
      PDT     = 1./(VOL(N)*DT)  ! TRAP
      DRK(N)  = DRK(N)   + PDT*
     +         (-1.5*VOL(N)*(RK(N)    - RKLE2(N))
     +          +0.5*VOL(N)*(RKLE2(N) - RKLE3(N)))
c     +     (-1.5*VOL(N)*RK(N)  +2.*VOL(N)*RKLE2(N) -.5*VOL(N)*RKLE3(N))
      DEPS(N) = DEPS(N)  + PDT*
     +         (-1.5*VOL(N)*(REPS(N)  - EPSLE2(N))
     +          +0.5*VOL(N)*(EPSLE2(N)- EPSLE3(N)))
c     +     (-1.5*VOL(N)*REPS(N)+2.*VOL(N)*EPSLE2(N)-.5*VOL(N)*EPSLE3(N))
 1000 CONTINUE

      RETURN
      END SUBROUTINE TIMDKE
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE TIMDMF(VAR,PRO,P,VOL,IMAX,JMAX,KMAX,IN,JN,KN,DT,NPHASE,
     + NGL,TWO_FLUIDL)

      USE TYPE_ARRAYS
 
      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,NPHASE,ISTRID,JSTRID,IL,I,K,IA,
     +        IPHASE,N,NGL,ii,jj,kk,istr,jstr,j
      REAL :: DT,PDT,EPS,apu,apu2,DER1,DER2,DER3,DER4
      REAL :: VOL(*),P(*)
      LOGICAL :: TWO_FLUIDL

      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(PROPERTIES) PRO(*)
C
C ... ADD 2-ORDER TIME DERIVATIVE TERM (VOL IS MISSING!)

      EPS     = 1.E-20
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID

      DO IPHASE = 1,NPHASE

      ISTR = IMAX + 2*IN
      JSTR = JMAX + 2*JN
      IL   = ISTR*JSTR

      DO K = 1,KMAX
      JJ   = (KN+K-1)*IL
      DO J = 1,JMAX
      IA   = (JN+J-1)*ISTR + JJ + IN
      DO I = 1,IMAX

      N       = IA + I

      PDT     = 1./(DT)  ! VOL-TRAP

      DER1 =    -1.5*(VAR(N)%ARO(IPHASE)    - VAR(N)%AROLE2(IPHASE))
     +          +0.5*(VAR(N)%AROLE2(IPHASE) - VAR(N)%AROLE3(IPHASE))
      DER2 =    -1.5*(VAR(N)%ARE(IPHASE)    - VAR(N)%ARELE2(IPHASE))
     +          +0.5*(VAR(N)%ARELE2(IPHASE) - VAR(N)%ARELE3(IPHASE))
      DER4 =    P(N)/PRO(N)%RO(IPHASE)*DER1 !Approximates void derivative
c      CALL IJKPAI(N,IMAX,JMAX,KMAX,II,JJ,KK)

      VAR(N)%DX(IPHASE)  =  VAR(N)%DX(IPHASE)     + PDT*DER1
      VAR(N)%DE(IPHASE)  =  VAR(N)%DE(IPHASE)     + PDT*(DER2 + DER4)

      IF(TWO_FLUIDL) THEN

      DER1 =    -1.5*(VAR(N)%ARM(IPHASE)    - VAR(N)%ARMLE2(IPHASE))
     +          +0.5*(VAR(N)%ARMLE2(IPHASE) - VAR(N)%ARMLE3(IPHASE))
      DER2 =    -1.5*(VAR(N)%ARN(IPHASE)    - VAR(N)%ARNLE2(IPHASE))
     +          +0.5*(VAR(N)%ARNLE2(IPHASE) - VAR(N)%ARNLE3(IPHASE))
      DER3 =    -1.5*(VAR(N)%ARW(IPHASE)    - VAR(N)%ARWLE2(IPHASE))
     +          +0.5*(VAR(N)%ARWLE2(IPHASE) - VAR(N)%ARWLE3(IPHASE))

c      CALL IJKPAI(N,IMAX,JMAX,KMAX,II,JJ,KK)

      VAR(N)%DM(IPHASE)  =  VAR(N)%DM(IPHASE)     + PDT*DER1
      VAR(N)%DN(IPHASE)  =  VAR(N)%DN(IPHASE)     + PDT*DER2
      VAR(N)%DW(IPHASE)  =  VAR(N)%DW(IPHASE)     + PDT*DER3

      ENDIF ! TWO_FLUIDL

      ENDDO; ENDDO; ENDDO

1000  CONTINUE
      ENDDO

      RETURN
      END SUBROUTINE TIMDMF
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE STARTI(NTOT,IG,NBLOCK,TIMEL,COORL,ITURB,NSCAL,MGM,
     +  IGRID,RO,RM,RN,RW,E,RK,REPS,FI,XCO,YCO,ZCO,
     +  ROLE2,RMLE2,RNLE2,RWLE2,ELE2,RKLE2,EPSLE2,FILE2,
     +  ROLE3,RMLE3,RNLE3,RWLE3,ELE3,RKLE3,EPSLE3,FILE3,
     +  XLE2,YLE2,ZLE2,XLE3,YLE3,ZLE3,BLKS,VAR,MAXSB,IPRO,NPROCE,MBPRO,
     +  TWO_FLUIDL)

      USE TYPE_ARRAYS

      IMPLICIT NONE

      INTEGER :: NBLOCK,NSCAL,MGM,MAXSB,IPRO,MBPRO,N,NTOT1,IG1,L,I,NS,
     +     IPHASE,NPHASE,ITURB,NGL
      INTEGER :: NTOT(MGM,*),IG(MGM,*),IGRID(*), NPROCE(MBPRO+1,*)
      REAL :: RO(*),RM(*),RN(*),RW(*),E(*),RK(*),REPS(*),FI(MAXSB,*),
     +        ROLE2(*),RMLE2(*),RNLE2(*),RWLE2(*),ELE2(*),RKLE2(*),
     +        EPSLE2(*),FILE2(MAXSB,*),ROLE3(*),RMLE3(*),RNLE3(*),
     +        RWLE3(*),ELE3(*),RKLE3(*),EPSLE3(*),FILE3(MAXSB,*)
      REAL :: XCO(*),YCO(*),ZCO(*),XLE2(*),YLE2(*),ZLE2(*),
     +     XLE3(*),YLE3(*),ZLE3(*)

      LOGICAL :: TIMEL,COORL,TWO_FLUIDL

      TYPE(BLOCKS) BLKS(*)
      TYPE(MPHASE_VARIABLES) VAR(*)

C
C ... INITIALIZE ARRAYS FOR PREVIOUS TIME LEVELS for begining of 
C ... the time-accurate calculation ppr 24.1.97

      IF(TIMEL) THEN
         WRITE(4, 111) 
         WRITE(45,111)
         IF(IPRO == 1) WRITE(*, 111) 
      ENDIF
 111  FORMAT('  OLD TIME-LEVELS WERE NOT FOUND FROM THE RESTART'/)

      IF(.NOT. TIMEL .AND. COORL) THEN
         WRITE(4, 112)
         WRITE(45,112)
         IF(IPRO == 1) WRITE(*, 112)
 112  FORMAT('  OLD COORDINATES WERE NOT FOUND FROM THE RESTART'/)
      ENDIF

      DO 9000 N = 1,NBLOCK
      NTOT1   = NTOT(1,N)
      IG1     = IG(1,N)
      NGL     = NPROCE(1+N,IPRO)
      NPHASE  = BLKS(NGL)%NPHASE

      IF(TIMEL) THEN ! IN CASE ONLY COORL IS ACTIVATED

         DO 3000 L   = 1,NTOT1
            I        = L + IG1 - 1
            ROLE3(I) = RO(I) 
            RMLE3(I) = RM(I) 
            RNLE3(I) = RN(I) 
            RWLE3(I) = RW(I) 
            ELE3(I)  = E(I)  
            ROLE2(I) = RO(I)
            RMLE2(I) = RM(I)
            RNLE2(I) = RN(I)
            RWLE2(I) = RW(I)
            ELE2(I)  = E(I)
 3000    CONTINUE

         IF(ITURB >= 3 .AND. ITURB /= 8) THEN
            DO 3100 L    = 1,NTOT1
               I         = L + IG1 - 1
               RKLE3(I)  = RK(I) 
               EPSLE3(I) = REPS(I)
               RKLE2(I)  = RK(I)
               EPSLE2(I) = REPS(I)
 3100       CONTINUE
         ENDIF ! ITURB

         IF(NPHASE > 1) THEN ! (Else meaningless)
            DO IPHASE = 1,NPHASE
            DO 3150 L    = 1,NTOT1
            I         = L + IG1 - 1
            VAR(I)%AROLE3(IPHASE) = VAR(I)%ARO(IPHASE)
            VAR(I)%AROLE2(IPHASE) = VAR(I)%ARO(IPHASE)
            VAR(I)%ARELE3(IPHASE) = VAR(I)%ARE(IPHASE)
            VAR(I)%ARELE2(IPHASE) = VAR(I)%ARE(IPHASE)
 3150       CONTINUE
            ENDDO
            IF(TWO_FLUIDL) THEN
            DO IPHASE = 1,NPHASE
            DO L    = 1,NTOT1
            I         = L + IG1 - 1
            VAR(I)%ARMLE3(IPHASE) = VAR(I)%ARM(IPHASE)
            VAR(I)%ARMLE2(IPHASE) = VAR(I)%ARM(IPHASE)
            VAR(I)%ARNLE3(IPHASE) = VAR(I)%ARN(IPHASE)
            VAR(I)%ARNLE2(IPHASE) = VAR(I)%ARN(IPHASE)
            VAR(I)%ARWLE3(IPHASE) = VAR(I)%ARW(IPHASE)
            VAR(I)%ARWLE2(IPHASE) = VAR(I)%ARW(IPHASE)
            ENDDO
            ENDDO
            ENDIF ! TWO_FLUIDL
         ENDIF ! NPHASE
         IF (NSCAL /= 0) THEN
            DO 3200 NS     = 1,NSCAL
            DO 3200 L      = 1,NTOT1
               I           = L + IG1 - 1
               FILE3(I,NS) = FI(I,NS)
               FILE2(I,NS) = FI(I,NS)
 3200       CONTINUE
         ENDIF ! SCALARS
      ENDIF ! TIMEL

c      IF (COORL .AND. IGRID(N) >= 10) THEN ! not with rotation grid
      IF (COORL) THEN ! why not?? 13.1.98 PPR (voi itko)
            DO 3300 L  = 1,NTOT1
               I       = L + IG1 - 1
               IF(IGRID(NGL) >= 5) THEN  ! Was local N ??
               XLE3(I) = XCO(I)
               YLE3(I) = YCO(I)
               ZLE3(I) = ZCO(I)
               ENDIF
    
               XLE3(I) = XCO(I)
               YLE3(I) = YCO(I)
               ZLE3(I) = ZCO(I)

               XLE2(I) = XCO(I)
               YLE2(I) = YCO(I)
               ZLE2(I) = ZCO(I)
 3300    CONTINUE

      ENDIF ! COORL

 9000 CONTINUE                  ! END OF BLOCK LOOP 1
      RETURN
      END SUBROUTINE STARTI
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE LOLIM(DRK,IMAX,JMAX,KMAX,IN,JN,KN,RLIM)

      REAL :: DRK(*)
C
C ... LIMIT THE VALUES OF DRK TO > RLIM
C
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
      NTOT    = IL*(KMAX + 2*KN)

c      DO 1000 K = 1,KMAX
c      IA      = (KN+K-1)*IL + JN*ISTRID
c      DO 1000 I = 1,JMAX*ISTRID
c      N       = IA + I
      DO 1000 N = 1,NTOT
      DRK(N)  = MAX(DRK(N),RLIM)
1000  CONTINUE
      RETURN
      END SUBROUTINE LOLIM
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE LOLIME(DRK,IMAX,JMAX,KMAX,IN,JN,KN,RLIM,NGL)

      REAL :: DRK(*)
C
C ... LIMIT THE VALUES OF DRK TO > RLIM
C
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
      NTOT    = IL*(KMAX + 2*KN)

c      DO 1000 K = 1,KMAX
c      IA      = (KN+K-1)*IL + JN*ISTRID
c      DO 1000 I = 1,JMAX*ISTRID
c      N       = IA + I
      DO 1000 N = 1,NTOT
c      if(ngl == 3) write(660,*) n,drk(n),rlim
      DRK(N)  = MAX(DRK(N),RLIM)
1000  CONTINUE
      RETURN
      END SUBROUTINE LOLIME
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE LOLIMP(P,PDIFF,FRSDEN,FRSPRE,DFRSPRE,DFRSDEN,XC,YC,ZC,
     &           IMAX,JMAX,KMAX,IN,JN,KN)

      IMPLICIT NONE

      INTEGER :: IMAX,JMAX,KMAX,IN,JN,KN,ISTRID,JSTRID,IL,I,J,K,N,IA,
     &        ISTR,JSTR,JJ,NTOT
      REAL :: FRSDEN,FRSPRE,PRELIM
      REAL :: P(*),PDIFF(*)
      REAL :: DFRSPRE,DFRSDEN,DGROUND,DPH
      REAL, DIMENSION(*) :: XC,YC,ZC
C
C ... LIMIT THE VALUES OF PRESSURE AND PRESSURE DIFFERENCE
C
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
      NTOT    = IL*(KMAX + 2*KN)

c      DO K    = 1,KMAX
c      IA      = (KN+K-1)*IL + JN*ISTRID
c      DO I    = 1,JMAX*ISTRID
c      N       = IA + I
      DO N = 1,NTOT
      PRELIM  = MIN(0.,P(N)-0.01*FRSPRE)
      P(N)    = P(N) - PRELIM
      PDIFF(N)= PDIFF(N) - PRELIM
      ENDDO !; ENDDO

      RETURN
      END SUBROUTINE LOLIMP
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE UPLIM(DRK,IMAX,JMAX,KMAX,IN,JN,KN,RLIM)

      REAL :: DRK(*)
C
C ... LIMIT THE VALUES OF DRK TO < RLIM
C
      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      IL      = ISTRID*JSTRID
      DO 1000 K = 1,KMAX
      IA      = (KN+K-1)*IL + JN*ISTRID
      DO 1000 I = 1,JMAX*ISTRID
      N       = IA + I
      DRK(N)  = MIN(DRK(N),RLIM)
1000  CONTINUE
      RETURN
      END SUBROUTINE UPLIM 
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE RESIKE(NBL,M,M2,NGL,ISSB,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,
     + CH,CP,A1,D1,A1XA,A1YA,A1ZA,A2,D2,A2XA,A2YA,A2ZA,A3,D3,A3XA,A3YA,
     + A3ZA,XC,YC,ZC,DISTW,XCO,YCO,ZCO,DTL,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,RMLOSS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + DT,GAMMA,RGAS,DRO,DM,DN,DW,DE,VOL,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,OHMI,DELTA,ICP,JCP,KCP,
     + IJMASK,IMAX,JMAX,KMAX,INTERI,INTERJ,INTERK,IDERI, 
     + JBOT,JTOP,IDI1,IDI2,IDI3,
     + IT,IL,IK,IPRINT,ICMAX,MPRINT,ICYCLE,ITIMES,T,
     + PR,PRT,LUSGS,CFL,CX,CY,CZ,CMX,CMY,CMZ,
     + DX,DY,DZ,QX,QY,QZ,TOMEGA,OMEGA,OMEX,OMEY,OMEZ,
     + ICON,NPATCH,XMOM,YMOM,ZMOM,
     + IBOT,ITOP,KBOT,KTOP,LAMIN,IFLUX, 
     + UBI,VBI,WBI,UBJ,VBJ,WBJ,UBK,VBK,WBK,UTI,VTI,WTI,
     + UTJ,VTJ,WTJ,UTK,VTK,WTK,UROT,VROT,WROT,RCON,RK,REPS,
     + DDEPS,DRK,DEPS,SRK,SEPS,PTUR,FUN1,F1RK,F1EPS,TTS,
     + BIJ,WIR,MAXEB,ISTRES,TURLIM,RKLIM,EPSLIM,FRSDEN,FRSPRE,
     + FRSVEL,FRSVIS,T0,DIFPRE,CHLREF,DRDH,DRDP,ISTATE,JSTATE,
     + ITURB,IDIS,KOVER,E0REF,T0REF,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,
     + NSCAL,KSCAL,HAT1,HAT2,HAT3,HAT4,RLOLIM,PROD,PI,DIF,DIS,VVIS,FWLL,
     + JRDIF,JRDIS,JRPRE,S11,MAXSS,STRESL,SOURL,TIMEL,GRAVIL,IEPSMA,
     + ROLE2,RMLE2,RNLE2,RWLE2,ELE2,RKLE2,EPSLE2,FILE2,XLE2,YLE2,ZLE2,
     + ROLE3,RMLE3,RNLE3,RWLE3,ELE3,RKLE3,EPSLE3,FILE3,XLE3,YLE3,ZLE3,
     + W12,SIJ,GRADT,GRADK,GREPS,MAX11,
     + NCHIM,ROFOR,RMFOR,RNFOR,RWFOR,EFOR,PDFOR,RKFOR,REFOR,MPFOR,
     + RKSI,FIFOR,
     + QMFIN,QVFIN,QMEIN,QMFOUT,QVFOUT,QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,
     + QMZIN,QMZOUT,CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,
     + IROTCO,FULLNS,IPRESC,ZZZ,MAXW,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,BOUNA1,
     + BOUNA2,IBF,PRO,VAR,BLKS,MULPHL,PRC,TURCOR,XXTRAL,FRESUL,IFSBC,
     + F1H,WAVEH,IWAVEB,FREDIF,IGRID,BUX,BUY,BUZ,VMXB,VMYB,VMZB,FRSSIE,
     + VTRAN,INTERTU,RE,RNUT,VORT,SHEAR,STRAIN,PSEUCO,RJK2,RJK4,TURDESL,
     + INCHIML,ENTROPY_FIX,QGFIN,QGEIN,QGFOUT,QGEOUT,
     + TUR_FRS_SOURCE,TRANSL,TRM,BOUNG,BOUNRET,PLE2,PLE3,IDIMSG,JDIMSG,
     + SURFA,SURFT,SURF2X,SURF2Y,SURF2Z,SURFMX,SURFMY,SURFMZ,CDIFF,
     + VELLAP,QSAS,IUPPTL,BOUNU1,BOUNU2,BOUNV1,BOUNV2,BOUNW1,BOUNW2,
     + SURFPX,SURFPY,SURFPZ,QLFIN,QLEIN,QLFOUT,QLEOUT,UTAUM,EPSOLD)

      USE TYPE_ARRAYS
      USE CHARACTERS
      USE CONSTANTS, ONLY : EPS, PII
      USE INTEGERS, ONLY  : MAXFS, MAXB, IREPEA
      USE NS3CO, ONLY     : IC9, IN, JN, KN, GX, GY, GZ,
     +                      TWO_FLUIDL, NPHASE, CHIMEL

      IMPLICIT NONE

      INTEGER :: NBL,M,M2,NGL,IMAX,JMAX,KMAX,INTERI,INTERJ,INTERK,IDERI,
     2 JBOT,JTOP,IDI1,IDI2,IDI3,IT,IL,IK,IPRINT,ICMAX,MPRINT,ICYCLE,
     3 ITIMES,LUSGS,NPATCH,IBOT,ITOP,KBOT,KTOP,LAMIN,IFLUX,MAXEB,ISTRES,
     4 ISTATE,ITURB,IDIS,KOVER,NSCAL,KSCAL,JRDIF,JRDIS,JRPRE,MAXSS,
     5 IEPSMA,MAX11,NCHIM,IROTCO,IPRESC,MAXW,IBF,ISTRID,JSTRID,KSTRID,
     6 ISTR,JSTR,KSTR,KMAXP,NTOT,IDM1,IDM2,IDM3,INTETI,INTETJ,LAMIN1,
     7 LAMIN2,LAMIN3,KBEGIN,NS,ILPO,II,IB,NT,NNN,I,J,K,KA,JJ,IA,LRICH,
     8 MAXSB,INTETK,IDO,IPHASE,ICHARP,ku1,ku2,ku3,ku4,ku5,ku6,IFSBC,
     9 ISLAB,IGRID,III,INTERTU,L,IUPPTL,KK,INTEAI,INTEAJ,INTEAK,II9

      REAL :: DT,GAMMA,RGAS,DELTA,T,PR,PRT,CFL,OMEGA,
     2 OMEX,OMEY,OMEZ,TURLIM,RKLIM,EPSLIM,FRSDEN,FRSPRE,
     3 FRSVIS,T0,DIFPRE,CHLREF,E0REF,T0REF,QMFIN,QMEIN,QMFOUT,QMEOUT,
     4 QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMXOUT,CMYIN,CMYOUT,
     5 CMZIN,CMZOUT,C1,C2,C3,C21,CMU,CTA,PSIGK,PSIGE,AA1,ETA0,PSIGK1,
     6 PSIGE1,A1KLEB,BSTAR,CKAPPA,BETA1,SIGRK1,SIGOM1,BETA2,SIGRK2,
     7 SIGOM2,PVISC,FRSVEL,QVFIN,QVFOUT,FREDIF,FRSSIE,RE,PSEUCO,
     8 RJK2,RJK4,ARTSSP,QGFIN,QGEIN,QGFOUT,QGEOUT,GXS,GYS,GZS,CDIFF,
     9 SIGPHI,ZETA2,QLFIN,QLEIN,QLFOUT,QLEOUT

      REAL :: RO(*),RM(*),RN(*),E(*),P(*),PDIFF(*),U(*),V(*),C(*),
     2 A1(*),A1XA(*),A1YA(*),A1ZA(*),A2(*),A2XA(*),A2YA(*),A2ZA(*),
     3 A3(*),A3XA(*),A3YA(*),A3ZA(*),DISTW(*),DRO(*),DM(*),
     4 DN(*),DE(*),VOL(*),F1R(*),F1RM(*),F1RN(*),F1E(*),F1RW(*),D1(*),
     5 CH(*),TEMP(*),VIS(*),EPS2(*),VIST(*),CP(*),
     6 UWALL(*),VWALL(*),WWALL(*),CPWALL(*),TWALL(*),QWALL(*),
     7 QWFRIC(*),TAUW1(*),TAUW2(*),SURFX(*),SURFY(*),SURFZ(*),
     8 TAUWX(*),TAUWY(*),TAUWZ(*),SURLE(*),DSURLE(*),WMFLUX(*),
     9 POROS(*),WHSTAG(*),WTEMP(*),RSDIRX(*),RSDIRY(*),RSDIRZ(*),
     1 RBK(*),HFLUX(*),RMLOSS(*),
     2 OHMI(*),STRAIN(*),
     3 RW(*),W(*),DW(*),D2(*),D3(*),
     4 UROT(*),VROT(*),WROT(*),PTUR(*),FUN1(*),TTS(*),
     5 RK(*),REPS(*),DRK(*),DEPS(*),SRK(*),SEPS(*),F1RK(*),F1EPS(*),
     6 DRDH(*),DRDP(*),PSIGSC(*),PSIGS2(*),TOMEGA(*),
     7 CX(*),CY(*),CZ(*),CMX(*),CMY(*),CMZ(*),DX(*),DY(*),DZ(*),
     8 QX(*),QY(*),QZ(*),RCON(IC9,*),
     9 UBI(*),VBI(*),WBI(*),UBJ(*),VBJ(*),WBJ(*),UBK(*),VBK(*),WBK(*),
     1 UTI(*),VTI(*),WTI(*),UTJ(*),VTJ(*),WTJ(*),UTK(*),VTK(*),WTK(*),
     2 FI(MAXSB,MAX(1,NSCAL)),F1FI(MAXSB,MAX(1,NSCAL)),
     3 DFI(MAXSB,MAX(1,NSCAL)),SFI(MAXSB,MAX(1,NSCAL)),
     4 HAT1(*),HAT2(*),HAT3(*),HAT4(*),
     5 PROD(MAXSB,6),PI(MAXSB,6),DIF(MAXSB,6),DIS(MAXSB,6),
     6 VVIS(MAXSB,6),FWLL(*),RLOLIM(*),S11(MAXSS,6),DDEPS(*),
     7 ROLE2(*),RMLE2(*),RNLE2(*),RWLE2(*),ELE2(*),RKLE2(*),EPSLE2(*),
     8 ROLE3(*),RMLE3(*),RNLE3(*),RWLE3(*),ELE3(*),RKLE3(*),EPSLE3(*),
     9 ROFOR(*),RMFOR(*),RNFOR(*),RWFOR(*),
     1 EFOR(*),PDFOR(*),RKFOR(*),REFOR(*),RKSI(*),
     2 FILE2(MAXSB,MAX(1,NSCAL)),FILE3(MAXSB,MAX(1,NSCAL)),
     3 FIFOR(MAXSB,MAX(1,NSCAL)),
     4 W12(MAX11,3),SIJ(MAX11,6),GRADT(MAX11,3),GRADK(MAX11,3),
     5 DTL(*),GREPS(MAX11,3),ZZZ(*),BIJ(MAXEB,6),WIR(MAXEB,3),BOUNR(*),
     6 BOUNU(*),BOUNV(*),BOUNW(*),BOUNE(*),BOUNT(*),BOUNRK(*),BOUNEP(*),
     7 BOUNP(*),BOUNPD(*),BOUNFI(IBF,MAX(1,NSCAL)),BOUNBI(IBF,*),
     8 BOUNMF(*),
     9 BOUNA1(*),BOUNA2(*),F1H(*),BUX(*),BUY(*),BUZ(*),VMXB(*),VMYB(*),
     1 VMZB(*),VTRAN(*),RNUT(*),VORT(MAXB,*),SHEAR(MAXB,*),
     2 BOUNG(*),BOUNRET(*),PLE2(*),PLE3(*),SURFA(*),SURFT(*),
     3 SURF2X(*),SURF2Y(*),SURF2Z(*),SURFMX(*),SURFMY(*),SURFMZ(*),
     4 VELLAP(*),QSAS(*),
     5 BOUNU1(*),BOUNU2(*),BOUNV1(*),BOUNV2(*),BOUNW1(*),BOUNW2(*),
     6 SURFPX(*),SURFPY(*),SURFPZ(*),UTAUM(*),EPSOLD(*)

      REAL, ALLOCATABLE, DIMENSION(:) :: DSUR,WAVE,SCALEJ, T2(:)
      REAL, ALLOCATABLE, DIMENSION(:) :: GRADAX,GRADAY,GRADAZ
      REAL, ALLOCATABLE, DIMENSION(:) :: DDSUR

      REAL, ALLOCATABLE :: DUIDXJ(:,:)

      INTEGER :: IHF(*),ISSB(*),ICP(*),JCP(*),
     &           KCP(*),IJMASK(*),ICON(IC9,*),JSTATE(*),IWAVEB(*),
     &           IDIMSG(*),JDIMSG(*)

      REAL :: XCO(*),YCO(*),ZCO(*),XLE2(*),YLE2(*),ZLE2(*),
     & XLE3(*),YLE3(*),ZLE3(*),ZC(*),YC(*),XC(*),
     & XCP(*),YCP(*),ZCP(*)

      REAL :: WAVEH(*) 
    
      REAL :: XMOM,YMOM,ZMOM
     

      TYPE(PROPERTIES)       :: PRO(*)
      TYPE(MPHASE_VARIABLES) :: VAR(*)
      TYPE(MPHASE_FORTIFY)   :: MPFOR(*)
      TYPE(BLOCKS)           :: BLKS(*)
      TYPE(PRE_COR)          :: PRC(*)
      TYPE(INTERMITTENCY)    :: TRM(*)

      LOGICAL :: STRESL,SOURL,TIMEL,STRE2L,GRAVIL,FULLNS,MULPHL,TURCOR,
     2 XXTRAL,FRESUL,TURDESL,INCHIML,ENTROPY_FIX,TUR_FRS_SOURCE,TRANSL

      REAL :: RSURF(1,6) ! Korvaa tämä patch-tyyppisellä taulukolla

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      KSTRID  = KMAX + 2*KN

      ISTR    = 1
      JSTR    = ISTRID
      KSTR    = ISTRID*JSTRID
      KMAXP   = KMAX + 1

      NTOT    = ISTRID*JSTRID*KSTRID
        
      IREPEA(20) = 0

      ALLOCATE(SCALEJ(NTOT),T2(NTOT))

      IF(TWO_FLUIDL) THEN
         ALLOCATE(GRADAX(NTOT),GRADAY(NTOT),GRADAZ(NTOT))
         CALL ADJUPRO(PRO,0.,IMAX,JMAX,KMAX,IN,JN,KN)
      ENDIF

      SCALEJ(1:NTOT) = 0. ; T2(1:NTOT) = 0.

      IF(ICYCLE == IPRINT) THEN
         WRITE(3,*)
         WRITE(3,*) ' Values at the beginning of RESIKE'
      ENDIF

c ... Scaling for the Jameson type dissipation

      ARTSSP = BLKS(NGL)%ARTSSP

      CALL SCALARD(SCALEJ,A1,A2,A3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,
     + A3XA,A3YA,A3ZA,U,V,W,C,UROT,VROT,WROT,IMAX,JMAX,KMAX,IN,JN,KN,
     + ARTSSP,IPRESC)

        
C ... Put the surface level into a temporary single precision array WAVE

      IF(FRESUL) THEN
        
         ISLAB   = MAX(ISTRID*JSTRID,ISTRID*KSTRID,JSTRID*KSTRID)

         ALLOCATE(DSUR(NTOT),WAVE(NTOT),DDSUR(ISLAB))
         WAVE  = 0.
         DSUR  = 0.
         DDSUR = 0.

         IF(M2 == 1) THEN
         CALL PATVSP(WAVEH,WAVE,F1R,IMAX,JMAX,KMAX,IN,JN,KN,NGL,M,
     +     NPATCH,ICON,IHF,'FRE',.FALSE.)
         ENDIF

      ELSE IF(MULPHL .AND. ICYCLE == IPRINT) THEN

         ALLOCATE(DSUR(1),WAVE(1),DDSUR(NTOT))
         DDSUR = 0.

      ELSE

         ALLOCATE(DSUR(1),WAVE(1),DDSUR(1))
         WAVE = 0.

      ENDIF
       
C ... ADJUST SURFACES WITH FRICTION TO THE GRID LEVEL USED

      IDM1    = (IDI1-1)/2**(M-1) + 1
      IDM2    = (IDI2-1)/2**(M-1) + 1
      IDM3    = MAX(1,(IDI3-1)/2**(M-1)) + 1
      IF(IDI3 == 0) IDM3 = 0
          
C ... ADJUST DISCRETIZATION FOR TURBULENCE VALUES
         
      IF(INTERTU == 0) THEN ! Normal treatment
         INTETI  = INTERI
         INTETJ  = INTERJ
         INTETK  = INTERK
         IF(INTERI > -5 .AND. INTERI < 5) INTETI = +1
         IF(INTERJ > -5 .AND. INTERJ < 5) INTETJ = +1
         IF(INTERK > -5 .AND. INTERK < 5) INTETK = +1
      ELSE ! Force the INTERTU value, e.g. INTERTU = +6
         INTETI  = INTERTU
         INTETJ  = INTERTU
         INTETK  = INTERTU
      ENDIF

C ... ADJUST VOID INTERPOLATION METHOD

      INTEAI = BLKS(NGL)%INTERI
      INTEAJ = BLKS(NGL)%INTERJ
      INTEAK = BLKS(NGL)%INTERK

C ... SEPARATE COORDINATE DIRECTIONS FROM LAMIN

      IF (ITURB == 0) THEN
         LAMIN1  = 0
         LAMIN2  = 0
         LAMIN3  = 0
      ELSE
         LAMIN1  = LAMIN/100
         LAMIN2  = (LAMIN - LAMIN1*100)/10
         LAMIN3  =  LAMIN - LAMIN1*100 - LAMIN2*10
      ENDIF

      STRE2L  = STRESL
      IF(ITURB >= 10 .AND. ITURB <= 19) STRE2L = .FALSE.

      KBEGIN  = NSCAL - KSCAL + 1 ! BEGINING OF SCALARS

C **********************************************************************
C                                                                      *
C ... CALCULATION OF FLUXES FOR K-EPSILON MODEL. VAN LEER DOES NOT WORK*
C                                                                      *
C **********************************************************************

C ... INITIALIZATION OF THE RESIDUALS

      CALL ZEROZZ(DRO, NTOT)
      CALL ZEROZZ(DM,  NTOT)
      CALL ZEROZZ(DN,  NTOT)
      CALL ZEROZZ(DW,  NTOT)
      CALL ZEROZZ(DE,  NTOT)
      CALL ZEROZZ(DRK, NTOT)
      CALL ZEROZZ(DEPS,NTOT)
      CALL ZEROZZ(SRK, NTOT)
      IF(IPRESC == 1) THEN
      PRC(1:NTOT)%DRO = 0.
      ENDIF


C ... INITIALIZATION OF THE MULTIPHASE RESIDUALS

      IF(MULPHL) THEN
      DO IPHASE = 1,NPHASES
      VAR(1:NTOT)%DX(IPHASE) = 0.
      VAR(1:NTOT)%DE(IPHASE) = 0.
      IF(M == 1) THEN
      VAR(1:NTOT)%EVAPR(1)   = 0.
      VAR(1:NTOT)%EVAPR(2)   = 0.
c      VAR(1:NTOT)%RKIF(1)    = 0.
c      VAR(1:NTOT)%RKIF(2)    = 0.
      ENDIF
      IF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
      CALL ADJUVAR(PRC,0.,IMAX,JMAX,KMAX,IN,JN,KN)

      VAR(1:NTOT)%DM(IPHASE) = 0.
      VAR(1:NTOT)%DN(IPHASE) = 0.
      VAR(1:NTOT)%DW(IPHASE) = 0.
c      PRC(1:NTOT)%DPDX       = 0.
c      PRC(1:NTOT)%DPDY       = 0.
c      PRC(1:NTOT)%DPDZ       = 0.
c         VAR(II)%U(IPHASE) = U(II)
c         VAR(II)%V(IPHASE) = V(II)
c         VAR(II)%W(IPHASE) = W(II)
      U(1:NTOT) = VAR(1:NTOT)%ALFA(1)*VAR(1:NTOT)%U(1)
     +          + VAR(1:NTOT)%ALFA(2)*VAR(1:NTOT)%U(2)
      V(1:NTOT) = VAR(1:NTOT)%ALFA(1)*VAR(1:NTOT)%V(1)
     +          + VAR(1:NTOT)%ALFA(2)*VAR(1:NTOT)%V(2)
      W(1:NTOT) = VAR(1:NTOT)%ALFA(1)*VAR(1:NTOT)%W(1)
     +          + VAR(1:NTOT)%ALFA(2)*VAR(1:NTOT)%W(2)

      ENDIF ! MULTI
      ENDDO
      ENDIF

C ... INITIALIZATION OF THE INTERMITTENCY RESIDUALS

      IF(TRANSL) THEN
      TRM(1:NTOT)%DG   = 0.
      TRM(1:NTOT)%DRET = 0.
      ENDIF

C     INITIALIZATION OF SCALAR RESIDUALS. PPR 11.2.

      DO 7 NS = 1,NSCAL
         CALL ZEROZZ(DFI(1,NS),NTOT)
7     CONTINUE

C     Initialize also the blending function F1.

      CALL ZEROZZ(FUN1,NTOT)

C     INITIALIZATION OF REYNOLDS STRESS SOURCES

      IF(ITURB >= 21 .AND. SOURL) THEN
      DO 8 NS = 1,6
         CALL ZEROZZ(DIF(1,NS), NTOT)
         CALL ZEROZZ(PROD(1,NS), NTOT)
         CALL ZEROZZ(VVIS(1,NS),NTOT)
         CALL ZEROZZ(DIS(1,NS), NTOT)
 8    CONTINUE
      ENDIF

      DO NS = 1,NSCAL
         CALL ZEROZZ(SFI(1,NS), NTOT)
      ENDDO

      IF(ITURB >= 21) THEN
         CALL SETVAL(FWLL,1.,NTOT)
         CALL SETVAL(SFI(1,1),1.,NTOT)    ! wall function
         CALL SETVAL(SFI(1,2),1000.,NTOT) ! wall distance
         CALL SETVAL(SFI(1,3),1000.,NTOT) ! wall distance in yplus
      ENDIF

C ... COEFFICIENTS FOR THE TURBULENCE MODELS

C ... DERFUN is recalled here because it stabilezed result
C ... next to the surfaces. (RIIPPUMATTA VIVUSTA FULLNS)
C ... (antakee mersu)


      IF(M2 >= 2) THEN      ! for M2=1 DERFUN called in TURBEQ

      CALL ZEROZZ(OHMI,NTOT)

      DO NS = 1,3
      CALL ZEROZZ(  W12(1,NS),NTOT)
      CALL ZEROZZ(GRADT(1,NS),NTOT)
      CALL ZEROZZ(GRADK(1,NS),NTOT)
      CALL ZEROZZ(GREPS(1,NS),NTOT)
      ENDDO

      DO NS = 1,6
      CALL ZEROZZ(SIJ(1,NS),NTOT)
      ENDDO

      CALL DERFUN(OHMI,W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),
     +     SIJ(1,3),SIJ(1,4),SIJ(1,5),SIJ(1,6),U,V,W,A1,A2,A3,VOL,
     +     D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     +     XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M,STRAIN,VELLAP)

      ENDIF ! M2 >= 2

      CALL TURBCO(ITURB,JRDIS,JRPRE,C1,C2,C3,C21,CMU,CTA,PSIGK,
     +     PSIGE,AA1,ETA0)

      PSIGK1 = 0.
      PSIGE1 = 0.

      CALL COEFKO(ITURB,A1KLEB,BSTAR,CKAPPA,
     &     BETA1,SIGRK1,SIGOM1,BETA2,SIGRK2,SIGOM2,
     &     SIGPHI,ZETA2,KOVER)

C     Adjust the diffusion coefficients for k-omega diffusion-fluxes:

      IF(IDIS == 2) THEN ! FUN1 must be calculated before fluxes
         PSIGK1  = SIGRK1
         PSIGE1  = SIGOM1
         PSIGK   = SIGRK2
         PSIGE   = SIGOM2
         IB = 1
C .... This should have been done in REFLEC
c         CALL REFLKO(RK,REPS,RO,SIJ,VIS,RBK,IMAX,JMAX,KMAX,
c     &        IN,JN,KN,RSURF,ICON,IHF,NPATCH,IB,MAX11,DISTW)

         CALL CROSKO(SEPS,RO,RK,REPS,VOL,A1,A1XA,A1YA,A1ZA,
     &        A2,A2XA,A2YA,A2ZA,A3,A3XA,A3YA,A3ZA,
     &        IMAX,JMAX,KMAX,IN,JN,KN,SIGOM2,SIGPHI,T2,KOVER)
         CALL FUN1KO(FUN1,SEPS,VIS,RO,RK,REPS,DISTW,TRANSL,
     &        IMAX,JMAX,KMAX,IN,JN,KN,BSTAR,SIGOM2,RKLIM,CHLREF,RE,NGL)
                   
      IF(ICYCLE == IPRINT) THEN
       CALL PRINYS(3,REPSC,  REPS,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
       CALL PRINYS(3,  RKC,    RK,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
       CALL PRINYS(3,  ROC,    RO,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
       CALL PRINYS(3,CROSDC,  SEPS,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
       CALL PRINYS(3,SRC(2),SIJ(1,2),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
       CALL PRINYS(3,DISTWC,DISTW,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
       CALL PRINYS(3,FUN1C,  FUN1,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
      ENDIF ! ICYCLE == IPRINT

      ENDIF

      IF(IDIS == 1)  CALL ZEROZZ(SEPS,NTOT) ! seps is used as crossdiffusion
      IF(ITURB == 10)CALL SETVAL(SEPS,1.,NTOT)

C ... EXACT DIFFUSION TERM IN RSM

      IF (JRDIF >= 4) THEN
         DO 12  NT = 1,6
         CALL DIFEX(RO,RK,REPS,VIS,EPS2,VOL,A1,A2,A3,
     +           A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     +           FI(1,1),FI(1,2),FI(1,3),FI(1,4),FI(1,5),FI(1,6),
     +           FI(1,NT),DFI(1,NT),DIF(1,NT),VVIS(1,NT),
     +           PSIGSC(NT),PSIGS2(NT),IMAX,JMAX,KMAX,IN,JN,KN,
     +           F1FI(1,1),F1FI(1,2),F1FI(1,3),JRDIF,SOURL)
         DO 11 NS = 1,3
            CALL ZEROZZ(F1FI(1,NS), NTOT)
 11      CONTINUE
 12      CONTINUE
      ENDIF

      IF(ICYCLE == IPRINT) THEN
      KU1     = IT
      KU2     = IL
      KU3     = IK
      KU4     = IMAX
      KU5     = JMAX
      KU6     = KMAX
      IF(KU2 <= 3) THEN
      WRITE(46,*)
      WRITE(46,*) 'ICYCLE = ',ICYCLE,'IN RESIKE:'
      ENDIF
      CALL PRINYD(46,XCC ,XC  ,KU1,KU2,0,KU3,KU4,KU5,KU6,NGL,M)
      CALL PRINYD(46,YCC ,YC  ,KU1,KU2,0,KU3,KU4,KU5,KU6,NGL,M)
      CALL PRINYD(46,ZCC ,ZC  ,KU1,KU2,0,KU3,KU4,KU5,KU6,NGL,M)
      IF(KU2 <= 3) THEN
      WRITE(46,*); WRITE(3,*)
      WRITE(46,*) 'IN RESIKE:'; WRITE(3,*) ' IN RESIKE:'
      ENDIF
      CALL PRINYD(46,XCOC,XCO ,KU1,KU2,0,KU3,KU4,KU5,KU6,NGL,M)
      CALL PRINYD(46,YCOC,YCO ,KU1,KU2,0,KU3,KU4,KU5,KU6,NGL,M)
      CALL PRINYD(46,ZCOC,ZCO ,KU1,KU2,0,KU3,KU4,KU5,KU6,NGL,M)
         CALL PRINYS(3,ROC,     RO,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(CHIMEL)
     +   CALL PRINYS(3,ROFORC,ROFOR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RMC,     RM,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(CHIMEL)
     +   CALL PRINYS(3,RMFORC,RMFOR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RNC,     RN,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(CHIMEL)
     +   CALL PRINYS(3,RNFORC,RNFOR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RWC,     RW,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(CHIMEL)
     +   CALL PRINYS(3,RWFORC,RWFOR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,EC,       E,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(CHIMEL)
     +   CALL PRINYS(3,EFORC,  EFOR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI') THEN
         CALL PRINYS(3,UC,       U,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,VC,       V,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,WC,       W,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         DO IPHASE = 1,1 !BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%U(IPHASE)
         CALL PRINYS(3,CHAR_VAR(33,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%V(IPHASE)
         CALL PRINYS(3,CHAR_VAR(34,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%W(IPHASE)
         CALL PRINYS(3,CHAR_VAR(35,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDDO
         ENDIF
         CALL PRINYS(3,PC,       P,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,PDIFC,PDIFF,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,TEMPC, TEMP,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,VISC,   VIS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DRDPC, DRDP,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DRDHC, DRDH,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,CC,       C,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,EPS2C, EPS2,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,VISTC, VIST,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,CHC,     CH,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(ITURB >= 3) THEN
         WRITE(3,*) 'RESIKEn arvot'
         CALL PRINYS(3,RKC,     RK,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,REPSC, REPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
         DO 8170 NS = 1,NSCAL
         CALL PRINYS(3,FIC(NS),FI(1,NS),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
 8170    CONTINUE
         IF(ITURB >= 10 .AND. ITURB <= 19) THEN
         DO 8171 NS = 1,6
         CALL PRINYS(3,UUC(NS),S11(1,NS),IT,IL,0,IK,IMAX,JMAX,KMAX,
     +           NGL,M)
 8171    CONTINUE
         ENDIF
      ENDIF

C ... REFLECT VELOCITIES SO THAT CENTRAL DIFFERENCE IS APPLIED IN 
C ... NEXT FACE FROM THE SOLID WALL AT THE FIRST GRID LEVEL
C ... This will change the reflected values in the first layer
C ... below the surface

      IF (M == 1) THEN
         CALL REFCEN(U,V,W,VAR,TRM,IMAX,JMAX,KMAX,IBOT,ITOP,JBOT,JTOP,
     +        KBOT,KTOP,IN,JN,KN,FRSDEN,FRSPRE,NPATCH,ICON,RO,P,PDIFF,
     +        E,RM,RN,RW,RK,REPS,ITURB,ISTATE,BLKS(NGL)%SOLUTION_TYPE,
     2        TRANSL)
      IF(ITURB >= 21) THEN
         CALL REFLUU(FI(1,1),FI(1,2),FI(1,3),FI(1,4),FI(1,5),FI(1,6),
     +        IMAX,JMAX,KMAX,IBOT,ITOP,JBOT,JTOP,KBOT,KTOP,
     +        IN,JN,KN,NPATCH,ICON,NGL)
      ENDIF    ! ITRUB >= 21
      IF(ITURB >= 10 .AND. ITURB <= 19) THEN
         CALL REFLUU(S11(1,1),S11(1,2),S11(1,3),S11(1,4),S11(1,5),
     +        S11(1,6),IMAX,JMAX,KMAX,IBOT,ITOP,JBOT,JTOP,KBOT,KTOP,
     +        IN,JN,KN,NPATCH,ICON,NGL)
      ENDIF ! ITURB >= 10 .AND. ITURB <= 19

      ENDIF ! M == 1

      CALL ZEROZZ(F1E,NTOT)         ! INITIALIZATION OF THE TRUE EPSILON
      CALL MAKE_EPS(RO,RK,REPS,DDEPS,F1E,ITURB,NTOT)

      IF(ITURB >= 3 .AND. ITURB <= 9 .AND.ISTRES == 0) THEN
         CALL PRODKE(OHMI,W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),
     +        SIJ(1,3),SIJ(1,4),SIJ(1,5),SIJ(1,6),PTUR,RK,REPS,DDEPS,
     +        F1E,EPS2,VIST,VIS,zzz(1),zzz(1),zzz(1),zzz(1),zzz(1),
     +        zzz(1),VTRAN,IMAX,JMAX,KMAX,IN,JN,KN,M,ITURB,
     +        BLKS(NGL)%KATOL)

c        CALL PRINYS(302,PTURC,PTUR, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
      ELSE IF(ISTRES >= 1) THEN
         CALL PEEKOO(VIS,EPS2,SIJ,BIJ,VTRAN,IMAX,JMAX,KMAX,RK,PTUR,
     +        MAXEB,MAX11)

      ELSE IF(ITURB  >= 21 .AND. ITURB  <= 23) THEN

         CALL PRODKE(OHMI,W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),
     +        SIJ(1,3),SIJ(1,4),SIJ(1,5),SIJ(1,6),PTUR,RK,REPS,DDEPS,
     +        F1E,EPS2,VIST,VIS,FI(1,1),FI(1,2),FI(1,3),FI(1,4),FI(1,5),
     +        FI(1,6),VTRAN,IMAX,JMAX,KMAX,IN,JN,KN,M,ITURB,
     +        BLKS(NGL)%KATOL)
      ENDIF

      IF(FULLNS) THEN

      CALL TEMDER(TEMP,GRADT(1,1),GRADT(1,2),GRADT(1,3),A1,A2,A3,
     + VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     + XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)

      CALL DIVV12(DDEPS,RK,RO,NTOT)

      CALL TEMDER(DDEPS,GRADK(1,1),GRADK(1,2),GRADK(1,3),A1,A2,A3,
     + VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     + XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)

      CALL DIVV12(DDEPS,REPS,RO,NTOT)

      CALL TEMDER(DDEPS,GREPS(1,1),GREPS(1,2),GREPS(1,3),A1,A2,A3,
     + VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     + XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)

      ENDIF ! FULLNS

      CALL ZEROZZ(DDEPS,NTOT)


C******************************************************************
C                                                                 *
C ... FLUXES IN ZETA (=K) -DIRECTION                              *
C                                                                 *
C******************************************************************

      CALL FLXCYC(NGL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,CP,
     + A3,D3,A3XA,A3YA,A3ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,
     + W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),SIJ(1,3),SIJ(1,4),
     + SIJ(1,5),SIJ(1,6),GRADT(1,1),GRADT(1,2),GRADT(1,3),GRADK(1,1), 
     + GRADK(1,2),GRADK(1,3),GREPS(1,1),GREPS(1,2),GREPS(1,3),RGAS,
     + GAMMA,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,OHMI,KCP,IMAX,JMAX,KMAX,
     + IN,JN,KN,ISTRID,JSTRID,KSTRID,ICYCLE,ICMAX,INTERK,INTETK,
     + INTEAK,IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,S11,MAXSS,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,RMLOSS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,KBOT,KTOP,LAMIN3,IFLUX,
     + WROT,IDM3,UBK,VBK,WBK,UTK,VTK,WTK,
     + RK,REPS,DDEPS,DRK,DEPS,SRK,SEPS,
     + PTUR,F1RK,F1EPS,FUN1,BIJ,MAXEB,ISTRES,TURLIM,RKLIM,
     + EPSLIM,PSIGK1,PSIGE1,PSIGK,PSIGE,C1,C2,CMU,CTA,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + ITURB,IDIS,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,KBEGIN,
     + KSCAL,HAT1,HAT2,HAT3,HAT4,RLOLIM,PROD,PI,DIF,DIS,VVIS,FWLL,
     + JRDIF,JRDIS,JRPRE,SOURL,IMAX,JMAX,KMAX,IN,JN,KN,KMAXP,
     + ISTR,JSTR,KSTR,3,FULLNS,ZZZ,MAXW,MAX11,
     + XCO,YCO,ZCO,QMFIN,QVFIN,QMEIN,QMFOUT,QVFOUT,QMEOUT,
     + QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMYIN,
     + CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,BOUNA1,
     + BOUNA2,IBF,PRO,VAR,PRC,BLKS,MULPHL,JSTATE,IPRESC,TURCOR,XXTRAL,
     + FRESUL,F1H,WAVE,IFSBC,IWAVEB,FREDIF,BUX,BUY,BUZ,VMXB,VMYB,VMZB,
     + FRSSIE,RNUT,STRAIN,PSEUCO,RJK2,RJK4,SCALEJ,RKSI,INCHIML,
     + ENTROPY_FIX,GRAVIL,QGFIN,QGEIN,QGFOUT,QGEOUT,
     + TRANSL,TRM,BOUNG,BOUNRET,DISTW,PLE2,IDIMSG,JDIMSG,SURFA,SURFT,
     + SURF2X,SURF2Y,SURF2Z,SURFMX,SURFMY,SURFMZ,IUPPTL,
     + BOUNU1,BOUNU2,BOUNV1,BOUNV2,BOUNW1,BOUNW2,SURFPX,SURFPY,SURFPZ,
     + QLFIN,QLEIN,QLFOUT,QLEOUT,UTAUM,EPSOLD)

c     + dudxi,dudyi,dudzi,dvdxi,dvdyi,dvdzi,dwdxi,dwdyi,dwdzi)

      IF (KMAX == 1) THEN       ! axisymmetric case
c         IF(ISTRES == 0) THEN ! Axisymmetric flux here
c         CALL FLUXP(F1RM,F1RN,F1RW,RO,RM,RN,RW,P,U,V,W,WROT,A3,
c     +        A3XA,A3YA,A3ZA,VOL,RK,EPS2,VIS,IMAX,JMAX,KMAX,
c     +        ISTR,JSTR,KSTR,IN,JN,KN,KSTR,1,IDM3)
c         ENDIF ! ISTRES == 0
         CALL ZEROZZ(F1R,NTOT)
         CALL ZEROZZ(F1E,NTOT)
         CALL ZEROZZ(F1RK,NTOT)
         CALL ZEROZZ(F1EPS,NTOT)
         IF(IPRESC == 1) CALL ZEROZZ(HAT1,NTOT)
         DO NS = 1,NSCAL
            CALL ZEROZZ(F1FI(1,NS), NTOT)
         ENDDO
         IF(MULPHL) THEN
         DO IPHASE = 1,NPHASES
c            CALL ZEROZZ(VAR(1:NTOT)%FRO(NS), NTOT)
c            CALL ZEROZZ(VAR(1:NTOT)%FE(NS),  NTOT)
            VAR(1:NTOT)%FRO(IPHASE) = 0.
            VAR(1:NTOT)%FE(IPHASE)  = 0.
         ENDDO
         ENDIF ! MULPHL
      END IF ! KMAX == 1

      IF(M2 == 1 .AND. (ICYCLE == IPRINT .OR.
     +     ICYCLE >= ICMAX .AND. .NOT. TIMEL .OR. 
     +     TIMEL.AND.MOD(ITIMES,MPRINT) == 0.AND.ICYCLE == 3)) THEN

         WRITE(44,1000) ITIMES,T,ISSB(7),NGL
         CALL HCHECK(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,P,RO,RM,RN,RW,
     +        RK,REPS,A3,A3XA,A3YA,A3ZA,WROT,IMAX,JMAX,KMAX,IN,JN,KN,
     +        ICYCLE,'K',ISTR,JSTR,KSTR,ITURB,C,TEMP,GAMMA,XCO,YCO,ZCO,
     +        XC,YC,ZC,CH,VIS,PRO,VAR,PR,IPRESC,FRSPRE,FRSDEN,
     +        ISTATE,ISSB(3),BLKS(NGL)%SOLUTION_TYPE,VOL,PDIFF)
         WRITE(44,*)
      ENDIF

 1000 FORMAT(/'  MASS, ENERGY AND ENTHALPY BALANCES IN TIME STEP ',I6,
     +     ' TIME ',E13.5,' IN BLOCK ',2I5)

      CALL SWEEPK(DRO,DM,DN,DW,DE,DRK,DEPS,F1R,F1RM,F1RN,F1RW,F1E,F1RK,
     2 F1EPS,VOL,VAR,TRM,IMAX,JMAX,KMAX,ISTRID*JSTRID,IN,JN,KN,DT,0,
     3 MULPHL,TRANSL,BLKS(NGL)%SOLUTION_TYPE,PRC)

C ... Save the mass flows for the pressure correction stage (mersu)

      IF(IPRESC == 1) THEN
         PRC(1:NTOT)%F3R = F1R(1:NTOT)
      ENDIF

      IF(MULPHL) THEN
      DO IPHASE = 1,NPHASES
         DO III = 1,NTOT
         VAR(III)%F3R(IPHASE) = VAR(III)%FRO(IPHASE)
         VAR(III)%F3A(IPHASE) = VAR(III)%FA(IPHASE)
         VAR(III)%F3X(IPHASE) = VAR(III)%FX(IPHASE)
         VAR(III)%F3U(IPHASE) = VAR(III)%FU(IPHASE)

         ENDDO
      ENDDO
      ENDIF

      IF(FRESUL .AND. M2 == 1 .AND. IGRID >= 5) THEN ! k-direction!
        CALL SWEEPS(DSUR,F1H,VOL,IMAX,JMAX,KMAX,ISTRID*JSTRID,
     +  IN,JN,KN,DT,1,MAXFS,0)
        PRC(1:NTOT)%F3R = F1R(1:NTOT)
      ENDIF

C ... NEW SWEEP FOR SCALARS PPR 11.2.

      IF (NSCAL >  0) THEN
        CALL SWEEPS(DFI,F1FI,VOL,IMAX,JMAX,KMAX,ISTRID*JSTRID,
     +  IN,JN,KN,DT,NSCAL,MAXSB,0)
      ENDIF

      IF(ICYCLE == IPRINT) THEN

         WRITE(3,'(/,A)') 'Mass flows applied for momentum and energy'
         CALL PRINYS(3,F3RC,F1R,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         WRITE(3,'(/,A)') 'Mass flows applied for pressure correction'
         CALL PRINYS(3,F3RC,HAT1, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DROC,DRO,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         IF(MULPHL) THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%ALFA(IPHASE)
         CALL PRINYS(3,CHAR_VAR(1,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRO(IPHASE)
         CALL PRINYS(3,CHAR_VAR(7,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
            ZZZ(1:NTOT) = VAR(1:NTOT)%DX(IPHASE)
            CALL PRINYS(3,CHAR_VAR(13,ICHARP),ZZZ(1),
     +      IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDDO
         ENDIF

         IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI') THEN
         CALL PRINYS(3,F3MC,F1RM,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,DM,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         CALL PRINYS(3,F3MC,F1RM,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,DM,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRM(IPHASE)
         CALL PRINYS(3,CHAR_VAR(23,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DM(IPHASE)
         CALL PRINYS(3,CHAR_VAR(30,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,    DM,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         ENDDO
         ENDIF
         IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI') THEN
         CALL PRINYS(3,F3NC,F1RN,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,DN,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRN(IPHASE)
         CALL PRINYS(3,CHAR_VAR(26,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DN(IPHASE)
         CALL PRINYS(3,CHAR_VAR(31,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,    DN,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDDO
         ENDIF

         IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI') THEN
         CALL PRINYS(3,F3WC,F1RW,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,DW,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRW(IPHASE)
         CALL PRINYS(3,CHAR_VAR(29,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DW(IPHASE)
         CALL PRINYS(3,CHAR_VAR(32,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,    DW,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDDO
         ENDIF

         CALL PRINYS(3,F3EC,F1E,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DEC,DE,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(MULPHL) THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FE(IPHASE)
         CALL PRINYS(3,CHAR_VAR(10,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
            ZZZ(1:NTOT) = VAR(1:NTOT)%DE(IPHASE)
            CALL PRINYS(3,CHAR_VAR(12,ICHARP),ZZZ(1),
     +      IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDDO
         ENDIF
         CALL PRINYS(3,WROTC,WROT, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(FRESUL .AND. M == 1) THEN
         CALL PRINYS(3,WAVEC,WAVE, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(IFSBC == 4) THEN
         CALL PRINYS(3,F3HC,F1H,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DSURFC,DSUR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
         ENDIF

         CALL PRINYS(3,F3KC,F1RK,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F3EPC,F1EPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         IF(ITURB >= 3) THEN
         WRITE(3,*) 'RESIKEn arvot k-suunnan'
         CALL PRINYS(3,RKC,     RK,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,REPSC, REPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,ROC, RO,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
         CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
C         CALL PRINYS(3,PTURC,PTUR, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,   DC,DDEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3, SRKC, SRK, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SEPSC,SEPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DROC, DRO,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)		

         IF(TRANSL) THEN
	   WRITE(3,*) '  '
	   WRITE(3,*) ' G and RET fluxes in k-direction'
           ZZZ(1:NTOT) = TRM(1:NTOT)%FG
           CALL PRINYS(3,F3G,ZZZ(1),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ZZZ(1:NTOT) = TRM(1:NTOT)%FRET
           CALL PRINYS(3,F3RET,ZZZ(1),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF		

C ... FOR SCALAR EQ PPR 14.2
         DO 8180 NS = 1,NSCAL
            CALL PRINYS(3,F3FIC(NS),F1FI(1,NS),IT,IL,0,IK,
     +      IMAX,JMAX,KMAX,NGL,M)
            CALL PRINYS(3,DFIC(NS), DFI(1,NS), IT,IL,0,IK,
     +      IMAX,JMAX,KMAX,NGL,M)
 8180    CONTINUE
         IF (ITURB >= 21) THEN
            CALL PRINYS(3,'   F1   ',SFI(1,1),IT,IL,0,IK,
     +      IMAX,JMAX,KMAX,NGL,M)
         ENDIF
      ENDIF ! ICYCLE == IPRINT
 1    CONTINUE

C******************************************************************
C                                                                 *
C ... FOR THE CALCULATION OF FLUXES IN XI (=I)  SORT              *
C ... GEOMETRY AND VARIABLES FROM IJK TO JKI                      *
C                                                                 *
C******************************************************************
          
      CALL FLXCYC(NGL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,CP,
     + A1,D1,A1XA,A1YA,A1ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,
     + W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),SIJ(1,3),SIJ(1,4),
     + SIJ(1,5),SIJ(1,6),GRADT(1,1),GRADT(1,2),GRADT(1,3),GRADK(1,1), 
     + GRADK(1,2),GRADK(1,3),GREPS(1,1),GREPS(1,2),GREPS(1,3),RGAS,
     + GAMMA,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,OHMI,ICP,JMAX,KMAX,IMAX,
     + JN,KN,IN,JSTRID,KSTRID,ISTRID,ICYCLE,ICMAX,INTERI,INTETI,
     + INTEAI,IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,S11,MAXSS,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,RMLOSS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,IBOT,ITOP,LAMIN1,IFLUX,
     + UROT,IDM1,UBI,VBI,WBI,UTI,VTI,WTI,
     + RK,REPS,DDEPS,DRK,DEPS,SRK,SEPS,
     + PTUR,F1RK,F1EPS,FUN1,BIJ,MAXEB,ISTRES,TURLIM,RKLIM,
     + EPSLIM,PSIGK1,PSIGE1,PSIGK,PSIGE,C1,C2,CMU,CTA,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + ITURB,IDIS,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,KBEGIN,
     + KSCAL,HAT1,HAT2,HAT3,HAT4,RLOLIM,PROD,PI,DIF,DIS,VVIS,FWLL,
     + JRDIF,JRDIS,JRPRE,SOURL,IMAX,JMAX,KMAX,IN,JN,KN,KMAX,
     + JSTR,KSTR,ISTR,1,FULLNS,ZZZ,MAXW,MAX11,
     + XCO,YCO,ZCO,QMFIN,QVFIN,QMEIN,QMFOUT,QVFOUT,QMEOUT,
     + QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMYIN,
     + CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,BOUNA1,
     + BOUNA2,IBF,PRO,VAR,PRC,BLKS,MULPHL,JSTATE,IPRESC,TURCOR,XXTRAL,
     + FRESUL,F1H,WAVE,IFSBC,IWAVEB,FREDIF,BUX,BUY,BUZ,VMXB,VMYB,VMZB,
     + FRSSIE,RNUT,STRAIN,PSEUCO,RJK2,RJK4,SCALEJ,RKSI,INCHIML,
     + ENTROPY_FIX,GRAVIL,QGFIN,QGEIN,QGFOUT,QGEOUT,
     + TRANSL,TRM,BOUNG,BOUNRET,DISTW,PLE2,IDIMSG,JDIMSG,SURFA,SURFT,
     + SURF2X,SURF2Y,SURF2Z,SURFMX,SURFMY,SURFMZ,IUPPTL,
     + BOUNU1,BOUNU2,BOUNV1,BOUNV2,BOUNW1,BOUNW2,SURFPX,SURFPY,SURFPZ,
     + QLFIN,QLEIN,QLFOUT,QLEOUT,UTAUM,EPSOLD)

      IF(M2 == 1 .AND. (ICYCLE == IPRINT .OR.
     +     ICYCLE >= ICMAX .AND. .NOT. TIMEL .OR. 
     +     TIMEL.AND.MOD(ITIMES,MPRINT) == 0.AND.ICYCLE == 3)) THEN

         WRITE(44,1000) ITIMES,T,ISSB(7),NGL
         CALL HCHECK(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,P,RO,RM,RN,RW,
     +        RK,REPS,A1,A1XA,A1YA,A1ZA,UROT,JMAX,KMAX,IMAX,JN,KN,IN,
     +        ICYCLE,'I',JSTR,KSTR,ISTR,ITURB,C,TEMP,GAMMA,XCO,YCO,ZCO,
     +        XC,YC,ZC,CH,VIS,PRO,VAR,PR,IPRESC,FRSPRE,FRSDEN,
     +        ISTATE,ISSB(1),BLKS(NGL)%SOLUTION_TYPE,VOL,PDIFF)
         WRITE(44,*)
      ENDIF

      CALL SWEEPK(DRO,DM,DN,DW,DE,DRK,DEPS,F1R,F1RM,F1RN,F1RW,F1E,F1RK,
     2 F1EPS,VOL,VAR,TRM,IMAX,JMAX,KMAX,1,IN,JN,KN,DT,0,MULPHL,TRANSL,
     3 BLKS(NGL)%SOLUTION_TYPE,PRC)

C ... Save the mass flows for the pressure correction stage (mersu)

      IF(IPRESC == 1) THEN
         PRC(1:NTOT)%F1R = F1R(1:NTOT)
      ENDIF

      IF(FRESUL .AND. M2 == 1 .AND. IGRID >= 5) THEN ! i-direction!
        CALL SWEEPS(DSUR,F1H,VOL,IMAX,JMAX,KMAX,1,
     +  IN,JN,KN,DT,1,MAXFS,0)
        PRC(1:NTOT)%F1R = F1R(1:NTOT)
      ENDIF

      IF(MULPHL) THEN
      DO IPHASE = 1,NPHASES
         DO III = 1,NTOT
         VAR(III)%F1R(IPHASE) = VAR(III)%FRO(IPHASE)
         VAR(III)%F1A(IPHASE) = VAR(III)%FA(IPHASE)
         VAR(III)%F1X(IPHASE) = VAR(III)%FX(IPHASE)
         VAR(III)%F1U(IPHASE) = VAR(III)%FU(IPHASE)

         ENDDO
      ENDDO
      ENDIF


C ... SWEEP FOR SCALARS PPR 11.2.
      IF (NSCAL > 0) THEN
          CALL SWEEPS(DFI,F1FI,VOL,IMAX,JMAX,KMAX,1,IN,JN,KN,DT,
     2    NSCAL,MAXSB,0)
      ENDIF

      IF(ICYCLE == IPRINT) THEN

         WRITE(3,'(/,A)') 'Mass flows applied for momentum and energy'
         CALL PRINYS(3,F1RC, F1R,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         WRITE(3,'(/,A)') 'Mass flows applied for pressure correction'
         CALL PRINYS(3,F1RC,HAT1, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DROC,DRO,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         IF(MULPHL) THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%ALFA(IPHASE)
         CALL PRINYS(3,CHAR_VAR(1,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRO(IPHASE)
         CALL PRINYS(3,CHAR_VAR(5,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DX(IPHASE)
         CALL PRINYS(3,CHAR_VAR(13,ICHARP),ZZZ(1),
     +   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDDO
         ENDIF

         IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI') THEN
         CALL PRINYS(3,F1MC, F1RM, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,DM,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         CALL PRINYS(3,F1MC, F1RM, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,DM,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRM(IPHASE)
         CALL PRINYS(3,CHAR_VAR(21,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DM(IPHASE)
         CALL PRINYS(3,CHAR_VAR(30,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,    DM,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         ENDDO
         ENDIF
         IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI') THEN
         CALL PRINYS(3,F1NC, F1RN, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,DN,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRN(IPHASE)
         CALL PRINYS(3,CHAR_VAR(24,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DN(IPHASE)
         CALL PRINYS(3,CHAR_VAR(31,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,    DN,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         ENDDO
         ENDIF
         IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI') THEN
         CALL PRINYS(3,F1WC, F1RW, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,DW,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRW(IPHASE)
         CALL PRINYS(3,CHAR_VAR(27,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DW(IPHASE)
         CALL PRINYS(3,CHAR_VAR(32,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,    DW,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         ENDDO
         ENDIF

         CALL PRINYS(3,F1EC, F1E,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DEC,DE,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(MULPHL) THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FE(IPHASE)
         CALL PRINYS(3,CHAR_VAR(8,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DE(IPHASE)
         CALL PRINYS(3,CHAR_VAR(12,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         ENDDO
         ENDIF
         CALL PRINYS(3,UROTC,UROT, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         IF(FRESUL .AND. M == 1) THEN
         CALL PRINYS(3,WAVEC,WAVE, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(IFSBC == 4) THEN
         CALL PRINYS(3,F1HC,F1H,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DSURFC,DSUR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
         ENDIF

         CALL PRINYS(3,F1KC, F1RK, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F1EPC,F1EPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(ITURB >= 3) THEN
         WRITE(3,*) 'RESIKEn arvot i-suunnan'
         CALL PRINYS(3,RKC,     RK,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,REPSC, REPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,ROC, RO,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF	
         CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
C        CALL PRINYS(3,PTURC,PTUR, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,   DC,DDEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SRKC, SRK,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SEPSC,SEPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DROC, DRO,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         IF(TRANSL) THEN
	   WRITE(3,*) '  '
	   WRITE(3,*) ' G and RET fluxes in i-direction'
           ZZZ(1:NTOT) = TRM(1:NTOT)%FG
           CALL PRINYS(3,F1G,ZZZ(1),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ZZZ(1:NTOT) = TRM(1:NTOT)%FRET
           CALL PRINYS(3,F1RET,ZZZ(1),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
	
         DO 8181 NS = 1,NSCAL
          CALL PRINYS(3,F1FIC(NS),F1FI(1,NS),IT,IL,0,IK,
     +    IMAX,JMAX,KMAX,NGL,M)
          CALL PRINYS(3,DFIC(NS), DFI(1,NS), IT,IL,0,IK,
     +    IMAX,JMAX,KMAX,NGL,M)
 8181    CONTINUE
         IF (NSCAL >= 1) THEN
            CALL PRINYS(3,'   F1   ',SFI(1,1),IT,IL,0,IK,
     +      IMAX,JMAX,KMAX,NGL,M)
      ENDIF
      ENDIF
C******************************************************************
C                                                                 *
C     CALCULATE FLUXES IN ETA (=J) -DIRECTION                     *
C                                                                 *
C******************************************************************

      CALL FLXCYC(NGL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,CP,
     + A2,D2,A2XA,A2YA,A2ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,
     + W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),SIJ(1,3),SIJ(1,4),
     + SIJ(1,5),SIJ(1,6),GRADT(1,1),GRADT(1,2),GRADT(1,3),GRADK(1,1), 
     + GRADK(1,2),GRADK(1,3),GREPS(1,1),GREPS(1,2),GREPS(1,3),RGAS,
     + GAMMA,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,OHMI,JCP,KMAX,IMAX,JMAX,
     + KN,IN,JN,KSTRID,ISTRID,JSTRID,ICYCLE,ICMAX,INTERJ,INTETJ,
     + INTEAJ,IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,S11,MAXSS,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,RMLOSS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,JBOT,JTOP,LAMIN2,IFLUX,
     + VROT,IDM2,UBJ,VBJ,WBJ,UTJ,VTJ,WTJ,
     + RK,REPS,DDEPS,DRK,DEPS,SRK,SEPS,
     + PTUR,F1RK,F1EPS,FUN1,BIJ,MAXEB,ISTRES,TURLIM,RKLIM,
     + EPSLIM,PSIGK1,PSIGE1,PSIGK,PSIGE,C1,C2,CMU,CTA,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + ITURB,IDIS,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,KBEGIN,
     + KSCAL,HAT1,HAT2,HAT3,HAT4,RLOLIM,PROD,PI,DIF,DIS,VVIS,FWLL,
     + JRDIF,JRDIS,JRPRE,SOURL,IMAX,JMAX,KMAX,IN,JN,KN,KMAX,
     + KSTR,ISTR,JSTR,2,FULLNS,ZZZ,MAXW,MAX11,
     + XCO,YCO,ZCO,QMFIN,QVFIN,QMEIN,QMFOUT,QVFOUT,QMEOUT,
     + QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMYIN,
     + CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,BOUNA1,
     + BOUNA2,IBF,PRO,VAR,PRC,BLKS,MULPHL,JSTATE,IPRESC,TURCOR,XXTRAL,
     + FRESUL,F1H,WAVE,IFSBC,IWAVEB,FREDIF,BUX,BUY,BUZ,VMXB,VMYB,VMZB,
     + FRSSIE,RNUT,STRAIN,PSEUCO,RJK2,RJK4,SCALEJ,RKSI,INCHIML,
     + ENTROPY_FIX,GRAVIL,QGFIN,QGEIN,QGFOUT,QGEOUT,
     + TRANSL,TRM,BOUNG,BOUNRET,DISTW,PLE2,IDIMSG,JDIMSG,SURFA,SURFT,
     + SURF2X,SURF2Y,SURF2Z,SURFMX,SURFMY,SURFMZ,IUPPTL,
     + BOUNU1,BOUNU2,BOUNV1,BOUNV2,BOUNW1,BOUNW2,SURFPX,SURFPY,SURFPZ,
     + QLFIN,QLEIN,QLFOUT,QLEOUT,UTAUM,EPSOLD)

      IF(M2 == 1 .AND. (ICYCLE == IPRINT .OR.
     +     ICYCLE >= ICMAX .AND. .NOT. TIMEL .OR. 
     +     TIMEL.AND.MOD(ITIMES,MPRINT) == 0.AND.ICYCLE == 3)) THEN

         WRITE(44,1000) ITIMES,T,ISSB(7),NGL
         CALL HCHECK(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,P,RO,RM,RN,RW,
     +        RK,REPS,A2,A2XA,A2YA,A2ZA,VROT,KMAX,IMAX,JMAX,KN,IN,JN,
     +        ICYCLE,'J',KSTR,ISTR,JSTR,ITURB,C,TEMP,GAMMA,XCO,YCO,ZCO,
     +        XC,YC,ZC,CH,VIS,PRO,VAR,PR,IPRESC,FRSPRE,FRSDEN,
     +        ISTATE,ISSB(2),BLKS(NGL)%SOLUTION_TYPE,VOL,PDIFF)
         WRITE(44,*)
      ENDIF

      IDO   = 1
      CALL SWEEPK(DRO,DM,DN,DW,DE,DRK,DEPS,F1R,F1RM,F1RN,F1RW,F1E,F1RK,
     2 F1EPS,VOL,VAR,TRM,IMAX,JMAX,KMAX,ISTRID,IN,JN,KN,DT,IDO,MULPHL,
     3 TRANSL,BLKS(NGL)%SOLUTION_TYPE,PRC)

C ... Save the mass flows for the pressure correction stage (mersu)

      IF(IPRESC == 1) THEN
         PRC(1:NTOT)%F2R = F1R(1:NTOT)
      ENDIF

      IF(FRESUL .AND. M2 == 1 .AND. IGRID >= 5) THEN ! j-direction!
        CALL SWEEPS(DSUR,F1H,VOL,IMAX,JMAX,KMAX,ISTRID,
     +  IN,JN,KN,DT,1,MAXFS,0)
        PRC(1:NTOT)%F2R = F1R(1:NTOT)
      ENDIF

      IF(MULPHL) THEN
      DO IPHASE = 1,NPHASES
         DO III = 1,NTOT
         VAR(III)%F2R(IPHASE) = VAR(III)%FRO(IPHASE)
         VAR(III)%F2A(IPHASE) = VAR(III)%FA(IPHASE)
         VAR(III)%F2X(IPHASE) = VAR(III)%FX(IPHASE)
         VAR(III)%F2U(IPHASE) = VAR(III)%FU(IPHASE)

c         IF(VAR(III)%ALFA(IPHASE)  == 0.) THEN ! Don't substract from zero
c            VAR(III)%DX(IPHASE) = MAX(VAR(III)%DX(IPHASE), 0.)
c            VAR(III)%DE(IPHASE) = MAX(VAR(III)%DE(IPHASE), 0.)
c         ENDIF
          IF(VAR(III)%ALFA(2)  == 0.) THEN ! Don't substract from zero
             VAR(III)%DX(2) = MAX(VAR(III)%DX(2), 0.)
             VAR(III)%DE(2) = MAX(VAR(III)%DE(2), 0.)
          ENDIF
         ENDDO
      ENDDO
      ENDIF ! MULPHL
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

C ... SWEEP FOR SCALARS PPR 11.2.
      IF (NSCAL > 0) THEN
        CALL SWEEPS(DFI,F1FI,VOL,IMAX,JMAX,KMAX,ISTRID,IN,JN,KN,DT,
     2  NSCAL,MAXSB,IDO)
      ENDIF

      IF(ICYCLE == IPRINT) THEN
         IF(M == 1) WRITE(44,*)
	   WRITE(3,*) '  '
	   WRITE(3,*) ' After j-direction'
         WRITE(3,'(/,A)') 'Mass flows applied for momentum and energy'   
         CALL PRINYS(3,F2RC, F1R,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         WRITE(3,'(/,A)') 'Mass flows applied for pressure correction'
         CALL PRINYS(3,F2RC,HAT1, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         WRITE(3,'(/,A)')'RESIDUn DRO (based on previous mass-fluxes)'
         CALL PRINYS(3,DROC,DRO,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         F1R(1:NTOT) = DRO(1:NTOT)*VOL(1:NTOT)
         WRITE(3,'(/,A)')'DRO*VOL (based on previous mass-fluxes)'
         CALL PRINYS(3,DROC,F1R,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         IF(MULPHL) THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%ALFA(IPHASE)
         CALL PRINYS(3,CHAR_VAR(1,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRO(IPHASE)
         CALL PRINYS(3,CHAR_VAR(6,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
            ZZZ(1:NTOT) = VAR(1:NTOT)%DX(IPHASE)
            CALL PRINYS(3,CHAR_VAR(13,ICHARP),ZZZ(1),
     +      IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDDO
         ENDIF

         IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI') THEN
         CALL PRINYS(3,F2MC,F1RM,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,    DM, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         CALL PRINYS(3,F2MC,F1RM,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,    DM, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRM(IPHASE)
         CALL PRINYS(3,CHAR_VAR(22,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DM(IPHASE)
         CALL PRINYS(3,CHAR_VAR(30,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,    DM,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDDO
         ENDIF

         IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI') THEN
         CALL PRINYS(3,F2NC,F1RN,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,DN,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRN(IPHASE)
         CALL PRINYS(3,CHAR_VAR(25,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DN(IPHASE)
         CALL PRINYS(3,CHAR_VAR(31,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,    DN,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         ENDDO
         ENDIF
         IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI') THEN
         CALL PRINYS(3,F2WC,F1RW,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,DW,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI') THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FRW(IPHASE)
         CALL PRINYS(3,CHAR_VAR(28,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DW(IPHASE)
         CALL PRINYS(3,CHAR_VAR(32,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,    DW,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         ENDDO
         ENDIF

         CALL PRINYS(3,F2EC, F1E,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DEC,DE,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(MULPHL) THEN
         DO IPHASE = 1,BLKS(NGL)%NPHASE
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = VAR(1:NTOT)%FE(IPHASE)
         CALL PRINYS(3,CHAR_VAR(9,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
            ZZZ(1:NTOT) = VAR(1:NTOT)%DE(IPHASE)
            CALL PRINYS(3,CHAR_VAR(12,ICHARP),ZZZ(1),
     +      IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDDO
         ENDIF
         CALL PRINYS(3,VROTC,VROT, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(FRESUL .AND. M == 1) THEN
         CALL PRINYS(3,WAVEC,WAVE, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(IFSBC == 4) THEN
         CALL PRINYS(3,F2HC,F1H,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DSURFC,DSUR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
         ENDIF

         CALL PRINYS(3,F2KC,F1RK,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F2EPC,F1EPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         IF(ITURB >= 3) THEN
         WRITE(3,*) 'RESIKEn arvot j-suunnan'
         CALL PRINYS(3,RKC,     RK,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,REPSC, REPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
         CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RKC,    RK, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,REPSC,REPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
C         CALL PRINYS(3,PTURC,PTUR, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,   DC,DDEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3, SRKC, SRK, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SEPSC,SEPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
		
         IF(TRANSL) THEN
	   WRITE(3,*) '  '
	   WRITE(3,*) ' G and RET fluxes in j-direction'
           ZZZ(1:NTOT) = TRM(1:NTOT)%FG
           CALL PRINYS(3,F2G,ZZZ(1),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ZZZ(1:NTOT) = TRM(1:NTOT)%FRET
           CALL PRINYS(3,F2RET,ZZZ(1),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF		

C ... FOR SCALAR EQ PPR 14.2
         DO 8184 NS = 1,NSCAL
          CALL PRINYS(3,F2FIC(NS),F1FI(1,NS),IT,IL,0,IK,
     +    IMAX,JMAX,KMAX,NGL,M)
          CALL PRINYS(3,DFIC(NS), DFI(1,NS), IT,IL,0,IK,
     +    IMAX,JMAX,KMAX,NGL,M)
 8184    CONTINUE
         IF (ITURB >= 21) THEN
            CALL PRINYS(3,'   F1   ',SFI(1,1),IT,IL,0,IK,
     +           IMAX,JMAX,KMAX,NGL,M)
         ENDIF
         WRITE(3,*)
         WRITE(3,*)' RESULTS BEFORE THE SOURCE TERM (RESIKE)'
         CALL PRINYS(3,VOLC, VOL, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DROC, DRO, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DKC,  DRK, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DEPSC,DEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DEC,  DE,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

      ENDIF ! ICYCLE == IPRINT
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      IF(TWO_FLUIDL) THEN

         DO IPHASE = 1,NPHASE

         IF(ICYCLE == IPRINT) THEN
         WRITE(3,*)'                         '
         WRITE(3,*)' RESULTS BEFORE ADDING PRESSURE GRADIENT'
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
          ZZZ(1:NTOT) = VAR(1:NTOT)%DM(IPHASE)
          CALL PRINYS(3,CHAR_VAR(30,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
          ZZZ(1:NTOT) = VAR(1:NTOT)%DN(IPHASE)
          CALL PRINYS(3,CHAR_VAR(31,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
          ZZZ(1:NTOT) = VAR(1:NTOT)%DW(IPHASE)
          CALL PRINYS(3,CHAR_VAR(32,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF

C ... Without the pressure gradient (You may need these)

         VAR(1:NTOT)%DU(IPHASE)  = VAR(1:NTOT)%DM(IPHASE)
         VAR(1:NTOT)%DV(IPHASE)  = VAR(1:NTOT)%DN(IPHASE)
         VAR(1:NTOT)%DWW(IPHASE) = VAR(1:NTOT)%DW(IPHASE)

C ... If these are added in IMPSMF, remember to modify RESL2 as in r729

c         VAR(1:NTOT)%DM(IPHASE)  = VAR(1:NTOT)%DM(IPHASE)  - 
c     +   VAR(1:NTOT)%ALFA(IPHASE)*PRC(1:NTOT)%DPDX
c         VAR(1:NTOT)%DN(IPHASE)  = VAR(1:NTOT)%DN(IPHASE)  - 
c     +   VAR(1:NTOT)%ALFA(IPHASE)*PRC(1:NTOT)%DPDY
c         VAR(1:NTOT)%DW(IPHASE)  = VAR(1:NTOT)%DW(IPHASE)  - 
c     +   VAR(1:NTOT)%ALFA(IPHASE)*PRC(1:NTOT)%DPDZ

      DO K = 1,KMAX
      III  = (K+KN-1)*KSTR
         DO J = 1,JMAX
         II9  = III + (J+JN-1)*ISTRID + IN
           DO I = 1,IMAX
           L = I + II9
         VAR(L)%DM(IPHASE)  = VAR(L)%DM(IPHASE)  - 
     +   VAR(L)%ALFA(IPHASE)*PRC(L)%DPDX
         VAR(L)%DN(IPHASE)  = VAR(L)%DN(IPHASE)  - 
     +   VAR(L)%ALFA(IPHASE)*PRC(L)%DPDY
         VAR(L)%DW(IPHASE)  = VAR(L)%DW(IPHASE)  - 
     +   VAR(L)%ALFA(IPHASE)*PRC(L)%DPDZ
           ENDDO
         ENDDO
      ENDDO


         IF(ICYCLE == IPRINT) THEN
         WRITE(3,*)'                         '
         WRITE(3,*)' RESULTS WITH PRESSURE GRADIENT'
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
          ZZZ(1:NTOT) = VAR(1:NTOT)%DM(IPHASE)
          CALL PRINYS(3,CHAR_VAR(30,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
          ZZZ(1:NTOT) = VAR(1:NTOT)%DN(IPHASE)
          CALL PRINYS(3,CHAR_VAR(31,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
          ZZZ(1:NTOT) = VAR(1:NTOT)%DW(IPHASE)
          CALL PRINYS(3,CHAR_VAR(32,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
         ENDDO

      ELSE ! For CAVIT and single phase

         IF(ICYCLE == IPRINT) THEN
         WRITE(3,*)'                         '
         WRITE(3,*)' RESULTS WITH PRESSURE GRADIENT'
         CALL PRINYS(3,DMC,DM,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,DN,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,DW,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
      ENDIF ! TWO_FLUIDL

         IF(MULPHL) THEN
         IF(ICYCLE == IPRINT) THEN
            DO IPHASE = 1,BLKS(NGL)%NPHASE
            ICHARP = BLKS(NGL)%ICHAR(IPHASE)
            ZZZ(1:NTOT) = VAR(1:NTOT)%DX(IPHASE)
            CALL PRINYS(3,CHAR_VAR(13,ICHARP),ZZZ(1),
     +      IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
            ZZZ(1:NTOT) = VAR(1:NTOT)%DE(IPHASE)
            CALL PRINYS(3,CHAR_VAR(12,ICHARP),ZZZ(1),
     +      IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDDO
         ENDIF
      ENDIF ! MULPHL

      IF(ICYCLE == IPRINT) THEN ! Odd place
         WRITE(3,*)'                         '
      WRITE(3,*) ' Before source'
             CALL PRINYS(3,DNC,    DN,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
      ENDIF

C **********************************************************************
C     CALCULATE TURBULENCE QUANTITIES
C ... HOMOGENEOUS PART OF THE SOURCE TERM, ETA AND TRUE EPSILON
C ************************************************************************

C ... VORTICITY AND STRAINS
C ... W12=W12(1,1)    W13=W12(1,2)    W23=W12(1,3)
C ... S11=SIJ(1,1)    S12=SIJ(1,2)    S13=SIJ(1,3)
C ... S22=SIJ(1,4)    S23=SIJ(1,5)    S33=SIJ(1,6)

      CALL ZEROZZ(F1E,NTOT)             ! INITIALIZATION OF TRUE EPSILON
      CALL MAKE_EPS(RO,RK,REPS,DDEPS,F1E,ITURB,NTOT)

      IF(ITURB >= 21) THEN                          ! REYNOLDS STRESS    
       CALL SOURRE(OHMI,W12,SIJ,RO,U,V,W,RK,REPS,DDEPS,C,VIS,SFI,
     +     DFI,IMAX,JMAX,KMAX,IN,JN,KN,JRDIS,JRPRE,SOURL,
     +     FI,PROD,F1FI,DIS,FWLL,MAXSB,MAX11)
      ENDIF

C ... ROTATIONAL TERM for Reynolds stresses

      IF(OMEGA /= 0. .AND. .NOT. TIMEL .AND. ITURB >= 21) THEN
       CALL ROTRE(FI(1,1),FI(1,2),FI(1,3),FI(1,4),FI(1,5),FI(1,6),
     +        PROD(1,1),PROD(1,2),PROD(1,3),PROD(1,4),PROD(1,5),
     +        PROD(1,6),VOL,IMAX,JMAX,KMAX,OMEGA,OMEX,OMEY,OMEZ,
     +        IN,JN,KN)
       CALL ROTRE(FI(1,1),FI(1,2),FI(1,3),FI(1,4),FI(1,5),FI(1,6),
     +        SFI(1,1),SFI(1,2),SFI(1,3),SFI(1,4),SFI(1,5),SFI(1,6),
     +        VOL,IMAX,JMAX,KMAX,OMEGA,OMEX,OMEY,OMEZ,IN,JN,KN)
      ENDIF

      IF(ITURB >= 24) THEN
         CALL ADDUUK(PTUR,PROD,IMAX,JMAX,KMAX,MAXSB)
      ENDIF

      IF(JRPRE == 3) THEN
C     calculate coefficients
         CALL ELLICO(HAT1,HAT2,HAT3,HAT4,F1RM,F1RN,F1RW,RK,REPS,DDEPS,
     +        VIS,RO,FI,SIJ,F1RK,A1,A2,A3,VOL,IMAX,JMAX,KMAX,IN,JN,KN,
     +        MAXSB,MAX11)
         CALL ELLBOU(HAT1,F1RM,F1FI,1,IMAX,JMAX,KMAX,IDI1,IDI2,IDI3,
     +        IN,JN,KN,NGL,NPATCH,ICON,RO,P,PDIFF,RM,RN,RW,E,VIS,VIST,
     +        EPS2,VOL,A1,A1XA,RK,REPS,DDEPS,ITURB,ISTATE,MAXSB,
     +        OHMI,U,V,W,SIJ,MAX11,FI)
         DO NNN = 1,6
            DO K = 1,KMAX
            KA   = (KN+K-1)*KSTR
            DO J = 1,JMAX
            JJ   = (JN+J-1)*JSTR + IN + KA
            DO I = 1,IMAX
               IA    = JJ + I
               F1FI(IA,NNN) = -F1FI(IA,NNN)/(1.E-8+RK(IA))
            ENDDO
            ENDDO
            ENDDO
            DO IA = 1,NTOT
               F1R(IA)      = PI(IA,NNN)/(1.E-8+RK(IA)) ! first guest
            ENDDO
         CALL LGSRSM(F1R,HAT1,HAT2,HAT3,HAT4,F1RM,F1RN,F1RW,F1FI(1,NNN),
     +        IMAX,JMAX,KMAX,IN,JN,KN,ISTRID,JSTRID,100)
         DO I = 1,NTOT
            PI(I,NNN)  = F1R(I)*(1.E-8+RK(I))
            F1FI(I,NNN)= -F1FI(I,NNN)*(1.E-8+RK(I))
            SFI(I,NNN) = SFI(I,NNN) + PI(I,NNN)
         ENDDO
         ENDDO
      ENDIF

      IF(JRPRE == 2 .OR. JRPRE == 1) THEN
         DO NNN = 1,6
         DO I = 1,NTOT
            PI(I,NNN) = F1FI(I,NNN)
         ENDDO
         ENDDO
      ENDIF

CJO   THIS CALL IS FOR ROTATION-CORRECTION. 
CJO   F1RM IS HERE USED FOR RICHARDSON NUMBER

      CALL ZEROZZ(F1RM,NTOT)
      LRICH = 0  ! No Richardson number
      IF (IROTCO >= 1)  LRICH = 2    ! HIRSC
C      IF ((KOVER >= 1.AND. KOVER <= 4) .OR. KOVER >= 6) 
      IF (KOVER == 1 .OR. KOVER == 6) 
     +     LRICH = 1            ! This is a local temporary variable

      IF(LRICH /= 0) THEN
        CALL RICHAR(OHMI,W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),
     +        SIJ(1,3),SIJ(1,4),SIJ(1,5),SIJ(1,6),LRICH,
     +        U,V,W,RK,REPS,DDEPS,A1,A2,A3,VOL,A1XA,A1YA,A1ZA,A2XA,
     +        A2YA,A2ZA,A3XA,A3YA,A3ZA,IMAX,JMAX,KMAX,IN,JN,KN,F1RM)
      ENDIF
        
      IF(IDIS == 1)THEN                ! K-EPSILON-SOURCE
      CALL SOURKE(SRK,SEPS,PTUR,VIS,OHMI,U,V,W,RO,RK,REPS,C,DDEPS,F1R,
     +        F1E,VOL,PR,PRT,IMAX,JMAX,KMAX,IN,JN,KN,LAMIN,M,C1,C2,C21,
     +        ETA0,ITURB,IEPSMA,F1RM,IROTCO,TRANSL,TRM,NGL)
      ELSEIF(IDIS == 2) THEN             ! k-omega source
      IF(TRANSL) THEN                    ! Including transition source
         ALLOCATE (DUIDXJ(NTOT,9))
         DO L = 1,NTOT
         DUIDXJ(L,1) = SIJ(L,1)              ! DUDX
         DUIDXJ(L,2) = SIJ(L,2) + W12(L,1)   ! DUDY
         DUIDXJ(L,3) = SIJ(L,3) + W12(L,2)   ! DUDZ
         DUIDXJ(L,4) = SIJ(L,2) - W12(L,1)   ! DVDX
         DUIDXJ(L,5) = SIJ(L,4)              ! DVDY
         DUIDXJ(L,6) = SIJ(L,5) + W12(L,3)   ! DVDZ
         DUIDXJ(L,7) = SIJ(L,3) - W12(L,2)   ! DWDX
         DUIDXJ(L,8) = SIJ(L,5) - W12(L,3)   ! DWDY
         DUIDXJ(L,9) = SIJ(L,6)              ! DWDZ
         ENDDO
         CALL TRANSM(TRM,IMAX,JMAX,KMAX,RO,VIS,DISTW,
     &		 RK,REPS,U,V,W,DUIDXJ,STRAIN,OHMI,VOL,
     &		 FRSVEL,NTOT,NGL)
	   DEALLOCATE (DUIDXJ)   
      ENDIF

      CALL SOURKO(SRK,SEPS,PTUR,EPS2,VIS,RO,RK,REPS,FUN1,F1RM,
     &        D1,D2,D3,NGL,IMAX,JMAX,KMAX,IN,JN,KN,KOVER,
     &        BSTAR,CKAPPA,BETA1,SIGOM1,BETA2,SIGOM2,ZETA2,CMU,
     &        TURDESL,TTS,TUR_FRS_SOURCE,TRANSL,TRM,T2,STRAIN,
     &        VELLAP,QSAS,OHMI,DISTW)
      ENDIF                              ! k-epsilon source

      IF(ITURB == 5) THEN              ! RNG-SOURCE
       CALL SOURNG(SRK,SEPS,PTUR,VIS,OHMI,U,V,W,RO,RK,REPS,DDEPS,F1R,
     + F1E,VOL,PR,PRT,IMAX,JMAX,KMAX,IN,JN,KN,LAMIN,M,C1,C2,C21,ETA0)
      ELSEIF(ITURB == 7) THEN          ! K-EPSILON WITH CROSS-DIFFUSION
       CALL SOURCD(PTUR,RK,REPS,DDEPS,EPS2,VIST,VIS,SRK,SEPS,RO,
     + A1,A2,A3,VOL,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     + C1,C2,C3,CMU,IMAX,JMAX,KMAX,IN,JN,KN,ITURB,M)
      ENDIF

      IF(ICYCLE == IPRINT) THEN
         WRITE(3,*)' THE FINAL SOURCE TERMS'
         CALL PRINYS(3,TEPSC,  F1E,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,PTURC, PTUR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SRKC,   SRK,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SEPSC, SEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,FUN1C, FUN1,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF (LRICH /= 0) THEN
            WRITE(3,*) 'RICHARDSON NUMBER'
            CALL PRINYS(3,' RI     ',F1RM,IT,IL,0,IK,IMAX,JMAX,KMAX,
     +                  NGL,M)
         ENDIF 

         IF (NSCAL >= 1) THEN ! Print scalar sources
            DO 8189 NS = 1,NSCAL
               CALL PRINYS(3,SRC(NS),SFI(1,NS),IT,IL,0,IK,
     +              IMAX,JMAX,KMAX,NGL,M)
 8189       CONTINUE
         ENDIF

         IF(ITURB  >= 21) THEN

           OPEN(23,FILE='ELLIPTIC',STATUS='UNKNOWN',FORM='FORMATTED')

           WRITE(23,*)
           WRITE(23,*) '  Before Elliptic smoothing'

           CALL PRINYS(23,'  L     ',F1RK,IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PHIXX  ',F1FI(1,1),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PHIXY  ',F1FI(1,2),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PHIYY  ',F1FI(1,4),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PHIZZ  ',F1FI(1,6),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)

           WRITE(23,*)
           WRITE(23,*) '  After Elliptic smoothing'

           CALL PRINYS(23,' PHIXX  ',PI(1,1),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PHIXY  ',PI(1,2),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PHIYY  ',PI(1,4),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PHIZZ  ',PI(1,6),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)

           CALL PRINYS(23,' FWLL   ',FWLL,IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PROXX  ',PROD(1,1),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' DISXX  ',DIS(1,1),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' DIFXX  ',DIF(1,1),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' VISXX  ',VVIS(1,1),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PROXY  ',PROD(1,2),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' DISXY  ',DIS(1,2),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' DIFXY  ',DIF(1,2),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' VISXY  ',VVIS(1,2),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PROYY  ',PROD(1,4),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' DISYY  ',DIS(1,4),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' DIFYY  ',DIF(1,4),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' VISYY  ',VVIS(1,4),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' PROZZ  ',PROD(1,6),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' DISZZ  ',DIS(1,6),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' DIFZZ  ',DIF(1,6),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CALL PRINYS(23,' VISZZ  ',VVIS(1,6),IT,IL,0,IK,
     +          IMAX,JMAX,KMAX,NGL,M)
           CLOSE(23)
        ENDIF ! ITURB >= 21
      ENDIF   ! ICYCLE == IPRINT

C *** ADD SOURCES TO RESIDUALS ****************************************

C ... Add turbulence source terms

      CALL ADDSKE(DRK,DEPS,SRK,RK,REPS,PTUR,SEPS,VOL,IMAX,JMAX,KMAX,
     + KSTRID,IN,JN,KN,DT,TRM,TRANSL)

C ... ROTATIONAL ACCELERATION TERM

      IF(OMEGA /= 0. .AND. .NOT. TIMEL) THEN
       IF(BLKS(NGL)%SOLUTION_TYPE /= 'MULTI' ) THEN
       CALL SWEEPR(DRO,DM,DN,DW,DE,RO,U,V,W,VOL,IMAX,JMAX,KMAX,
     2 OMEGA,OMEX,OMEY,OMEZ,IN,JN,KN,DT)
      ELSEIF(BLKS(NGL)%SOLUTION_TYPE == 'MULTI' ) THEN
        CALL SWEEPRMF(VAR,PRO,VOL,IMAX,JMAX,KMAX,
     2 OMEGA,OMEX,OMEY,OMEZ,IN,JN,KN,DT,BLKS(NGL)%NPHASE)
       ENDIF
      ENDIF

C *** INTERMITTENCY SOURCES *******************************************
Coli
C *** SCALAR SOURCES **************************************************

      IF(NSCAL > 0) THEN
         CALL ADDSSC(DFI,SFI,VOL,IMAX,JMAX,KMAX,KSTRID,
     +   IN,JN,KN,DT,MAXSB,NSCAL)
      ENDIF

C ... GRAVITATIONAL ACCELERATION

      IF(GRAVIL) THEN
        CALL GRAVIT(DM,DN,DW,DE,U,V,W,RO,VOL,FRSDEN,PRO,VAR,BLKS,
     2  NGL,IMAX,JMAX,KMAX,IN,JN,KN,DT)
      ENDIF

C ... TIME-DERIVATIVE

      IF(TIMEL) THEN
         CALL TIMDER(DRO,DM,DN,DW,DE,RO,RM,RN,RW,E,ROLE2,RMLE2,RNLE2,
     +   RWLE2,ELE2,ROLE3,RMLE3,RNLE3,RWLE3,ELE3,VOL,IMAX,JMAX,KMAX,
     +   IN,JN,KN,DT,NGL,PDIFF,PLE2,PLE3)
         CALL TIMDKE(DRK,DEPS,RK,REPS,RKLE2,EPSLE2,RKLE3,EPSLE3,
     +   VOL,IMAX,JMAX,KMAX,IN,JN,KN,DT)
         IF(MULPHL) THEN
            CALL TIMDMF(VAR,PRO,P,VOL,IMAX,JMAX,KMAX,IN,JN,KN,DT,
     +      BLKS(NGL)%NPHASE,NGL,TWO_FLUIDL)
         ENDIF
         IF(NSCAL > 0) THEN
            CALL TIMDSC(DFI,FI,FILE2,FILE3,VOL,IMAX,JMAX,KMAX,KSTRID,
     +      IN,JN,KN,DT,MAXSB,NSCAL)
         ENDIF
      ENDIF

C ... FORTIFIED ALGORITHM

      IF(NCHIM /= 0) THEN
      IF(LUSGS == 0) PVISC = 1.8     !  TESTED 1.5.1990
      IF(LUSGS == 1) PVISC = 1.8     !  WILL BE TESTED SOON

      CALL TIME3(A1,A2,A3,D1,D2,D3,VOL,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,
     + A3XA,A3YA,A3ZA,DTL,DT,RO,U,V,W,C,P,IMAX,JMAX,KMAX,CFL,VIS,VIST,
     + UROT,VROT,WROT,FRSDEN,FRSVEL,PR,PRT,IDM1,IDM2,IDM3,M,TIMEL,
     + PVISC,ZZZ,1,FRSPRE,CDIFF)
      CALL FORTKE(DRO,DM,DN,DW,DE,DRK,DEPS,RO,RM,RN,RW,E,RK,REPS,
     +   ROFOR,RMFOR,RNFOR,RWFOR,EFOR,PDFOR,RKFOR,REFOR,MPFOR,TRM,
     +   TRANSL,VAR,PRO,IMAX,JMAX,KMAX,IN,JN,KN,IPRESC,VOL,RKSI,DTL)
      ENDIF

C ... Free-surface algorithm

      IF(FRESUL .AND. M2 == 1 .AND. IGRID >= 5) THEN 

c         DSUR(1:NTOT) = DSUR(1:NTOT)   !/VOL(1:NTOT)!*RO(1:NTOT))
*         DSUR(1:NTOT) = DSUR(1:NTOT) + W(1:NTOT)*RO(1:NTOT)*VOL(1:NTOT)
*     +                - WAVE(1:NTOT)*DRO(1:NTOT)*VOL(1:NTOT)

         GXS = ABS(GX/SQRT(GX**2+GY**2+GZ**2))
         GYS = ABS(GY/SQRT(GX**2+GY**2+GZ**2))
         GZS = ABS(GZ/SQRT(GX**2+GY**2+GZ**2))

         DSUR(1:NTOT) = DSUR(1:NTOT) 
     +                + GXS*U(1:NTOT)*RO(1:NTOT)*VOL(1:NTOT)
     +                + GYS*V(1:NTOT)*RO(1:NTOT)*VOL(1:NTOT)
     +                + GZS*W(1:NTOT)*RO(1:NTOT)*VOL(1:NTOT)
     +                - WAVE(1:NTOT)*DRO(1:NTOT)*VOL(1:NTOT)

         CALL PATVSP(DDSUR,DSUR,DSURLE,IMAX,JMAX,KMAX,IN,JN,KN,NGL,M,
     +     NPATCH,ICON,IHF,'FRE',.TRUE.)
  
      ENDIF
      
C ... MULTI-PHASE SOURCES (Evaporation)

      IF(MULPHL .AND. BLKS(NGL)%NPHASE > 1) THEN
         CALL EVAP(PRO,VAR,BLKS,U,V,W,P,PDIFF,VIS,EPS2,
     +   IMAX,JMAX,KMAX,IN,JN,KN,DT,DTL,NGL,M,PRT,VOL)
c         CALL CORR_EVAP(PRO,VAR,BLKS,IMAX,JMAX,KMAX,IN,JN,KN,NGL,M)
      ENDIF

      IF(TWO_FLUIDL .AND. BLKS(NGL)%NPHASE > 1) THEN

      IF(BLKS(NGL)%VMASS /= 0) THEN        ! Including virtual mass
         DO IPHASE = 1,NPHASE
         DO I = 1,3 ! Direction
         SELECT CASE(I)
         CASE(1)
         ZZZ(1:NTOT) = VAR(1:NTOT)%U(IPHASE)
         CASE(2)
         ZZZ(1:NTOT) = VAR(1:NTOT)%V(IPHASE)
         CASE(3)
         ZZZ(1:NTOT) = VAR(1:NTOT)%W(IPHASE)
         END SELECT
         CALL TEMDER(ZZZ,GRADAX,GRADAY,GRADAZ,A1,A2,A3,
     +   VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     +   XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)
         CALL VMASSF(PRO,VAR,BLKS,U,V,W,GRADAX,GRADAY,GRADAZ,IMAX,JMAX,
     +   KMAX,IN,JN,KN,DT,DTL,NGL,M,VOL,I,IPHASE)
         ENDDO
         ENDDO
      ENDIF ! VMASS

         ZZZ(1:NTOT) = VAR(1:NTOT)%ALFA(2)
         CALL TEMDER(ZZZ,GRADAX,GRADAY,GRADAZ,A1,A2,A3,
     +   VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     +   XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)

         CALL LIFTF(PRO,VAR,BLKS,U,V,W,P,PDIFF,VIS,EPS2,W12(1,1),
     +   W12(1,2),W12(1,3),IMAX,JMAX,KMAX,DT,DTL,NGL,M,PRT,VOL,RO)

         CALL INTF(PRO,VAR,BLKS,U,V,W,P,PDIFF,VIS,EPS2,GRADAX,GRADAY,
     +   GRADAZ,IMAX,JMAX,KMAX,IN,JN,KN,DT,DTL,NGL,M,PRT,VOL,RO)

         DO I = 1,3
         PRO(1:NTOT)%FITOT(I) = PRO(1:NTOT)%FD(I)  + PRO(1:NTOT)%FL(I)
     +                        + PRO(1:NTOT)%FTD(I) + PRO(1:NTOT)%FVM(I)
     +                        + PRO(1:NTOT)%FW(I)
         ENDDO


         IF(ICYCLE == IPRINT) THEN

         ZZZ(1:NTOT) = PDIFF(1:NTOT) !VAR(1:NTOT)%ALFA(IPHASE)
         CALL TEMDER(ZZZ,GRADAX,GRADAY,GRADAZ,A1,A2,A3,
     +   VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     +   XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)

         DO IPHASE = 1,NPHASE

c         CALL ALFAPG(DM,DN,DW,DE,U,V,W,RO,VOL,FRSDEN,
c     +   PRO,VAR,BLKS,NGL,IMAX,JMAX,KMAX,IN,JN,KN,DT,
c     +   PRC,IPHASE,PDIFF)
c      write(1300,*) 'Temderiin vuon laskennasta, mersu'
c         CALL TEMDER(ZZZ,GRADAX,GRADAY,GRADAZ,A1,A2,A3,
c     +   VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
c     +   XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)
c         CALL ALFAP(DM,DN,DW,DE,U,V,W,RO,VOL,FRSDEN,
c     +   PRO,VAR,BLKS,NGL,IMAX,JMAX,KMAX,IN,JN,KN,DT,
c     +   GRADAX,GRADAY,GRADAZ,IPHASE,PDIFF)

c      DO I = 1,NTOT
c            CALL IJKPAI(i,IMAX,JMAX,KMAX,II,JJ,KK)
c
c        write(6000+ngl*10+kk,*) ii,jj,GRADAX(I),GRADAY(I),GRADAZ(I)
c      ENDDO
         WRITE(3,*)
         WRITE(3,*)' AFTER INTERFACIAL FRICTION'
         ICHARP = BLKS(NGL)%ICHAR(IPHASE)
         ZZZ(1:NTOT) = PRO(1:NTOT)%FITOT(1)
         CALL PRINYS(3,FTDXC,ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = PRC(1:NTOT)%DPDX
         CALL PRINYS(3,DPDXC,ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DM(IPHASE)
         CALL PRINYS(3,CHAR_VAR(30,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = PRO(1:NTOT)%FITOT(2)
         CALL PRINYS(3,FTDYC,ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = PRC(1:NTOT)%DPDY
         CALL PRINYS(3,DPDYC,ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DN(IPHASE)
         CALL PRINYS(3,CHAR_VAR(31,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = PRC(1:NTOT)%DPDZ
         CALL PRINYS(3,DPDZC,ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = VAR(1:NTOT)%DW(IPHASE)
         CALL PRINYS(3,CHAR_VAR(32,ICHARP),ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

         IF(ICYCLE == IPRINT) THEN ! Checking...
         WRITE(3,*)
         WRITE(3,*)' PRESSURE GRADIENT FOR CHECKING'
         ZZZ(1:NTOT) = GRADAX(1:NTOT)
         CALL PRINYS(7003,DPDXC,ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = GRADAY(1:NTOT)
         CALL PRINYS(7003,DPDYC,ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ZZZ(1:NTOT) = GRADAX(1:NTOT)
         CALL PRINYS(7003,DPDZC,ZZZ(1),
     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF

c         IF(ICYCLE == IPRINT) THEN ! Comparing...
c         ZZZ(1:NTOT) = PRC(1:NTOT)%DPDX
c         CALL PRINYS(8003,DPDXC,ZZZ(1),
c     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
c         ZZZ(1:NTOT) = PRC(1:NTOT)%DPDY
c         CALL PRINYS(8003,DPDYC,ZZZ(1),
c     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
c         ZZZ(1:NTOT) = PRC(1:NTOT)%DPDZ
c         CALL PRINYS(8003,DPDZC,ZZZ(1),
c     +    IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
c         ENDIF

         ENDDO
      ENDIF

      ENDIF

C *** END OF SOURCES ***************************************************

      IF(ITURB >= 24) CALL ADDUUK(DRK,DFI,IMAX,JMAX,KMAX,MAXSB)

      IF(ICYCLE == IPRINT) THEN
         IF (ITURB >= 21) THEN
             CALL TESTI(rk,REPS,DDEPS,fi,sfi,prod,dis,pi,ro,vis,
     +       imax,jmax,kmax,maxsb)
         ENDIF
             WRITE(3,*)
             WRITE(3,*)' RESULTS AFTER UPDATING THE SOURCE TERM'
         IF(MULPHL) THEN
             CALL PRINYS(3,PC,P(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             ZZZ(1:NTOT) = PRO(1:NTOT)%PSAT
             CALL PRINYS(3,PSATC,ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)

             ZZZ(1:NTOT) = P(1:NTOT) - PRO(1:NTOT)%PSAT
             WRITE(3,*)
             CALL PRINYS(3,DPSATC,ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             DDSUR(1:NTOT) =  PRO(1:NTOT)%DPSAT   
             CALL PRINYD(3,DPSATC,DDSUR(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           DO IPHASE = 1,BLKS(NGL)%NPHASE
             ICHARP = BLKS(NGL)%ICHAR(IPHASE)
             ZZZ(1:NTOT) = VAR(1:NTOT)%ALFA(IPHASE)
             CALL PRINYS(3,CHAR_VAR(1,ICHARP),ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             WRITE(3,*)
             WRITE(3,*)'Temperature difference from the saturated value'
             WRITE(3,*)
             ZZZ(1:NTOT) = PRO(1:NTOT)%TEMP(IPHASE) - PRO(1:NTOT)%TSAT
             CALL PRINYS(3,CHAR_VAR(4,ICHARP),ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             WRITE(3,*)'Demperature difference from the saturated value'
             WRITE(3,*)
             ZZZ(1:NTOT) = PRO(1:NTOT)%DTEMP(IPHASE) - PRO(1:NTOT)%TSAT
c             ZZZ(1:NTOT) = (PDIFF(1:NTOT)-PRO(1:NTOT)%DPSAT)*
c     +       PRO(1:NTOT)%DTSDP ! Varo vaihtoehtoa
             CALL PRINYS(3,CHAR_VAR(4,ICHARP),ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             WRITE(3,*)'Demperature'
             WRITE(3,*)
             ZZZ(1:NTOT) = PRO(1:NTOT)%DTEMP(IPHASE)
             CALL PRINYS(3,CHAR_VAR(4,ICHARP),ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             ZZZ(1:NTOT) = PRO(1:NTOT)%TAUF(IPHASE)
             CALL PRINYS(3,CHAR_PH(13,ICHARP),ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             ZZZ(1:NTOT) = PRO(1:NTOT)%QIF(IPHASE)
             CALL PRINYS(3,CHAR_PH(8,ICHARP),ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             ZZZ(1:NTOT) = VAR(1:NTOT)%EVAPR(IPHASE)
             CALL PRINYS(3,CHAR_VAR(3,ICHARP),ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ENDDO
         ENDIF
             CALL PRINYS(3,DROC,  DRO,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             CALL PRINYS(3,DMC,    DM,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             CALL PRINYS(3,DNC,    DN,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             CALL PRINYS(3,DWC,    DW,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             CALL PRINYS(3,DEC,    DE,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             CALL PRINYS(3,DKC,   DRK,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             CALL PRINYS(3,DEPSC,DEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             CALL PRINYS(3,VISC,   VIS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             CALL PRINYS(3,CHC,    CH,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(FRESUL .AND. M2 == 1) THEN
             CALL PRINYS(3,DSURFC,DSUR,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF

         IF(TRANSL) THEN
           ZZZ(1:NTOT) = TRM(1:NTOT)%DG
           CALL PRINYS(3,DGC,ZZZ(1),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
           ZZZ(1:NTOT) = TRM(1:NTOT)%DRET
           CALL PRINYS(3,DRETC,ZZZ(1),IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF		

         IF(MULPHL) THEN
            DO IPHASE = 1,BLKS(NGL)%NPHASE
             ICHARP = BLKS(NGL)%ICHAR(IPHASE)
             ZZZ(1:NTOT) = VAR(1:NTOT)%DX(IPHASE)
             CALL PRINYS(3,CHAR_VAR(13,ICHARP),ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             ZZZ(1:NTOT) = VAR(1:NTOT)%DE(IPHASE)
             CALL PRINYS(3,CHAR_VAR(12,ICHARP),ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             ZZZ(1:NTOT) = VAR(1:NTOT)%EQL(IPHASE)
             CALL PRINYS(3,CHAR_PH(14,ICHARP),ZZZ(1),
     +       IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
             ENDDO
         ENDIF
             DO 8186 NS = 1,NSCAL
             CALL PRINYS(3,DFIC(NS), DFI(1,NS), IT,IL,0,IK,
     +       IMAX,JMAX,KMAX,NGL,M)
 8186    CONTINUE
      ENDIF ! ICYCLE == IPRINT

c      IF(FRESUL .AND. M2 == 1) DEALLOCATE (DSUR,DDSUR,WAVE)
      DEALLOCATE (DSUR,DDSUR,WAVE,SCALEJ,T2)
  
      RETURN
      END SUBROUTINE RESIKE
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE RESIHS(NBL,M,M2,NGL,ISSB,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,
     + CH,A1,D1,A1XA,A1YA,A1ZA,A2,D2,A2XA,A2YA,A2ZA,A3,D3,A3XA,A3YA,
     + A3ZA,XC,YC,ZC,DISTW,XCO,YCO,ZCO,DTL, 
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + DT,GAMMA,RGAS,DRO,DM,DN,DW,DE,VOL,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,OHMI,DELTA,ICP,JCP,KCP,
     + IJMASK,IMAX,JMAX,KMAX,INTERI,INTERJ,INTERK,IDERI,
     + JBOT,JTOP,IDI1,IDI2,IDI3,
     + IT,IL,IK,IPRINT,ICMAX,MPRINT,ICYCLE,ITIMES,T,
     + PR,PRT,LUSGS,CFL,CX,CY,CZ,CMX,CMY,CMZ,
     + DX,DY,DZ,QX,QY,QZ,TOMEGA,OMEGA,OMEX,OMEY,OMEZ,
     + ICON,NPATCH,XMOM,YMOM,ZMOM,
     + IBOT,ITOP,KBOT,KTOP,LAMIN,IFLUX, 
     + UBI,VBI,WBI,UBJ,VBJ,WBJ,UBK,VBK,WBK,UTI,VTI,WTI,
     + UTJ,VTJ,WTJ,UTK,VTK,WTK,UROT,VROT,WROT,RCON,RK,REPS,
     + DDEPS,DRK,DEPS,SRK,SEPS,PTUR,FUN1,F1RK,F1EPS,TTS,
     + BIJ,WIR,MAXEB,ISTRES,TURLIM,RKLIM,EPSLIM,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,CHLREF,DRDH,DRDP,ISTATE,
     + ITURB,IDIS,KOVER,E0REF,T0REF,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,
     + NSCAL,KSCAL,HAT1,HAT2,HAT3,HAT4,RLOLIM,PROD,PI,DIF,DIS,VVIS,FWLL,
     + JRDIF,JRDIS,JRPRE,S11,MAXSS,STRESL,SOURL,TIMEL,GRAVIL,IEPSMA,
     + ROLE2,RMLE2,RNLE2,RWLE2,ELE2,RKLE2,EPSLE2,FILE2,XLE2,YLE2,ZLE2,
     + ROLE3,RMLE3,RNLE3,RWLE3,ELE3,RKLE3,EPSLE3,FILE3,XLE3,YLE3,ZLE3,
     + W12,SIJ,GRADT,GRADK,GREPS,MAX11,
     + NCHIM,ROFOR,RMFOR,RNFOR,RWFOR,EFOR,PDFOR,RKFOR,REFOR,RKSI,FIFOR,
     + QMFIN,QMEIN,QMFOUT,QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,
     + CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,
     + IROTCO,FULLNS,IPRESC,ZZZ,MAXW,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,IBF,
     + PRO,VAR,BLKS,MULPHL,RLDIST)

      USE TYPE_ARRAYS
      USE CHARACTERS
      USE CONSTANTS, ONLY : EPS, PII
      USE NS3CO, ONLY     : IC9, IN, JN, KN

      IMPLICIT NONE

      INTEGER :: NBL,M,M2,NGL,IMAX,JMAX,KMAX,INTERI,INTERJ,INTERK,IDERI,
     2 JBOT,JTOP,IDI1,IDI2,IDI3,IT,IL,IK,IPRINT,ICMAX,MPRINT,ICYCLE,
     3 ITIMES,LUSGS,NPATCH,IBOT,ITOP,KBOT,KTOP,LAMIN,IFLUX,MAXEB,ISTRES,
     4 ISTATE,ITURB,IDIS,KOVER,NSCAL,KSCAL,JRDIF,JRDIS,JRPRE,MAXSS,
     5 IEPSMA,MAX11,NCHIM,IROTCO,IPRESC,MAXW,IBF,ISTRID,JSTRID,KSTRID,
     6 ISTR,JSTR,KSTR,KMAXP,NTOT,IDM1,IDM2,IDM3,INTETI,INTETJ,LAMIN1,
     7 LAMIN2,LAMIN3,KBEGIN,NS,ILPO,II,IB,NT,NNN,I,J,K,KA,JJ,IA,LRICH,
     8 MAXSB,INTETK

      REAL :: DT,GAMMA,RGAS,DELTA,T,PR,PRT,CFL,OMEGA,
     2 OMEX,OMEY,OMEZ,TURLIM,RKLIM,EPSLIM,FRSDEN,FRSPRE,
     3 FRSVIS,T0,DIFPRE,CHLREF,E0REF,T0REF,QMFIN,QMEIN,QMFOUT,QMEOUT,
     4 QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMXOUT,CMYIN,CMYOUT,
     5 CMZIN,CMZOUT,C1,C2,C3,C21,CMU,CTA,PSIGK,PSIGE,AA1,ETA0,PSIGK1,
     6 PSIGE1,A1KLEB,BSTAR,CKAPPA,BETA1,SIGRK1,SIGOM1,BETA2,SIGRK2,
     7 SIGOM2,PVISC,FRSVEL

      REAL :: RO(*),RM(*),RN(*),E(*),P(*),PDIFF(*),U(*),V(*),C(*),
     2 A1(*),A1XA(*),A1YA(*),A1ZA(*),A2(*),A2XA(*),A2YA(*),A2ZA(*),
     3 A3(*),A3XA(*),A3YA(*),A3ZA(*),DISTW(*),DRO(*),DM(*),
     4 DN(*),DE(*),VOL(*),F1R(*),F1RM(*),F1RN(*),F1E(*),F1RW(*),D1(*),
     5 CH(*),TEMP(*),VIS(*),EPS2(*),VIST(*),
     6 UWALL(*),VWALL(*),WWALL(*),CPWALL(*),TWALL(*),QWALL(*),
     7 QWFRIC(*),TAUW1(*),TAUW2(*),SURFX(*),SURFY(*),SURFZ(*),
     8 TAUWX(*),TAUWY(*),TAUWZ(*),SURLE(*),DSURLE(*),WMFLUX(*),
     9 POROS(*),WHSTAG(*),WTEMP(*),RSDIRX(*),RSDIRY(*),RSDIRZ(*),
     1 RBK(*),HFLUX(*),OHMI(*),
     2 RW(*),W(*),DW(*),D2(*),D3(*),
     3 UROT(*),VROT(*),WROT(*),PTUR(*),FUN1(*),TTS(*),
     4 RK(*),REPS(*),DRK(*),DEPS(*),SRK(*),SEPS(*),F1RK(*),F1EPS(*),
     5 DRDH(*),DRDP(*),PSIGSC(*),PSIGS2(*),TOMEGA(*),
     6 CX(*),CY(*),CZ(*),CMX(*),CMY(*),CMZ(*),DX(*),DY(*),DZ(*),
     7 QX(*),QY(*),QZ(*),RCON(IC9,*),
     8 UBI(*),VBI(*),WBI(*),UBJ(*),VBJ(*),WBJ(*),UBK(*),VBK(*),WBK(*),
     9 UTI(*),VTI(*),WTI(*),UTJ(*),VTJ(*),WTJ(*),UTK(*),VTK(*),WTK(*),
     1 FI(MAXSB,MAX(1,NSCAL)),F1FI(MAXSB,MAX(1,NSCAL)),
     2 DFI(MAXSB,MAX(1,NSCAL)),SFI(MAXSB,MAX(1,NSCAL)),
     3 HAT1(*),HAT2(*),HAT3(*),HAT4(*),
     4 PROD(MAXSB,6),PI(MAXSB,6),DIF(MAXSB,6),DIS(MAXSB,6),
     5 VVIS(MAXSB,6),FWLL(*),RLOLIM(*),S11(MAXSS,6),DDEPS(*),
     6 ROLE2(*),RMLE2(*),RNLE2(*),RWLE2(*),ELE2(*),RKLE2(*),EPSLE2(*),
     7 ROLE3(*),RMLE3(*),RNLE3(*),RWLE3(*),ELE3(*),RKLE3(*),EPSLE3(*),
     8 ROFOR(*),RMFOR(*),RNFOR(*),RWFOR(*),
     9 EFOR(*),PDFOR(*),RKFOR(*),REFOR(*),RKSI(*),
     1 FILE2(MAXSB,MAX(1,NSCAL)),FILE3(MAXSB,MAX(1,NSCAL)),
     2 FIFOR(MAXSB,MAX(1,NSCAL)),
     3 W12(MAX11,3),SIJ(MAX11,6),GRADT(MAX11,3),GRADK(MAX11,3),
     4 DTL(*),GREPS(MAX11,3),ZZZ(*),BIJ(MAXEB,6),WIR(MAXEB,3),BOUNR(*),
     5 BOUNU(*),BOUNV(*),BOUNW(*),BOUNE(*),BOUNT(*),BOUNRK(*),BOUNEP(*),
     6 BOUNP(*),BOUNPD(*),BOUNFI(IBF,MAX(1,NSCAL)),BOUNBI(IBF,*),
     7 BOUNMF(*),RLDIST(*)

      INTEGER :: IHF(*), ISSB(*),  
     &           ICP(*), JCP(*), KCP(*),
     &           IJMASK(*),ICON(IC9,*)

      REAL :: XCO(*),YCO(*),ZCO(*),XLE2(*),YLE2(*),ZLE2(*),
     2 XLE3(*),YLE3(*),ZLE3(*),ZC(*),YC(*),XC(*),XCP(*),YCP(*),ZCP(*)

      REAL :: XMOM,YMOM,ZMOM

      TYPE(PROPERTIES)       :: PRO(*)
      TYPE(MPHASE_VARIABLES) :: VAR(*)
      TYPE(BLOCKS)           :: BLKS(*)

      LOGICAL :: STRESL,SOURL,TIMEL,STRE2L,GRAVIL,FULLNS,MULPHL

      REAL :: RSURF(1,6) ! Korvaa tÃ¤mÃ¤ patch-tyyppisellÃ¤ taulukolla

c      real dudxi(30000),dudyi(30000),dudzi(30000),
c     2 dvdxi(30000),dvdyi(30000),dvdzi(30000),
c     3 dwdxi(30000),dwdyi(30000),dwdzi(30000)

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      KSTRID  = KMAX + 2*KN

      ISTR    = 1
      JSTR    = ISTRID
      KSTR    = ISTRID*JSTRID
      KMAXP   = KMAX + 1

      NTOT   = ISTRID*JSTRID*KSTRID
        
C ... ADJUST CELLS WITH FRICTION TO THE GRID LEVEL USED

      IDM1    = (IDI1-1)/2**(M-1) + 1
      IDM2    = (IDI2-1)/2**(M-1) + 1
      IDM3    = MAX(1,(IDI3-1)/2**(M-1)) + 1
      IF(IDI3 == 0) IDM3 = 0

C ... ADJUST DISCRETIZATION FOR TURBULENCE VALUES

      INTETI = INTERI
      INTETJ = INTERJ
      INTETK = INTERK
      IF(INTERI > -5 .AND. INTERI < 5) INTETI = +1
      IF(INTERJ > -5 .AND. INTERJ < 5) INTETJ = +1
      IF(INTERK > -5 .AND. INTERK < 5) INTETK = +1

C ... SEPARATE COORDINATE DIRECTIONS FROM LAMIN

      IF (ITURB == 0) THEN
         LAMIN1  = 0
         LAMIN2  = 0
         LAMIN3  = 0
      ELSE
         LAMIN1  = LAMIN/100
         LAMIN2  = (LAMIN - LAMIN1*100)/10
         LAMIN3  =  LAMIN - LAMIN1*100 - LAMIN2*10
      ENDIF

      STRE2L = STRESL
      IF(ITURB >= 10 .AND. ITURB <= 19) STRE2L = .FALSE.

      KBEGIN  = NSCAL - KSCAL + 1 ! BEGINING OF SCALARS

C **********************************************************************
C                                                                      *
C ... CALCULATION OF FLUXES FOR THE SOLID STRUCTURES                   *
C                                                                      *
C **********************************************************************

C ... INITIALIZATION OF THE RESIDUALS

      CALL ZEROZZ(DRO, NTOT)
      CALL ZEROZZ(DM,  NTOT)
      CALL ZEROZZ(DN,  NTOT)
      CALL ZEROZZ(DW,  NTOT)
      CALL ZEROZZ(DE,  NTOT)
      CALL ZEROZZ(DRK, NTOT)
      CALL ZEROZZ(DEPS,NTOT)
      CALL ZEROZZ(SRK, NTOT)


      IF(M2 >= 2) THEN      ! for M2=1 DERFUN called in TURBEQ

      DO NS = 1,3
      CALL ZEROZZ(GRADT(1,NS),NTOT)
      ENDDO

      ENDIF ! M2 >= 2

      IF(ICYCLE == IPRINT) THEN
         CALL PRINYS(3,ROC,     RO,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RMC,     RM,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RNC,     RN,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RWC,     RW,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,UC,       U,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,VC,       V,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,WC,       W,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,PC,       P,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,PDIFC,PDIFF,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,TEMPC, TEMP,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,VISC,   VIS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DRDPC, DRDP,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DRDHC, DRDH,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,EPS2C, EPS2,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,VISTC, VIST,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,CHC,    CH,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         IF(ITURB >= 3) THEN
         CALL PRINYS(3,RKC,     RK,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,REPSC, REPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         ENDIF
      ENDIF

C ... REFLECT VELOCITIES SO THAT CENTRAL DIFFERENCE IS APPLIED IN 
C ... NEXT FACE FROM THE SOLID WALL AT THE FIRST GRID LEVEL

      CALL TEMDER(TEMP,GRADT(1,1),GRADT(1,2),GRADT(1,3),A1,A2,A3,
     + VOL,D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     + XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M)

C******************************************************************
C                                                                 *
C ... FLUXES IN ZETA (=K) -DIRECTION                              *
C                                                                 *
C******************************************************************

      CALL FLXSOL(NGL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,
     + A3,D3,A3XA,A3YA,A3ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,
     + W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),SIJ(1,3),SIJ(1,4),
     + SIJ(1,5),SIJ(1,6),GRADT(1,1),GRADT(1,2),GRADT(1,3),GRADK(1,1), 
     + GRADK(1,2),GRADK(1,3),GREPS(1,1),GREPS(1,2),GREPS(1,3),RGAS,
     + GAMMA,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,OHMI,KCP,IMAX,JMAX,KMAX,
     + IN,JN,KN,ISTRID,JSTRID,KSTRID,ICYCLE,ICMAX,INTERK,INTETK,
     + IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,S11,MAXSS,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,KBOT,KTOP,LAMIN3,IFLUX,
     + WROT,IDM3,UBK,VBK,WBK,UTK,VTK,WTK,
     + RK,REPS,DDEPS,DRK,DEPS,SRK,SEPS,
     + PTUR,F1RK,F1EPS,FUN1,BIJ,MAXEB,ISTRES,TURLIM,RKLIM,
     + EPSLIM,PSIGK1,PSIGE1,PSIGK,PSIGE,C1,C2,CMU,CTA,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + ITURB,IDIS,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,KBEGIN,
     + KSCAL,HAT1,HAT2,HAT3,HAT4,RLOLIM,PROD,PI,DIF,DIS,VVIS,FWLL,
     + JRDIF,JRDIS,JRPRE,SOURL,IMAX,JMAX,KMAX,IN,JN,KN,KMAXP,
     + ISTR,JSTR,KSTR,3,FULLNS,ZZZ,MAXW,MAX11,
     + XCO,YCO,ZCO,QMFIN,QMEIN,QMFOUT,
     + QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMYIN,
     + CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,IBF)
c     + dudxi,dudyi,dudzi,dvdxi,dvdyi,dvdzi,dwdxi,dwdyi,dwdzi)

      IF (KMAX  == 1) THEN       ! axisymmetric case
         CALL ZEROZZ(F1R,NTOT)
         CALL ZEROZZ(F1E,NTOT)
         CALL ZEROZZ(F1RK,NTOT)
         CALL ZEROZZ(F1EPS,NTOT)
      END IF ! KMAX == 1

      IF(M2 == 1 .AND. (ICYCLE == IPRINT .OR.
     +     ICYCLE >= ICMAX .AND. .NOT. TIMEL .OR. 
     +     TIMEL.AND.MOD(ITIMES,MPRINT) == 0.AND.ICYCLE == 3)) THEN

         WRITE(44,1000) ITIMES,T,ISSB(7),NGL
         CALL HCHECK(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,P,RO,RM,RN,RW,
     +        RK,REPS,A3,A3XA,A3YA,A3ZA,WROT,IMAX,JMAX,KMAX,IN,JN,KN,
     +        ICYCLE,'K',ISTR,JSTR,KSTR,ITURB,C,TEMP,GAMMA,XCO,YCO,ZCO,
     +        XC,YC,ZC,CH,VIS,PRO,VAR,PR,IPRESC,FRSPRE,FRSDEN,
     +        ISTATE,ISSB(3),BLKS(NGL)%SOLUTION_TYPE,VOL,PDIFF)
         WRITE(44,*)
      ENDIF
 1000 FORMAT(/'  MASS, ENERGY AND ENTHALPY BALANCES IN TIME STEP ',I6,
     +     ' TIME ',E13.5,' IN BLOCK ',2I5)

      CALL SWEEPS(DE,F1E,VOL,IMAX,JMAX,KMAX,ISTRID*JSTRID,IN,JN,KN,
     +     DT,1,NTOT,0)

      IF(ICYCLE == IPRINT) THEN
         CALL PRINYS(3,F3RC,F1R,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F3MC,F1RM,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,DM,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F3NC,F1RN,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,DN,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F3WC,F1RW,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,DW,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F3EC,F1E,   IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F3KC,F1RK,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F3EPC,F1EPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
C         CALL PRINYS(3,PTURC,PTUR, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,   DC,DDEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3, SRKC, SRK, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SEPSC,SEPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DROC, DRO,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
      ENDIF
 1    CONTINUE

C******************************************************************
C                                                                 *
C ... FOR THE CALCULATION OF FLUXES IN XI (=I)  SORT              *
C ... GEOMETRY AND VARIABLES FROM IJK TO JKI                      *
C                                                                 *
C******************************************************************
           
      CALL FLXSOL(NGL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,
     + A1,D1,A1XA,A1YA,A1ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,
     + W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),SIJ(1,3),SIJ(1,4),
     + SIJ(1,5),SIJ(1,6),GRADT(1,1),GRADT(1,2),GRADT(1,3),GRADK(1,1), 
     + GRADK(1,2),GRADK(1,3),GREPS(1,1),GREPS(1,2),GREPS(1,3),RGAS,
     + GAMMA,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,OHMI,ICP,JMAX,KMAX,IMAX,
     + JN,KN,IN,JSTRID,KSTRID,ISTRID,ICYCLE,ICMAX,INTERI,INTETI,
     + IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,S11,MAXSS,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,IBOT,ITOP,LAMIN1,IFLUX,
     + UROT,IDM1,UBI,VBI,WBI,UTI,VTI,WTI,
     + RK,REPS,DDEPS,DRK,DEPS,SRK,SEPS,
     + PTUR,F1RK,F1EPS,FUN1,BIJ,MAXEB,ISTRES,TURLIM,RKLIM,
     + EPSLIM,PSIGK1,PSIGE1,PSIGK,PSIGE,C1,C2,CMU,CTA,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + ITURB,IDIS,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,KBEGIN,
     + KSCAL,HAT1,HAT2,HAT3,HAT4,RLOLIM,PROD,PI,DIF,DIS,VVIS,FWLL,
     + JRDIF,JRDIS,JRPRE,SOURL,IMAX,JMAX,KMAX,IN,JN,KN,KMAX,
     + JSTR,KSTR,ISTR,1,FULLNS,ZZZ,MAXW,MAX11,
     + XCO,YCO,ZCO,QMFIN,QMEIN,QMFOUT,
     + QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMYIN,
     + CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,IBF)
      IF(M2 == 1 .AND. (ICYCLE == IPRINT .OR.
     +     ICYCLE >= ICMAX .AND. .NOT. TIMEL .OR. 
     +     TIMEL.AND.MOD(ITIMES,MPRINT) == 0.AND.ICYCLE == 3)) THEN

         WRITE(44,1000) ITIMES,T,ISSB(7),NGL
         CALL HCHECK(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,P,RO,RM,RN,RW,
     +        RK,REPS,A1,A1XA,A1YA,A1ZA,UROT,JMAX,KMAX,IMAX,JN,KN,IN,
     +        ICYCLE,'I',JSTR,KSTR,ISTR,ITURB,C,TEMP,GAMMA,XCO,YCO,ZCO,
     +        XC,YC,ZC,CH,VIS,PRO,VAR,PR,IPRESC,FRSPRE,FRSDEN,
     +        ISTATE,ISSB(1),BLKS(NGL)%SOLUTION_TYPE,VOL,PDIFF)
         WRITE(44,*)
      ENDIF

      CALL SWEEPS(DE,F1E,VOL,IMAX,JMAX,KMAX,1,IN,JN,KN,DT,1,NTOT,0)

      IF(ICYCLE == IPRINT) THEN
         CALL PRINYS(3,F1RC, F1R,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F1MC, F1RM, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,DM,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F1NC, F1RN, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,DN,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F1WC, F1RW, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,DW,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F1EC, F1E,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F1KC, F1RK, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F1EPC,F1EPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
C        CALL PRINYS(3,PTURC,PTUR, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,   DC,DDEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SRKC, SRK,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,SEPSC,SEPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DROC, DRO,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
      ENDIF

C******************************************************************
C                                                                 *
C     CALCULATE FLUXES IN ETA (=J) -DIRECTION                     *
C                                                                 *
C******************************************************************
    
      CALL FLXSOL(NGL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,
     + A2,D2,A2XA,A2YA,A2ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,
     + W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),SIJ(1,3),SIJ(1,4),
     + SIJ(1,5),SIJ(1,6),GRADT(1,1),GRADT(1,2),GRADT(1,3),GRADK(1,1), 
     + GRADK(1,2),GRADK(1,3),GREPS(1,1),GREPS(1,2),GREPS(1,3),RGAS,
     + GAMMA,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,OHMI,JCP,KMAX,IMAX,JMAX,
     + KN,IN,JN,KSTRID,ISTRID,JSTRID,ICYCLE,ICMAX,INTERJ,INTETJ,
     + IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,S11,MAXSS,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,JBOT,JTOP,LAMIN2,IFLUX,
     + VROT,IDM2,UBJ,VBJ,WBJ,UTJ,VTJ,WTJ,
     + RK,REPS,DDEPS,DRK,DEPS,SRK,SEPS,
     + PTUR,F1RK,F1EPS,FUN1,BIJ,MAXEB,ISTRES,TURLIM,RKLIM,
     + EPSLIM,PSIGK1,PSIGE1,PSIGK,PSIGE,C1,C2,CMU,CTA,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + ITURB,IDIS,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,KBEGIN,
     + KSCAL,HAT1,HAT2,HAT3,HAT4,RLOLIM,PROD,PI,DIF,DIS,VVIS,FWLL,
     + JRDIF,JRDIS,JRPRE,SOURL,IMAX,JMAX,KMAX,IN,JN,KN,KMAX,
     + KSTR,ISTR,JSTR,2,FULLNS,ZZZ,MAXW,MAX11,
     + XCO,YCO,ZCO,QMFIN,QMEIN,QMFOUT,
     + QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMYIN,
     + CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,IBF)

      IF(M2 == 1 .AND. (ICYCLE == IPRINT .OR.
     +     ICYCLE >= ICMAX .AND. .NOT. TIMEL .OR. 
     +     TIMEL.AND.MOD(ITIMES,MPRINT) == 0.AND.ICYCLE == 3)) THEN

         WRITE(44,1000) ITIMES,T,ISSB(7),NGL
         CALL HCHECK(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,P,RO,RM,RN,RW,
     +        RK,REPS,A2,A2XA,A2YA,A2ZA,VROT,KMAX,IMAX,JMAX,KN,IN,JN,
     +        ICYCLE,'J',KSTR,ISTR,JSTR,ITURB,C,TEMP,GAMMA,XCO,YCO,ZCO,
     +        XC,YC,ZC,CH,VIS,PRO,VAR,PR,IPRESC,FRSPRE,FRSDEN,
     +        ISTATE,ISSB(2),BLKS(NGL)%SOLUTION_TYPE,VOL,PDIFF)
         WRITE(44,*)
      ENDIF

      CALL SWEEPS(DE,F1E,VOL,IMAX,JMAX,KMAX,ISTRID,IN,JN,KN,DT,1,
     +     NTOT,1)
      IF(ICYCLE == IPRINT) THEN
         IF(M == 1) WRITE(44,*)
         CALL PRINYS(3,F2RC, F1R,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F2MC,F1RM,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DMC,    DM,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F2NC,F1RN,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DNC,DN,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F2WC,F1RW,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DWC,DW,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F2EC, F1E,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DEC,DE,     IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F2KC,F1RK,  IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,F2EPC,F1EPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,RKC,    RK, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,REPSC,REPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         WRITE(3,*)
         WRITE(3,*)' RESULTS BEFORE THE SOURCE TERM'
         CALL PRINYS(3,VOLC, VOL, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DROC, DRO, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DKC,  DRK, IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
         CALL PRINYS(3,DEPSC,DEPS,IT,IL,0,IK,IMAX,JMAX,KMAX,NGL,M)
      ENDIF

C **********************************************************************
C     CALCULATE THE POSSIBLE SOURCE TERM HERE
C ************************************************************************

      RETURN
      END SUBROUTINE RESIHS
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE TURBEQ(NBL,M,RO,U,V,W,C,CH,A1,D1,A1XA,
     + A1YA,A1ZA,A2,D2,A2XA,A2YA,A2ZA,A3,D3,A3XA,A3YA,A3ZA,XC,YC,ZC,
     + DISTW,DT,GAMMA,DRO,DM,DN,DW,DE,VOL,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,OHMI,DELTA,ICP,JCP,KCP,
     + IJMASK,IMAX,JMAX,KMAX,ICYCLE,INTERI,INTERJ,INTERK,IDERI,
     + JBOT,JTOP,IDI1,IDI2,IDI3,IT,IL,IK,IPRINT,PR,PRT,CX,CY,CZ,
     + CMX,CMY,CMZ,DX,DY,DZ,TOMEGA,OMEGA,XMOM,YMOM,ZMOM,
     + IBOT,ITOP,KBOT,KTOP,LAMIN,IFLUX,
     + UROT,VROT,WROT,W12,SIJ,MAX11,
     + RK,REPS,DDEPS,DRK,DEPS,SRK,SEPS,PTUR,F1RK,F1EPS,
     + TTS,BIJ,WIR,MAXEB,ISTRES,TURLIM,FRSVIS,
     + RKLIM,EPSLIM,FRSDEN,FRSPRE,FRSVEL,T0,DRDH,DRDP,ITURB,IDIS,
     + KOVER,IEPSMA,PSIGSC,PSIGS2,FI,MAXSB,NSCAL,KSCAL,JRDIS,JRPRE,
     + HAT1,HAT2,HAT3,HAT4,S11,MAXSS,STRESL,NPATCH,ICON,IROTCO,ZZZ,MAXW,
     + VTRAN,RNUT,VORT,SHEAR,STRAIN,RKSI,TURDESL,TRANSL,TRM,MULPHL,
     + TUR_MULPHL,PRO,VAR,VELLAP,QSAS,FUN1,BLKS)
C ... LAST LINE IS FOR SCALARS PPR 11.2
CIBM  INCLUDE (NS3CH)
cc    INCLUDE 'NS3CH.C'

      USE CHARACTERS
      USE CONSTANTS, ONLY : EPS, PII, CV1
      USE INTEGERS,  ONLY : MAXB
      USE NS3CO, ONLY     : IN, JN, KN, IC9
      USE TYPE_ARRAYS

      IMPLICIT NONE

      INTEGER :: III,IMAX,JMAX,KMAX,ISTRID,JSTRID,KSTRID,NTOT,IDM1,IDI1,
     & IDM2,IDI2,IDM3,IDI3,LAMIN1,LAMIN2,LAMIN3,LAMIN,JRDIS,ITURB,JRPRE,
     & NPATCH,IDERI,IBOT,ITOP,JBOT,JTOP,KBOT,KTOP,NBL,ISTRES,L,IDIS,
     & ITYP,KX1,KX2,KY1,KY2,IDIR2,ICYCLE,IPRINT,IT,IL,IK,IEPSMA,KOVER,
     & NS,INTERI,INTERJ,INTERK,IFLUX,MAX11,MAXEB,MAXSB,NSCAL,KSCAL,
     & MAXSS,IROTCO,MAXW,M

      REAL :: FRSMUT,FRSVIS,C1,C2,C3,C21,CMU,CTA,PSIGK,PSIGE,AA1,ETA0,
     & OMEGA,PR,PRT,TURLIM,DIV,RKLIM,EPSLIM,A1KLEB,BSTAR,CKAPPA,BETA1,
     & SIGRK1,SIGOM1,BETA2,SIGRK2,SIGOM2,DT,GAMMA,DELTA,CX,CY,CZ,CMX,
     & CMY,CMZ,DX,DY,DZ,TOMEGA,FRSDEN,FRSPRE,
     & FRSVEL,T0,SIGPHI,ZETA2

      REAL :: ZC(*), YC(*), XC(*)
     
      INTEGER :: ICP(*),JCP(*),KCP(*),IJMASK(*),ICON(IC9,*)

      REAL :: RO(*),U(*),V(*),C(*),A1(*),A1XA(*)
     2 ,A1YA(*),A1ZA(*),A2(*),A2XA(*),A2YA(*),A2ZA(*),
     3 A3(*),A3XA(*),A3YA(*),A3ZA(*),DRO(*),DM(*),DN(*),DE(*),VOL(*),
     4 F1R(*),F1RM(*),F1RN(*),F1E(*),F1RW(*),D1(*),CH(*),TEMP(*),
     5 VIS(*),EPS2(*),VIST(*),DISTW(*),
     6 W(*),DW(*),D2(*),D3(*),
     7 OHMI(*),STRAIN(*),UROT(*),VROT(*),WROT(*),PTUR(*),TTS(*),
     8 RK(*),REPS(*),DRK(*),DEPS(*),SRK(*),SEPS(*),F1RK(*),F1EPS(*),
     9 DRDH(*),DRDP(*),PSIGSC(*),PSIGS2(*),DDEPS(*),
     1 FI(MAXSB,MAX(1,NSCAL)),HAT1(*),HAT2(*),HAT3(*),HAT4(*),
     2 S11(MAXSS,6),W12(MAX11,3),SIJ(MAX11,6),ZZZ(*),
     3 BIJ(MAXEB,6),WIR(MAXEB,3),VTRAN(*),RNUT(*),VORT(MAXB,*),
     4 SHEAR(MAXB,*),RKSI(*),VELLAP(*),QSAS(*),FUN1(*)

      REAL :: XMOM,YMOM,ZMOM

      REAL :: EPS4 ! Aerobased obsolate array

      REAL, ALLOCATABLE :: FMF(:),FWC(:),FWX(:),FWY(:),FWZ(:)

      LOGICAL :: STRESL, TURDESL, TRANSL, MULPHL, TUR_MULPHL

      TYPE(INTERMITTENCY)    :: TRM(*)
      TYPE(PROPERTIES)       :: PRO(*)
      TYPE(MPHASE_VARIABLES) :: VAR(*)
      TYPE(BLOCKS)           :: BLKS(*)


      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      KSTRID  = KMAX + 2*KN
      NTOT    = ISTRID*JSTRID*KSTRID
      FRSMUT  = 1.E-3*FRSVIS !  k-omega lower limit. 
C ... ADJUST CELLS WITH FRICTION TO THE GRID LEVEL USED

      IDM1    = (IDI1-1)/2**(M-1) + 1
      IDM2    = (IDI2-1)/2**(M-1) + 1
      IDM3    = MAX(1,(IDI3-1)/2**(M-1)) + 1
      IF(IDI3 == 0) IDM3 = 0
     
C ... SEPARATE COORDINATE DIRECTIONS FROM LAMIN

      LAMIN1  =  LAMIN/100
      LAMIN2  = (LAMIN - LAMIN1*100)/10
      LAMIN3  =  LAMIN - LAMIN1*100 - LAMIN2*10


C **********************************************************************
C                                                                      *
C ... CALCULATION OF TWO-EQUATION TURBULENCE MODELS                    *
C     CALCULATE TURBULENCE VISCOSITIES                                  *
C                                                                      *
C **********************************************************************

C ... COEFFICIENTS FOR THE TURBULENCE MODELS

      CALL TURBCO(ITURB,JRDIS,JRPRE,C1,C2,C3,C21,CMU,CTA,PSIGK,
     +     PSIGE,AA1,ETA0)

C ... Calculate velocity derivatives and store as strain and vorticity

      CALL DERFUN(OHMI,W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),
     +     SIJ(1,3),SIJ(1,4),SIJ(1,5),SIJ(1,6),U,V,W,A1,A2,A3,VOL,
     +     D1,D2,D3,A1XA,A1YA,A1ZA,A2XA,A2YA,A2ZA,A3XA,A3YA,A3ZA,
     +     XC,YC,ZC,IMAX,JMAX,KMAX,IN,JN,KN,IDERI,M,STRAIN,VELLAP)

      DO III = 1,3
        VORT(1:NTOT,III)  = W12(1:NTOT,III)
      ENDDO
      DO III = 1,6
        SHEAR(1:NTOT,III) = SIJ(1:NTOT,III)
      ENDDO

      IF(LAMIN /= 0) THEN

      IF(ITURB >= 10 .AND. ITURB <= 19) THEN
C ... mitakohan taman tekee tassa. Siis vain tassa lasketaan RS PPR
C ... 20.3.97
      CALL GATSKI(OHMI,W12(1,1),W12(1,2),W12(1,3),SIJ(1,1),SIJ(1,2),
     +        SIJ(1,3),SIJ(1,4),SIJ(1,5),SIJ(1,6),
     +        S11(1,1),S11(1,2),S11(1,3), S11(1,4),S11(1,5),S11(1,6),
     +        PTUR,U,V,W,RK,REPS,DDEPS,EPS2,VIST,VIS,
     +        OMEGA,VTRAN,IMAX,JMAX,KMAX,IN,JN,KN,ITURB,M)

         CALL REFLUU(S11(1,1),S11(1,2),S11(1,3),S11(1,4),S11(1,5),
     +        S11(1,6),IMAX,JMAX,KMAX,IBOT,ITOP,JBOT,JTOP,KBOT,KTOP,
     +        IN,JN,KN,NPATCH,ICON,NBL)
       ENDIF ! ITURB >= 10 .AND. ITURB <= 19

      ENDIF ! LAMIN /= 0

C ... Wallin-Johansson type EARSM and turbulence time scale

      IF(.NOT.TURDESL) THEN ! Turbulence time scale
        CALL TTIMES(RO,VIS,RK,REPS,ITURB,IMAX,JMAX,KMAX,TTS)
      ENDIF

      IF(ISTRES == 1) THEN
      CALL EARSM1(VIS,VIST,EPS2,EPS4,RK,WIR,W12,SIJ,BIJ,IMAX,JMAX,
     &     KMAX,MAXEB,MAX11,TTS,PR,PRT,TURLIM,FRSMUT)
      ENDIF


C ... Initialize some arrays

      DO 9 L = 1,ISTRID*JSTRID*KSTRID     ! INITIALIZATION OF
      DIV    = (SIJ(L,1) + SIJ(L,4) + SIJ(L,6))/3.
      F1R(L) = (SIJ(L,1)-DIV)**2 + (SIJ(L,4)-DIV)**2 + (SIJ(L,6)-DIV)**2
     +        + 2.*SIJ(L,2)**2 + 2.*SIJ(L,3)**2 + 2.*SIJ(L,5)**2
      F1R(L) = SQRT(2.*F1R(L))            ! TOTAL STRAIN    (S)
      F1RW(L)= 0.                         ! MENTER'S COEFF. (F2)
      F1RN(L)= 0.                         ! WALL DISTANCE   (Y)
      F1RM(L)= 1.                         ! WALL DAMPING    (F)

 9    CONTINUE

      IF(MULPHL) THEN
         ALLOCATE (FMF(NTOT))
         ALLOCATE (FWX(NTOT),FWY(NTOT),FWZ(NTOT),FWC(NTOT))
         FMF(1:NTOT) = 0. ! Initialized to one as the wall is found
         FWX(1:NTOT) = 0.
         FWY(1:NTOT) = 0.
         FWZ(1:NTOT) = 0.
         IF(BLKS(NBL)%WFORCEMUL /= 0) THEN
            CALL FWCOEFF(PRO,VAR,BLKS,FWC,U,V,W,
     +   IMAX,JMAX,KMAX,IN,JN,KN,DT,NBL,M,RO)
         ENDIF
      ENDIF ! MULPHL

C **********************************************************************
 
C ... WALL CORRECTIONS AND TURBULENT VISCOSITY FOR k-epsilon MODELS
C ... SPEZIALE'S MODEL DOES NOT NEED WALL FUNCTIONS
     
      IF (ITURB /= 10 .AND. ITURB /= 9 .AND. IDIS == 1)THEN 

      IF(LAMIN3 /= 0) THEN

C ... look through patches for turbulence variables.

      DO L = 1,NPATCH
      ITYP  = ICON(1,L)
      IF(ITYP >= 8 .AND. ITYP <= 10 .AND. (ICON(3,L) == 3 .OR.
     +    ICON(3,L) == 6))THEN
      KX1 = ICON(4,L)
      KX2 = ICON(5,L)
      KY1 = ICON(6,L)
      KY2 = ICON(7,L)
      IDIR2 = 1
      IF(ICON(3,L) >= 4) IDIR2 = -1

      CALL WALLKE(VIS,OHMI,RO,D3,IMAX,JMAX,KMAX,IN,JN,KN,
     +     KBOT,KTOP,KCP,LAMIN3,F1RM,F1RN,F1RW,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
      IF(ITURB == 8) THEN ! van Driest damping for Smagorinsky SGS
         CALL WALLVD(VIS,OHMI,RO,D3,IMAX,JMAX,KMAX,IN,JN,KN,
     +     KBOT,KTOP,KCP,LAMIN3,F1RM,F1RN,F1RW,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
      ENDIF
      IF(MULPHL) THEN 
      IF(TUR_MULPHL) THEN ! Multiphase wall terms for turbulence
         CALL WALLMF(VIS,OHMI,RO,D3,IMAX,JMAX,KMAX,IN,JN,KN,
     +     KBOT,KTOP,LAMIN3,FMF,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
      ENDIF
         IF(BLKS(NBL)%WFORCEMUL /= 0) THEN ! Wall force
         CALL WALLF(FWC,FWX,FWY,FWZ,A3XA,A3YA,A3ZA,D3,IMAX,JMAX,KMAX,
     +     IN,JN,KN,KBOT,KTOP,LAMIN3,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,BLKS(NBL)%WFORCEMUL)
         ENDIF
      ENDIF ! MULPHL

      ENDIF
      ENDDO

       IF(ICYCLE == IPRINT) THEN
          WRITE(3,*)
          WRITE(3,*) ' WALL SOURCE AFTER K-DIRECTION'
          CALL PRINYS(3,'   F    ',F1RM,IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          CALL PRINYS(3,'   F2   ',F1RW,IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          IF(MULPHL .AND. TUR_MULPHL) THEN
          CALL PRINYS(3,'   FMF  ',FMF, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          CALL PRINYS(3,'   FWX  ',FWX, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
c          CALL PRINYS(332,A1XC,A1XA, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
c          CALL PRINYS(332,A2XC,A2XA, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
c          CALL PRINYS(332,A3XC,A3XA, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          ENDIF ! MULPHL
       ENDIF
      ENDIF

      IF(LAMIN1 /= 0) THEN
      CALL SORT40(RO,VIS,D1,OHMI,F1RM,F1RW,ISTRID,JSTRID,KSTRID,1,ZZZ)
      IF(MULPHL) THEN
         CALL SORTZZ(FMF,ISTRID,JSTRID,KSTRID,1,ZZZ)
         CALL SORT43(FWC,FWX,FWY,FWZ,A1XA,A1YA,A1ZA,ISTRID,JSTRID,
     +   KSTRID,1,ZZZ)
      ENDIF ! MULPHL

      DO L = 1,NPATCH
      ITYP  = ICON(1,L)
      IF(ITYP >= 8 .AND. ITYP <= 10 .AND. (ICON(3,L) == 1 .OR.
     +    ICON(3,L) == 4))THEN
      KX1 = ICON(4,L)
      KX2 = ICON(5,L)
      KY1 = ICON(6,L)
      KY2 = ICON(7,L)
      IDIR2 = 1
      IF(ICON(3,L) >= 4) IDIR2 = -1
      CALL WALLKE(VIS,OHMI,RO,D1,JMAX,KMAX,IMAX,JN,KN,IN,
     +     IBOT,ITOP,ICP,LAMIN1,F1RM,F1RN,F1RW,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
      IF(ITURB == 8) THEN ! van Driest damping for Smagorinsky SGS
      CALL WALLVD(VIS,OHMI,RO,D1,JMAX,KMAX,IMAX,JN,KN,IN,
     +     IBOT,ITOP,ICP,LAMIN1,F1RM,F1RN,F1RW,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
      ENDIF
      IF(MULPHL) THEN 
      IF(TUR_MULPHL) THEN ! Multiphase wall terms for turbulence
         CALL WALLMF(VIS,OHMI,RO,D1,JMAX,KMAX,IMAX,JN,KN,IN,
     +     IBOT,ITOP,LAMIN1,FMF,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
      ENDIF
         IF(BLKS(NBL)%WFORCEMUL /= 0) THEN ! Wall force
         CALL WALLF(FWC,FWX,FWY,FWZ,A1XA,A1YA,A1ZA,D1,JMAX,KMAX,IMAX,
     +     JN,KN,IN,IBOT,ITOP,LAMIN1,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,BLKS(NBL)%WFORCEMUL)
         ENDIF
      ENDIF

      ENDIF ! LAMIN1
      ENDDO

      CALL SORT40(RO,VIS,D1,OHMI,F1RM,F1RW,JSTRID,KSTRID,ISTRID,2,ZZZ)
      IF(MULPHL) THEN
         CALL SORTZZ(FMF,JSTRID,KSTRID,ISTRID,2,ZZZ)
         CALL SORT43(FWC,FWX,FWY,FWZ,A1XA,A1YA,A1ZA,JSTRID,KSTRID,
     +   ISTRID,2,ZZZ)
      ENDIF ! MULPHL

       IF(ICYCLE == IPRINT) THEN
          WRITE(3,*)
          WRITE(3,*) ' WALL SOURCE AFTER I-DIRECTION'
          CALL PRINYS(3,'   F    ',F1RM,IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          CALL PRINYS(3,'   F2   ',F1RW,IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          IF(MULPHL .AND. TUR_MULPHL) THEN
          CALL PRINYS(3,'   FMF  ',FMF, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          CALL PRINYS(3,'   FWX  ',FWX, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          ENDIF ! MULPHL
       ENDIF
      ENDIF

      IF(LAMIN2 /= 0) THEN

      CALL SORT40(RO,VIS,D2,OHMI,F1RM,F1RW,ISTRID,JSTRID,KSTRID,2,ZZZ)
      IF(MULPHL) THEN
         CALL SORTZZ(FMF,ISTRID,JSTRID,KSTRID,2,ZZZ)
         CALL SORT43(FWC,FWX,FWY,FWZ,A2XA,A2YA,A2ZA,ISTRID,JSTRID,
     +   KSTRID,2,ZZZ)
      ENDIF

      DO L = 1,NPATCH
      ITYP  = ICON(1,L)
      IF(ITYP >= 8 .AND. ITYP <= 10 .AND. (ICON(3,L) == 2 .OR.
     +    ICON(3,L) == 5))THEN
      KY1 = ICON(4,L)
      KY2 = ICON(5,L)
      KX1 = ICON(6,L)
      KX2 = ICON(7,L)
      IDIR2 = 1
      IF(ICON(3,L) >= 4) IDIR2 = -1
      CALL WALLKE(VIS,OHMI,RO,D2,KMAX,IMAX,JMAX,KN,IN,JN,
     +     JBOT,JTOP,JCP,LAMIN2,F1RM,F1RN,F1RW,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
      IF(ITURB == 8) THEN ! van Driest damping for Smagorinsky SGS
         CALL WALLVD(VIS,OHMI,RO,D2,KMAX,IMAX,JMAX,KN,IN,JN,
     +     JBOT,JTOP,JCP,LAMIN2,F1RM,F1RN,F1RW,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
      ENDIF
      IF(MULPHL) THEN
      IF(TUR_MULPHL) THEN ! Multiphase wall terms for turbulence
         CALL WALLMF(VIS,OHMI,RO,D2,KMAX,IMAX,JMAX,KN,IN,JN,
     +     JBOT,JTOP,LAMIN2,FMF,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
      ENDIF
         IF(BLKS(NBL)%WFORCEMUL /= 0) THEN ! Wall force
         CALL WALLF(FWC,FWX,FWY,FWZ,A2XA,A2YA,A2ZA,D2,KMAX,IMAX,JMAX,
     +     KN,IN,JN,JBOT,JTOP,LAMIN2,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,BLKS(NBL)%WFORCEMUL)
         ENDIF
      ENDIF

      ENDIF ! LAMIN2
      ENDDO

      CALL SORT40(RO,VIS,D2,OHMI,F1RM,F1RW,KSTRID,ISTRID,JSTRID,1,ZZZ)
      IF(MULPHL) THEN
         CALL SORTZZ(FMF,KSTRID,ISTRID,JSTRID,1,ZZZ)
         CALL SORT43(FWC,FWX,FWY,FWZ,A2XA,A2YA,A2ZA,KSTRID,ISTRID,
     +   JSTRID,1,ZZZ)
      ENDIF ! MULPHL

       IF(ICYCLE == IPRINT) THEN
          WRITE(3,*)
          WRITE(3,*) ' WALL SOURCE AFTER J-DIRECTION'
          CALL PRINYS(3,'   F    ',F1RM,IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          CALL PRINYS(3,'   F2   ',F1RW,IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          IF(MULPHL .AND. TUR_MULPHL) THEN
          CALL PRINYS(3,'   FMF  ',FMF, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          CALL PRINYS(3,'   FWX  ',FWX, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          CALL PRINYS(3,'   FWY  ',FWY, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          ENDIF ! MULPHL
       ENDIF
      ENDIF ! LAMIN2

      IF(BLKS(NBL)%WFORCEMUL /= 0) THEN ! Store multiphase wall terms
         PRO(1:NTOT)%FW(1) = FWX(1:NTOT)
         PRO(1:NTOT)%FW(2) = FWY(1:NTOT)
         PRO(1:NTOT)%FW(3) = FWZ(1:NTOT)
      ENDIF

      ENDIF                     ! (ITURB /= 10 .AND. IDIS == 1)

C ... Wall corrections for K-EPSILON completed
C **********************************************************************
C ... K-OMEGA MUST ALSO BE CALLED IF BUBBLE-INDUCED TURBULENCE EXISTS

      IF (ITURB /= 10 .AND. ITURB /= 9 .AND. IDIS == 2 .AND. TUR_MULPHL)
     +THEN 

      IF(LAMIN3 /= 0) THEN

C ... look through patches for turbulence variables.

      DO L = 1,NPATCH
      ITYP  = ICON(1,L)
      IF(ITYP >= 8 .AND. ITYP <= 10 .AND. (ICON(3,L) == 3 .OR.
     +    ICON(3,L) == 6))THEN
      KX1 = ICON(4,L)
      KX2 = ICON(5,L)
      KY1 = ICON(6,L)
      KY2 = ICON(7,L)
      IDIR2 = 1
      IF(ICON(3,L) >= 4) IDIR2 = -1

      IF(MULPHL .AND. TUR_MULPHL) THEN ! Multiphase wall terms
         CALL WALLMF(VIS,OHMI,RO,D3,IMAX,JMAX,KMAX,IN,JN,KN,
     +     KBOT,KTOP,LAMIN3,FMF,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
         IF(BLKS(NBL)%WFORCEMUL /= 0) THEN ! Wall force
         CALL WALLF(FWC,FWX,FWY,FWZ,A3XA,A3YA,A3ZA,D3,IMAX,JMAX,KMAX,
     +     IN,JN,KN,KBOT,KTOP,LAMIN3,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,BLKS(NBL)%WFORCEMUL)

         ENDIF
      ENDIF
      ENDIF
      ENDDO

       IF(ICYCLE == IPRINT) THEN
          WRITE(3,*)
          WRITE(3,*) ' AFTER K-DIRECTION'
          IF(MULPHL .AND. TUR_MULPHL)
     +    CALL PRINYS(3,'   FMF  ',FMF, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
       ENDIF
      ENDIF

      IF(LAMIN1 /= 0) THEN

      CALL SORT40(RO,VIS,D1,OHMI,F1RM,F1RW,ISTRID,JSTRID,KSTRID,1,ZZZ)
      CALL SORTZZ(FMF,ISTRID,JSTRID,KSTRID,1,ZZZ)

      DO L = 1,NPATCH
      ITYP  = ICON(1,L)
      IF(ITYP >= 8 .AND. ITYP <= 10 .AND. (ICON(3,L) == 1 .OR.
     +    ICON(3,L) == 4))THEN
      KX1 = ICON(4,L)
      KX2 = ICON(5,L)
      KY1 = ICON(6,L)
      KY2 = ICON(7,L)
      IDIR2 = 1
      IF(ICON(3,L) >= 4) IDIR2 = -1
      IF(MULPHL .AND. TUR_MULPHL) THEN ! Multiphase wall terms
         CALL WALLMF(VIS,OHMI,RO,D1,JMAX,KMAX,IMAX,JN,KN,IN,
     +     IBOT,ITOP,LAMIN1,FMF,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
         IF(BLKS(NBL)%WFORCEMUL /= 0) THEN ! Wall force
         CALL WALLF(FWC,FWX,FWY,FWZ,A1XA,A1YA,A1ZA,D1,JMAX,KMAX,IMAX,
     +     JN,KN,IN,IBOT,ITOP,LAMIN1,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,BLKS(NBL)%WFORCEMUL)
         ENDIF

      ENDIF
      ENDIF
      ENDDO

      CALL SORT40(RO,VIS,D1,OHMI,F1RM,F1RW,JSTRID,KSTRID,ISTRID,2,ZZZ)
      CALL SORTZZ(FMF,JSTRID,KSTRID,ISTRID,2,ZZZ)

       IF(ICYCLE == IPRINT) THEN
          WRITE(3,*)
          WRITE(3,*) ' AFTER I-DIRECTION'
          IF(MULPHL .AND. TUR_MULPHL) THEN
          CALL PRINYS(3,'   FMF  ',FMF, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          ENDIF ! MULPHL
       ENDIF
      ENDIF

      IF(LAMIN2 /= 0) THEN

      CALL SORT40(RO,VIS,D2,OHMI,F1RM,F1RW,ISTRID,JSTRID,KSTRID,2,ZZZ)
      CALL SORTZZ(FMF,ISTRID,JSTRID,KSTRID,2,ZZZ)

      DO L = 1,NPATCH
      ITYP  = ICON(1,L)
      IF(ITYP >= 8 .AND. ITYP <= 10 .AND. (ICON(3,L) == 2 .OR.
     +    ICON(3,L) == 5))THEN
      KY1 = ICON(4,L)
      KY2 = ICON(5,L)
      KX1 = ICON(6,L)
      KX2 = ICON(7,L)
      IDIR2 = 1

      IF(ICON(3,L) >= 4) IDIR2 = -1
      IF(MULPHL .AND. TUR_MULPHL) THEN ! Multiphase wall terms
         CALL WALLMF(VIS,OHMI,RO,D2,KMAX,IMAX,JMAX,KN,IN,JN,
     +     JBOT,JTOP,LAMIN2,FMF,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,ZZZ)
         IF(BLKS(NBL)%WFORCEMUL /= 0) THEN ! Wall force
         CALL WALLF(FWC,FWX,FWY,FWZ,A2XA,A2YA,A2ZA,D2,KMAX,IMAX,JMAX,
     +     KN,IN,JN,JBOT,JTOP,LAMIN2,F1E,ITURB,
     +     KX1,KX2,KY1,KY2,IDIR2,BLKS(NBL)%WFORCEMUL)
         ENDIF
      ENDIF
      ENDIF
      ENDDO

      CALL SORT40(RO,VIS,D2,OHMI,F1RM,F1RW,KSTRID,ISTRID,JSTRID,1,ZZZ)
      CALL SORTZZ(FMF,KSTRID,ISTRID,JSTRID,1,ZZZ)

       IF(ICYCLE == IPRINT) THEN
          WRITE(3,*)
          WRITE(3,*) ' AFTER J-DIRECTION'
          IF(MULPHL .AND. TUR_MULPHL) THEN
          CALL PRINYS(3,'   FMF  ',FMF, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          ENDIF ! MULPHL
       ENDIF
      ENDIF
      ENDIF                     ! (ITURB /= 10 .AND. IDIS == 2)

C ... WALL CORRECTIONS DONE

C **********************************************************************

C ... Calculate turbulent viscosity in k-epsilon based models

      IF(IEPSMA /= 1 .AND. IDIS == 1) THEN

      CALL EPS2KE(EPS2,VIST,VIS,F1R,OHMI,RO,RK,REPS,C,IMAX,JMAX,KMAX,
     + IN,JN,KN,M,F1RM,F1RW,DDEPS,ITURB,TURLIM,RKLIM,EPSLIM,CMU,AA1,
     + RKSI,VOL)

      ELSE IF(IDIS == 1) THEN       ! With compressibility effects
	
      CALL EPS2CO(EPS2,VIST,VIS,F1R,OHMI,RO,RK,REPS,C,IMAX,JMAX,KMAX,
     + IN,JN,KN,M,F1RM,F1RW,DDEPS,ITURB,TURLIM,RKLIM,EPSLIM,CMU,AA1,
     + RKSI)
      ENDIF

C ... k-epsilon type models handled

      IF(IDIS == 2) THEN ! k-omega

        CALL COEFKO(ITURB,A1KLEB,BSTAR,CKAPPA,BETA1,
     +  SIGRK1,SIGOM1,BETA2,SIGRK2,SIGOM2,
     +  SIGPHI,ZETA2,KOVER)

        IF ((KOVER == 0).OR.(KOVER == 5)) THEN
C       The original versions (SST and BSL) by Florian Menter (OHMI):
C           CALL EPS2KO(EPS2,VIST,VIS,OHMI,RO,RK,REPS,DISTW,
            CALL EPS2KO(EPS2,VIST,VIS,STRAIN,RO,RK,REPS,DISTW,
     +      TURLIM,FRSMUT,IMAX,JMAX,KMAX,IN,JN,KN,PR,PRT,
     +      BSTAR,A1KLEB,KOVER,RKSI)
        ELSE
C       The rotation and curvature corrected RC-versions (etc) (STRAIN):
            CALL EPS2KO(EPS2,VIST,VIS,F1R,RO,RK,REPS,DISTW,
     +      TURLIM,FRSMUT,IMAX,JMAX,KMAX,IN,JN,KN,PR,PRT,
     +      BSTAR,A1KLEB,KOVER,RKSI)
      END IF

      END IF ! IDIS == 2

C ... k-omega models handled

      IF(ITURB == 9) THEN ! Spalart-Allmaras
          CALL SPALART_ALLMARAS(EPS2,VIST,RO,VIS,REPS,CV1,IMAX,JMAX,
     +    KMAX,IN,JN,KN,TURLIM,RKSI)
      ENDIF

C ... Spalart-Allmaras model handled

      IF(MULPHL .AND. TUR_MULPHL) THEN ! Bubble-induced turbulence
            CALL EPS2MF(EPS2,VIST,VIS,STRAIN,RO,RK,REPS,DISTW,FMF,VAR,
     +      TURLIM,FRSMUT,IMAX,JMAX,KMAX,IN,JN,KN,PR,PRT,
     +      BSTAR,A1KLEB,KOVER,RKSI)
      ENDIF ! TUR_MULPHL

       IF(ICYCLE == IPRINT) THEN
          WRITE(3,*)
          WRITE(3,*) ' TURBULENT VISCOCITY'
          CALL PRINYS(3,EPS2C,EPS2, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          IF(ITURB /= 9)
     +    CALL PRINYS(3,REPSC,REPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          IF(ITURB == 9)
     +    CALL PRINYS(3,RNUTC,REPS, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          CALL PRINYS(3,VISTC,VIST, IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          CALL PRINYS(3,'   S    ',F1R,IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          CALL PRINYS(3,OHMIC,OHMI,IT,IL,0,IK,IMAX,JMAX,KMAX,NBL,M)
          IF(ITURB >= 10 .AND. ITURB <= 19) THEN
             DO NS = 1,6
                CALL PRINYS(3,UUC(NS),S11(1,NS),IT,IL,0,IK,IMAX,JMAX,
     +          KMAX,NBL,M)
             ENDDO
          ENDIF
      ENDIF

c     DEALLOCATE (FMF,FWC,FWX,FWY,FWZ)

      RETURN
      END SUBROUTINE TURBEQ
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE FLXCYC(NBL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,CP,
     + A3,D3,A3XA,A3YA,A3ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,
     + W12,W13,W23,SS11,SS12,SS13,SS22,
     + SS23,SS33,DTDX,DTDY,DTDZ,DKDX,
     + DKDY,DKDZ,DEPSDX,DEPSDY,DEPSDZ,RGAS,GAMMA,E0REF,T0REF,
     + DRO,DM,DN,DW,DE,VOL,OHMI,KCP,IMAX,JMAX,KMAX,
     + IN,JN,KN,ISTRID,JSTRID,KSTRID,ICYCLE,ICMAX,INTERK,INTETK,INTEAK,
     + IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,S11,MAXSS,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,RMLOSS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,KBOT,KTOP,LAMIN3,IFLUX,
     + WROT,IDM3,UBK,VBK,WBK,UTK,VTK,WTK,
     + RK,REPS,DDEPS,DRK,DEPS,SRK,SEPS,
     + PTUR,F1RK,F1EPS,FUN1,BIJ,MAXEB,ISTRES,TURLIM,RKLIM,
     + EPSLIM,PSIGK1,PSIGE1,PSIGK,PSIGE,C1,C2,CMU,CTA,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + ITURB,IDIS,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,KBEGIN,
     + KSCAL,HAT1,HAT2,HAT3,HAT4,RLOLIM,PROD,PI,DIF,DIS,VVIS,FWLL,
     + JRDIF,JRDIS,JRPRE,SOURL,IMAXRE,JMAXRE,KMAXRE,INRE,JNRE,KNRE,
     + KMAXP,ISTR,JSTR,KSTR,IDIR,FULLNS,ZZZ,MAXW,MAX11,
     + XCO,YCO,ZCO,QMFIN,QVFIN,QMEIN,QMFOUT,QVFOUT,QMEOUT,
     + QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMYIN,
     + CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,BOUNA1,
     + BOUNA2,IBF,PRO,VAR,PRC,BLKS,MULPHL,JSTATE,IPRESC,TURCOR,XXTRAL,
     + FRESUL,F1H,WAVE,IFSBC,IWAVEB,FREDIF,BUX,BUY,BUZ,VMXB,VMYB,VMZB,
     + FRSSIE,RNUT,STRAIN,PSEUCO,RJK2,RJK4,SCALEJ,RKSI,INCHIML,
     + ENTROPY_FIX,GRAVIL,QGFIN,QGEIN,QGFOUT,QGEOUT,
     + TRANSL,TRM,BOUNG,BOUNRET,DISTW,PLE2,IDIMS,JDIMS,SURFA,SURFT,
     + SURF2X,SURF2Y,SURF2Z,SURFMX,SURFMY,SURFMZ,IUPPTL,BOUNU1,BOUNU2,
     + BOUNV1,BOUNV2,BOUNW1,BOUNW2,SURFPX,SURFPY,SURFPZ,
     + QLFIN,QLEIN,QLFOUT,QLEOUT,UTAUM,EPSOLD)

      USE TYPE_ARRAYS
      USE CHARACTERS
      USE CONSTANTS, ONLY   : EPS, PII
      USE NS3CO, ONLY       : IC9, WALLFUNL
      USE FLIGHT, ONLY      : ACTDISK, IFA, IFT, SHIP, ISCALE_ACT
      USE MAIN_ARRAYS, ONLY : IGRID

      IMPLICIT NONE

      INTEGER :: NBL,M,M2,IMAX,JMAX,KMAX,IN,JN,KN,ISTRID,JSTRID,KSTRID,
     2 ICYCLE,CMAX,INTERK,INTETK,IT,IL,IK,IPRINT,MAXSS,NPATCH,KBOT,
     3 KTOP,LAMIN3,IFLUX,IDM3,MAXEB,ISTRES,ISTATE,ITURB,IDIS,MAXSB,
     4 NSCAL,KBEGIN,KSCAL,JRDIF,JRDIS,JRPRE,IMAXRE,JMAXRE,KMAXRE,
     5 KMAXP,ISTR,JSTR,KSTR,IDIR,AXW,MAX11,MAW,NTOT,IJKSTR,IADD,JADD,
     6 KADD,NS,L,ITYP,KX1,KX2,KY1,KY2,IDIR2,IF2,IFACE,ILMO,KBOTOP,
     7 INLOUT,IBF,II,IBL,IBTYPE,NFACN,ICMAX,MAXW,IQ2,IE2,IPHASE,
     8 IPRESC,IFSBC,KX11,KX22,KY11,KY22,KOKO,ICHARP,IDIMP,
     9 JDIMP,iii,KX1SAVE,KX2SAVE,IACTU,IA2,IM2,JA2,JM2,IUPPTL,INTEAK,
     1 INRE,JNRE,KNRE

      REAL :: RO(*),RM(*),RN(*),E(*),P(*),PDIFF(*),U(*),V(*),C(*),
     2 A3(*),A3XA(*),A3YA(*),A3ZA(*),DRO(*),DM(*),DN(*),DE(*),VOL(*),
     3 F1R(*),F1RM(*),F1RN(*),F1E(*),F1RW(*),CH(*),TEMP(*),
     4 VIS(*),EPS2(*),VIST(*),CP(*),
     5 UWALL(*),VWALL(*),WWALL(*),CPWALL(*),TWALL(*),QWALL(*),
     6 QWFRIC(*),TAUW1(*),TAUW2(*),SURFX(*),SURFY(*),SURFZ(*),
     7 TAUWX(*),TAUWY(*),TAUWZ(*),SURLE(*),DSURLE(*),WMFLUX(*),
     8 POROS(*),WHSTAG(*),WTEMP(*),RSDIRX(*),RSDIRY(*),RSDIRZ(*),
     9 RBK(*),HFLUX(*),RMLOSS(*),
     1 UBK(*),VBK(*),WBK(*),UTK(*),VTK(*),WTK(*),
     2 RW(*),W(*),DW(*),D3(*),OHMI(*),WROT(*),PTUR(*),
     3 RK(*),REPS(*),DRK(*),DEPS(*),SRK(*),SEPS(*),F1RK(*),F1EPS(*),
     4 DRDH(*),DRDP(*),PSIGSC(*),PSIGS2(*),
     5 FI(MAXSB,MAX(1,NSCAL)),F1FI(MAXSB,MAX(1,NSCAL)),
     6 DFI(MAXSB,MAX(1,NSCAL)),SFI(MAXSB,MAX(1,NSCAL)),
     7 HAT1(*),HAT2(*),HAT3(*),HAT4(*),
     8 PROD(MAXSB,6),PI(MAXSB,6),DIF(MAXSB,6),DIS(MAXSB,6),S11(MAXSS,6),
     9 VVIS(MAXSB,6),FWLL(*),RLOLIM(*),DDEPS(*),
     1 CX(*),CY(*),CZ(*),CMX(*),CMY(*),CMZ(*),DX(*),DY(*),DZ(*),
     2 QX(*),QY(*),QZ(*),TOMEGA(*),RCON(IC9,*),FUN1(*),BIJ(MAXEB,6),
     3 W12(*),W13(*),W23(*),SS11(*),SS12(*),SS13(*),SS22(*),SS23(*),
     4 SS33(*),DTDX(*),DTDY(*),DTDZ(*),DKDX(*),DKDY(*),DKDZ(*),
     5 DEPSDX(*),DEPSDY(*),DEPSDZ(*),ZZZ(*),BOUNR(*),BOUNU(*),BOUNV(*),
     6 BOUNW(*),BOUNE(*),BOUNT(*),BOUNRK(*),BOUNEP(*),BOUNFI(IBF,*),
     7 BOUNBI(IBF,*),BOUNP(*),BOUNPD(*),BOUNMF(*),BOUNA1(*),BOUNA2(*),
     8 F1H(*),WAVE(*),BUX(*),BUY(*),BUZ(*),VMXB(*),VMYB(*),VMZB(*),
     9 RNUT(*),STRAIN(*),SCALEJ(*),RKSI(*),
     1 BOUNG(*),BOUNRET(*),DISTW(*),PLE2(*),SURFA(*),SURFT(*),
     2 SURF2X(*),SURF2Y(*),SURF2Z(*),SURFMX(*),SURFMY(*),SURFMZ(*),
     3 BOUNU1(*),BOUNU2(*),BOUNV1(*),BOUNV2(*),BOUNW1(*),BOUNW2(*),
     4 SURFPX(*),SURFPY(*),SURFPZ(*),UTAUM(*),EPSOLD(*)

      REAL :: RGAS,GAMMA,E0REF,T0REF,OMEGA,TURLIM,RKLIM,RJK2,RJK4,
     2 EPSLIM,PSIGK1,PSIGE1,PSIGK,PSIGE,C1,C2,CMU,CTA,FRSDEN,FRSPRE,
     3 FRSVEL,FRSVIS,T0,DIFPRE,QMFIN,QMEIN,QMFOUT,QMEOUT,QMXIN,QMXOUT,
     4 QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,
     5 CMZOUT,PR,PRT,QVFIN,QVFOUT,ARTSSP,FREDIF,FRSSIE,
     6 PSEUCO,QGFIN,QGEIN,QGFOUT,QGEOUT,QLFIN,QLEIN,QLFOUT,QLEOUT,
     7 RELAX

      CHARACTER(10)          :: MULPHC

      INTEGER :: IHF(*),ICON(IC9,*),KCP(*),JSTATE(*),
     1           IWAVEB(*),IDIMS(*),JDIMS(*),ACNOR(19)

      REAL :: XCO(*), YCO(*), ZCO(*), XC(*), YC(*), ZC(*),
     2                    XCP(*), YCP(*), ZCP(*)

      REAL :: XMOM,YMOM,ZMOM
      
      REAL,ALLOCATABLE :: F2VWF(:),F3VWF(:),F4VWF(:)

      TYPE(PROPERTIES)       :: PRO(*)
      TYPE(MPHASE_VARIABLES) :: VAR(*)
      TYPE(BLOCKS)  :: BLKS(*)
      TYPE(PRE_COR) :: PRC(*)
      TYPE(INTERMITTENCY)    :: TRM(*)

      LOGICAL :: SOURL,FULLNS,DIRECTION,SOLID_WALL,INLETS_AND_OUTLETS,
     &  INLETS,MULPHL,TURCOR,XXTRAL,FRESUL,INCHIML,ENTROPY_FIX,GRAVIL,
     &  TRANSL

      REAL, POINTER :: TEMP1(:),TEMP2(:),ALFA1(:),ALFA2(:),X1(:),
     &  X2(:),RO1(:),RO2(:) ! Liian hidas

C ... CALCULATIONS OF FLUXES WITH HIGHER-ORDER TURBULENCE MODELS.

*      CALL DOMAW(MAXW,IMAXRE,JMAXRE,MAW)
      CALL DOMAW(MAXW,IMAXRE,JMAXRE,INRE,JNRE,MAW)

      NTOT   = ISTRID*JSTRID*KSTRID
      IF(ICYCLE == 1) ACNOR = 1 ! Scaling of the actuator data

c      TEMP1 => PRO(1:NTOT)%TEMP(1) ; TEMP2 => PRO(1:NTOT)%TEMP(2)
c      ALFA1 => VAR(1:NTOT)%ALFA(1) ; ALFA2 => VAR(1:NTOT)%ALFA(2)
c      X1    => VAR(1:NTOT)%X(1)    ; X2    => VAR(1:NTOT)%X(2)
c      RO1   => PRO(1:NTOT)%RO(1)   ; RO2   => PRO(1:NTOT)%RO(2)

      IF(IDIR == 1) THEN
        IJKSTR = ISTR
        IADD   = 1
        JADD   = 0
        KADD   = 0
      ELSE IF(IDIR ==  2) THEN
        IJKSTR = JSTR
        IADD   = 0
        JADD   = 1
        KADD   = 0
      ELSE IF(IDIR == 3) THEN
        IJKSTR = KSTR
        IADD   = 0
        JADD   = 0
        KADD   = 1
      ELSE
        STOP 'In FLXCYX'
      ENDIF
       
      IF(JRDIS >= 4) THEN
      DO 7 NS = 1,NSCAL
      CALL ZEROZZ(F1FI(1,NS),NTOT)
7     CONTINUE
      ENDIF
 
      ARTSSP = BLKS(NBL)%ARTSSP

      MULPHC = BLKS(NBL)%SOLUTION_TYPE

      IF(LAMIN3 /= 0) THEN

C ... CALCULATE WALL-DEPENDENT SOURCE TERMS WITH TWO-EQUATION MODELS
C **********************************************************************

C ... look through the solid patches for turbulence variables.

      DO L = 1,NPATCH
      ITYP  = ICON(1,L)
      IF(ITYP >= 8 .AND. ITYP <= 10 .AND. (ICON(3,L) == IDIR .OR.
     +    ICON(3,L) == IDIR+3))THEN

         KX1 = ICON(4,L)
         KX2 = ICON(5,L)
         KY1 = ICON(6,L)
         KY2 = ICON(7,L)
      IF(IDIR == 2) THEN
         KY1 = ICON(4,L)
         KY2 = ICON(5,L)
         KX1 = ICON(6,L)
         KX2 = ICON(7,L)
      ENDIF

      IDIR2 = 1
      IF(ICON(3,L) >= 4) IDIR2 = -1

      IF(KBOT /= 0 .OR. KTOP /= 0)     THEN 

      IF(ITURB /= 10 .AND. ITURB /= 6) THEN  ! ISOTROPIC
         CALL TURBKE(EPS2,VIST,VIS,OHMI,U,V,W,RO,D3,RK,REPS,DDEPS,SRK,
     2        SEPS,PTUR,VOL,A3,A3XA,A3YA,A3ZA,PR,PRT,IMAX,JMAX,KMAX,
     3        IN,JN,KN,KBOT,KTOP,KCP,LAMIN3,NBL,M,F1EPS,F1R,F1RM,ITURB,
     4        TURLIM,RKLIM,EPSLIM,CMU,C1,ISTR,JSTR,KSTR,
     5        KX1,KX2,KY1,KY2,IDIR2,ZZZ)

      ELSEIF(ITURB == 10) THEN  ! NON-ISOTROPIC SPEZIALE (ITURB = 10)

      CALL TURBSP(VIS,RO,D3,RK,REPS,SRK,SEPS,VOL,A3,A3XA,A3YA,A3ZA,
     2        F1R,IMAX,JMAX,KMAX,IN,JN,KN,KBOT,KTOP,KCP,CTA,
     3        ISTR,JSTR,KSTR,
     4        KX1,KX2,KY1,KY2,IDIR2)
      ENDIF                     !(ITURB /= 10)

      ENDIF                     !(KBOT /= 0 .OR. KTOP /= 0)
      ENDIF                     !(ITYP >= 8 ......)
      ENDDO                     ! L=1,NPATCH
      ENDIF                     !(LAMIN3 /= 0)

C ... Update the variabbles in inlets and outlets

      IF(M  == 1 ) THEN

      DO L = 1,NPATCH

      ITYP   = ICON(1,L)          ! Boundary type, 1=CON, 3=INL,5=OUT
      IF2    = IHF(ICON(2,L))     ! Starting address of this patch
      IFACE  = ICON(3,L)          ! Face number
      IBTYPE = ICON(8,L)          ! I/O specification
      IF(IBTYPE > 10 .AND. IBTYPE <= 20) IBTYPE = IBTYPE - 10
      IF(IBTYPE > 20 .AND. IBTYPE <= 30) IBTYPE = IBTYPE - 20

      IF(NSCAL == 0) THEN
         IQ2 = 1
      ELSE
         IQ2 = IF2
      ENDIF
      IF(ISTRES == 0) THEN ! Unused ??
         IE2 = 1
      ELSE
         IE2 = IF2
      ENDIF

      IF(IFACE <= 3) THEN 
         ILMO   =  1               ! Direction indicator
      ELSE IF(IFACE > 3) THEN
         ILMO   = -1
      ELSE
         STOP'Troubles with faces at FLXCYC'
      ENDIF

      DIRECTION          = (IFACE == IDIR .OR. IFACE == IDIR+3)
      INLETS_AND_OUTLETS = ((ITYP == 3 .AND. IBTYPE <= 6) .OR. 
     +                      (ITYP == 5 .AND. IBTYPE <= 5))

C ... Update inlets and outlets for standard flux calculation

      IF(INLETS_AND_OUTLETS .AND. DIRECTION) THEN ! Inlet or outlet patch

         KX1 = ICON(4,L)
         KX2 = ICON(5,L)
         KY1 = ICON(6,L)
         KY2 = ICON(7,L)

      IF(IDIR == 2) THEN
         KY1 = ICON(4,L)
         KY2 = ICON(5,L)
         KX1 = ICON(6,L)
         KX2 = ICON(7,L)
      ENDIF

       IF(IFACE <= 3) THEN
          KBOTOP = 1
       ELSE IF(IFACE == 4) THEN
          KBOTOP = IMAXRE
       ELSE IF(IFACE == 5) THEN
          KBOTOP = JMAXRE
       ELSE IF(IFACE == 6) THEN
          KBOTOP = KMAXRE
       ELSE
          STOP'Problems with faces in FLXCYC'
       ENDIF

C ... Define the variables at the inlets and outlets

      IF(ITYP == 3) THEN

      CALL INLET(P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,XC,YC,ZC,OHMI,
     2  S11,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,
     3  KY2,RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,CP,PRT,IFLUX,M,M2,IN,JN,KN,
     4  FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5  ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6  RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7  BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8  BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9  BOUNA1(IF2),BOUNA2(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,
     1  IPRINT,JSTATE,PRO,VAR,
c     1  IPRINT,JSTATE,TEMP1,TEMP2,ALFA1,ALFA2,X1,X2,RO1,RO2,
     2  BLKS(NBL)%NPHASE,IWAVEB,FRESUL,FRSSIE,RNUT,
     3  TRANSL,TRM,BOUNG(IF2),BOUNRET(IF2),PLE2,BOUNU1(IF2),
     4  BOUNU2(IF2),BOUNV1(IF2),BOUNV2(IF2),BOUNW1(IF2),BOUNW2(IF2),
     5  BLKS(NBL)%SOLUTION_TYPE,PRC)
      ENDIF ! ITYP == 3
       
      IF(ITYP == 5) THEN
      CALL OUTLET(P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,XC,YC,ZC,OHMI,
     2  S11,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,
     3  KY2,RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,CP,PRT,IFLUX,M,M2,IN,JN,KN,
     4  FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5  ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6  RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7  BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8  BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9  BOUNA1(IF2),BOUNA2(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,
     1  IPRINT,JSTATE,PRO,VAR,
c     1  IPRINT,JSTATE,TEMP1,TEMP2,ALFA1,ALFA2,X1,X2,RO1,RO2,
     2  BLKS(NBL)%NPHASE,IWAVEB,FRESUL,RNUT,
     3  TRANSL,TRM,BOUNG(IF2),BOUNRET(IF2),PLE2,BOUNU1(IF2),
     4  BOUNU2(IF2),BOUNV1(IF2),BOUNV2(IF2),BOUNW1(IF2),BOUNW2(IF2),
     5  BLKS(NBL)%SOLUTION_TYPE,IF2,PRC)
      ENDIF ! ITYP == 5

      ENDIF ! Inlets and outlets      
      ENDDO ! L = 1, NPATCH
      ENDIF ! M == 1

      IF(ITURB >= 21) THEN

C ... CALCULATE REPRODUCTION TERM WITH REYNOLDS-STRESS MODEL

          CALL REPROD(RO,U,V,W,RK,REPS,DDEPS,
     +     FI(1,1) , FI(1,2), FI(1,3), FI(1,4), FI(1,5), FI(1,6),VIS,
     +     SFI(1,1),SFI(1,2),SFI(1,3),SFI(1,4),SFI(1,5),SFI(1,6),OHMI,
     +     FWLL,D3,VOL,A3,A3XA,A3YA,A3ZA,IMAX,JMAX,KMAX,IMAXRE,
     +     JMAXRE,KMAXRE,JRDIS,JRPRE,IN,JN,KN,KBOT,KTOP,KCP,LAMIN3,
     +     F1RM,F1R,SOURL,ISTR,JSTR,KSTR,ZZZ)
      ENDIF

C     CALCULATE VISCOUS FLUXES OF K AND EPSILON WITH TWO-EQUATION MODELS
C **********************************************************************

      DO II = 1,NTOT ! Initialize these fluxes to zero
      F1R(II) = 0.
      F1RM(II)= 0.
      F1RN(II)= 0.
      F1RW(II)= 0.
      F1E(II) = 0.
      F1RK(II)= 0.
      F1EPS(II)=0.
      IF(FRESUL) F1H(II) = 0.
      ENDDO

      IF(MULPHL) THEN ! Initialize these fluxes to zero
      DO IPHASE = 1,NPHASES
      DO II = 1,NTOT
      VAR(II)%FRO(IPHASE) = 0.
      VAR(II)%FE(IPHASE)  = 0.
      ENDDO
      ENDDO

c      IF(BLKS(NBL)%SOLUTION_TYPE == 'MULTI') THEN !U's only for testing
      IF(MULPHL) THEN
      DO IPHASE = 1,NPHASES
      DO II = 1,NTOT
         VAR(II)%FRM(IPHASE) = 0.
         VAR(II)%FRN(IPHASE) = 0.
         VAR(II)%FRW(IPHASE) = 0.
         VAR(II)%FX(IPHASE)  = 0.

c         VAR(II)%U(IPHASE) = U(II)
c         VAR(II)%V(IPHASE) = V(II)
c         VAR(II)%W(IPHASE) = W(II)
      ENDDO
      ENDDO
      ENDIF
      ENDIF

      IF(TRANSL) THEN !Intermittency variables
      DO II = 1,NTOT
      TRM(II)%FG   = 0.
      TRM(II)%FRET = 0.
      ENDDO
      ENDIF

      IF(FULLNS .AND. M == 1) THEN  ! COMPLETE FLUXES FOR K-E/O

c      CALL FLKENS(F1E,F1RK,F1EPS,VOL,A3,A3XA,A3YA,A3ZA,RO,RK,REPS,
c     2        IMAXRE,JMAXRE,KMAXRE,IDM3,VIS,EPS2,VIST,FUN1,
c     3        DKDX,DKDY,DKDZ,DEPSDX,DEPSDY,DEPSDZ,
c     4        psigk1,psige1,PSIGK,PSIGE,KSTR,IDIR)

      CALL FLKEBL(F1E,F1RK,F1EPS,VOL,A3,A3XA,A3YA,A3ZA,D3,RO,RK,
     2        REPS,IMAXRE,JMAXRE,KMAXRE,IDM3,VIS,EPS2,VIST,FUN1,
     3        DKDX,DKDY,DKDZ,DEPSDX,DEPSDY,DEPSDZ,XC,YC,ZC,
     4        psigk1,psige1,PSIGK,PSIGE,KSTR,IDIR,
     5        BLKS(NBL)%IDIFF)

      ELSE   ! THIN-LAYER

      CALL FLUDKE(F1E,F1RK,F1EPS,VOL,A3,RO,RK,REPS,IMAXRE,JMAXRE,KMAXRE,
     2        IDM3,VIS,EPS2,VIST,FUN1,psigk1,psige1,PSIGK,PSIGE,
     3        KSTR,IDIR,BLKS(NBL)%IDIFF,TRANSL,TRM)

      ENDIF

C     CALCULATE VISCOUS FLUXES OF REYNOLDS STRESSES
C **********************************************************************

      IF(ITURB >= 21) THEN
          CALL DIFF(RO,RK,REPS,VIS,EPS2,VOL,A3,A3XA,A3YA,A3ZA,D3,
     +     FI(1,1), FI(1,2),FI(1,3),FI(1,4),FI(1,5),FI(1,6),
     +     F1FI(1,1),F1FI(1,2),F1FI(1,3),F1FI(1,4),F1FI(1,5),F1FI(1,6),
     +     DIF(1,1) ,DIF(1,2) ,DIF(1,3) ,DIF(1,4) ,DIF(1,5),DIF(1,6),
     +     VVIS(1,1),VVIS(1,2),VVIS(1,3),VVIS(1,4),VVIS(1,5),VVIS(1,6),
     +     IDM3,PSIGSC,PSIGS2,JRDIF,IMAXRE,JMAXRE,KMAXRE,
     +     SOURL,KSTR,IDIR,ICYCLE,ICMAX)
      ENDIF

      IF(ITURB >= 24) CALL ADDUUK(F1RK,F1FI,IMAX,JMAX,KMAX,MAXSB)
      CALL SETV12(F1E,F1RK,NTOT)    ! ADD DIFFUSION OF K TO ENERGY FLUX

C ... AND CALCULATE THE MAIN VISCOUS FLUXES WITH TWO-EQUATION MODELS
C **********************************************************************
        
      IF((ITURB <= 23).AND.((ITURB < 10).OR.(ITURB > 19))) THEN

      IF (FULLNS .AND. M == 1) THEN   
       
      CALL FLUXBL(F1R,F1RM,F1RN,F1RW,F1E,VOL,A3,XC,YC,ZC,RO,RM,RN,RW,
     2      P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,
     3      EPS2,VIST,W12,W13,W23,SS11,SS12,SS13,SS22,SS23,SS33,DTDX, 
     4      DTDY,DTDZ,D3,A3XA,A3YA,A3ZA,CP,PR,PRT,WROT,PRO,
     5      VAR,TEMP,CH,DRDH,DRDP,ISTATE,GAMMA,FRSDEN,FRSPRE,HAT1,HAT2,
     6      HAT3,HAT4,KSTR,IDIR,ITURB,MULPHL,BLKS(NBL)%IDIFF)
c      CALL FLUXNS(F1R,F1RM,F1RN,F1RW,F1E,VOL,A3,RO,RM,RN,RW,P,U,V,W,E,
c     2      C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,EPS2,VIST,
c     3      W12,W13,W23,SS11,SS12,SS13,SS22,SS23,SS33,DTDX,DTDY,DTDZ, 
c     4      A3XA,A3YA,A3ZA,PR,PRT,WROT,
c     5      TEMP,CH,DRDH,DRDP,ISTATE,GAMMA,FRSDEN,FRSPRE,
c     6      HAT1,HAT2,HAT3,HAT4,KSTR,IDIR,ITURB)
      ELSE

       IF(BLKS(NBL)%SOLUTION_TYPE == 'MULTI') THEN ! Two-fluid model
       CALL FLUXTF(F1R,F1RM,F1RN,F1RW,F1E,VOL,A3,RO,RM,RN,RW,P,U,V,W,E,
     2      C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,EPS2,VIST,
     3      A3XA,A3YA,A3ZA,CP,PR,PRT,WROT,PRO,VAR,TEMP,CH,DRDH,
     4      DRDP,ISTATE,GAMMA,FRSDEN,FRSPRE,HAT1,HAT2,HAT3,HAT4,KSTR,
     5      IDIR,MULPHL,BLKS(NBL)%NPHASE,FRESUL,FREDIF,F1H,WAVE,M,
     6      BLKS(NBL)%IDIFF,NBL)
       ELSE ! A traditional single phase or cavitation model
       CALL FLUXDO(F1R,F1RM,F1RN,F1RW,F1E,VOL,A3,RO,RM,RN,RW,P,U,V,W,E,
     2      C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,EPS2,VIST,
     3      A3XA,A3YA,A3ZA,CP,PR,PRT,WROT,PRO,VAR,TEMP,CH,DRDH,
     4      DRDP,ISTATE,GAMMA,FRSDEN,FRSPRE,HAT1,HAT2,HAT3,HAT4,KSTR,
     5      IDIR,MULPHL,BLKS(NBL)%NPHASE,FRESUL,FREDIF,F1H,WAVE,M,
     6      BLKS(NBL)%IDIFF)
       ENDIF
      ENDIF  ! FULLNS

C **********************************************************************
      ELSE ! WITH THE REYNOLDS STRESS MODEL

       CALL FLUXVV(F1R,F1RM,F1RN,F1RW,F1E,VOL,A3,RO,RM,RN,RW,P,U,V,W,E,
     2      C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,EPS2,VIST,
     3      A3XA,A3YA,A3ZA,PR,PRT,WROT,
     4      TEMP,CH,DRDH,DRDP,ISTATE,GAMMA,FRSDEN,FRSPRE,
     5      HAT1,HAT2,HAT3,HAT4,KSTR,IDIR)

      ENDIF  ! IF((ITURB <= ... 

C ... CORRECT THE K-EPSILON MODEL WITH REYNOLDS STRESSES IF ITURB = 24

      IF(ITURB == 24 .AND. IFLUX /= 5) THEN
       CALL FLUXIS(F1R,F1RM,F1RN,F1RW,F1E,RO,P,U,V,W,E,
     2      FI(1,1),FI(1,2),FI(1,3),FI(1,4),FI(1,5),FI(1,6),
     3      VOL,A3,A3XA,A3YA,A3ZA,INTERK,IDM3,IMAXRE,JMAXRE,KMAXRE,
     4      KMAXP,KSTR)
      ENDIF
C **********************************************************************

C ... CORRECT THE K-EPSILON MODEL WITH EARSM IF ITURB = 10

      IF(ITURB >= 10 .AND. ITURB <= 19) THEN
       CALL FLUXIS(F1R,F1RM,F1RN,F1RW,F1E,RO,P,U,V,W,E,
     2      S11(1,1),S11(1,2),S11(1,3),S11(1,4),S11(1,5),S11(1,6),
     3      VOL,A3,A3XA,A3YA,A3ZA,INTERK,IDM3,IMAXRE,JMAXRE,KMAXRE,
     4      KMAXP,KSTR)
      ENDIF

C     Viscous fluxes are updated. Add inviscid flux and EARSM
C **********************************************************************

      IF(IDIR == 3 .AND. KMAXRE == 1) THEN ! Axisymmetric (k-direction)
       
      IF(MULPHC /= 'MULTI') THEN     ! Homogeneous model
      IF(IFLUX == 4 .OR. IFLUX == 6 .OR. IFLUX == 7) THEN
      CALL FLUXA(F1RM,F1RN,F1RW,RO,RM,RN,RW,PDIFF,RK,BIJ,WROT,A3,A3XA,
     2  A3YA,A3ZA,IMAXRE,JMAXRE,KMAXRE,IJKSTR,JADD,KADD,MAXEB,ITURB,
     3  ISTRES,m2)
      ELSE
      CALL FLUXA(F1RM,F1RN,F1RW,RO,RM,RN,RW,P,RK,BIJ,WROT,A3,A3XA,
     2  A3YA,A3ZA,IMAXRE,JMAXRE,KMAXRE,IJKSTR,JADD,KADD,MAXEB,ITURB,
     3  ISTRES,m2)
      ENDIF ! IFLUX == 4
      ELSEIF(MULPHC == 'MULTI') THEN ! Two-fluid model
      F1RM(1:NTOT) = 0.;  F1RN(1:NTOT) = 0.;  F1RW(1:NTOT) = 0. 
      CALL FLUXAMF(F1RM,F1RN,F1RW,VAR,PRO,PDIFF,RK,BIJ,WROT,A3,A3XA,
     2  A3YA,A3ZA,IMAXRE,JMAXRE,KMAXRE,IJKSTR,JADD,KADD,MAXEB,ITURB,
     3  ISTRES,PRC)
      ENDIF ! MULPHC

      ELSE ! A normal case

C ... Correct the k-epsilon/omega model with the EARSM of Wallin-Johansson

      IF(ISTRES >= 1) THEN

      CALL ANISFLUX(IMAXRE,JMAXRE,KMAXRE,JADD,KADD,IJKSTR,U,V,W,RK,
     2     BIJ,A3,A3XA,A3YA,A3ZA,F1RM,F1RN,F1RW,F1E,MAXEB)
      ENDIF

C ... ADD THE INVISCID FLUX

      HAT1(1:NTOT) = 0.
      HAT2(1:NTOT) = 0.
      HAT3(1:NTOT) = 0.
      HAT4(1:NTOT) = 0.

      IF(IFLUX == 1) THEN  ! K-EPSILON BASED ROE'S SCHEME

       CALL FLUXKE(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,XXTRAL,RKSI,INCHIML,ENTROPY_FIX,TRANSL,TRM)

      IF(RJK2 > 0..AND.M == 1 .OR. RJK4 > 0..AND.M == 1) THEN
      CALL JAMESON(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,JSTATE,IPRESC,ARTSSP,XXTRAL,FRESUL,M,F1H,WAVE,FRSSIE,PRC,
     7  PSEUCO,RJK2,RJK4,SCALEJ)
      ENDIF

       ELSE IF(IFLUX == 4) THEN ! SIMPLIFIED INCOMPRESSIBLE SCHEME

       CALL DIVV12(RK,RK,RO,NTOT)
       CALL DIVV12(REPS,REPS,RO,NTOT)
       CALL FLUINC(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,JSTATE,IPRESC,ARTSSP,XXTRAL,FRESUL,M,F1H,WAVE,FRSSIE,PRC,
     7  PSEUCO,RKSI,INCHIML,NBL,TRANSL,TRM,BLKS(NBL)%FRSTEM,IUPPTL)
       CALL MULV12(RK,RO,NTOT)
       CALL MULV12(REPS,RO,NTOT)

      IF(RJK2 > 0..AND.M == 1 .OR. RJK4 > 0..AND.M == 1) THEN
      CALL JAMESON(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,JSTATE,IPRESC,ARTSSP,XXTRAL,FRESUL,M,F1H,WAVE,FRSSIE,PRC,
     7  PSEUCO,RJK2,RJK4,SCALEJ)
      ENDIF

C ... ROE'S SCHEME WITH FULLY COUPLED REYNOLDS STRESSES

       ELSE IF(IFLUX == 5) THEN
       CALL FLUXRE(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,PR,PRT,
     4  WROT,TEMP,CH,DRDH,DRDP,ISTATE,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  FRSVEL,HAT1,HAT2,HAT3,HAT4,
     6  F1FI(1,1),F1FI(1,2),F1FI(1,3),F1FI(1,4),F1FI(1,5),F1FI(1,6),
     7    FI(1,1),  FI(1,2),  FI(1,3),  FI(1,4),  FI(1,5),  FI(1,6),
     8  PSIGSC,PSIGS2,NSCAL,MAXSB,KMAXP,KSTR,IDIR,ZZZ,MAW,MAXW,RKSI,
     9  INCHIML)

       ELSE IF(IFLUX == 6) THEN  ! Multi-phase flow scheme 'CAVIT'

       CALL DIVV12(RK,RK,RO,NTOT)
       CALL DIVV12(REPS,REPS,RO,NTOT)
       CALL FLUMPH(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,PRO,VAR,A3XA,A3YA,A3ZA,D3,PR,PRT,
     4  WROT,TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,
     5  FRSPRE,RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,
     6  ZZZ,MAW,MAXW,JSTATE,IPRESC,ARTSSP,PSEUCO,RKSI,INCHIML,NBL,
     7  XC,YC,ZC,GRAVIL,BLKS(NBL)%SOLUTION_TYPE,BLKS(NBL)%FRSTEM,IUPPTL,
     8  INTEAK,PRC,BLKS(NBL)%FRADEN)
       CALL MULV12(RK,RO,NTOT)
       CALL MULV12(REPS,RO,NTOT)

       ELSE IF(IFLUX == 7) THEN ! Kurganov-Tadmor scheme

      CALL FLUXKT(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,XXTRAL,RKSI,INCHIML,ENTROPY_FIX,FRSSIE,PDIFF,PSEUCO,ARTSSP,
     7  NBL,BLKS(NBL)%FRSTEM,IUPPTL)
c     6  MAXW,XXTRAL,RKSI,INCHIML,ENTROPY_FIX) ! FLUXKT2

       ELSE IF(IFLUX == 8) THEN ! H-CUSP scheme

      CALL FLUCUSP(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,IN,JN,KN,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,XXTRAL,RKSI,INCHIML,ENTROPY_FIX,TRANSL,TRM)

      ENDIF ! INVISCID FLUX
      ENDIF ! AXISYMMETRIC FLUX

C **********************************************************************
      IF(IFLUX == 0)WRITE(*,*)'VAN LEER DOES NOT WORK WITK K-E OR K-O'

      IF(KSCAL /= 0) THEN ! Calculate scalar fluxes
         IF(ITURB <= 19) THEN 
C ... NOTE, NO SCALAR DIFFUSION EQS. WITH RSM IN THIS DIFFUSION VERSION
         CALL FLSCLD(RO,F1FI(1,KBEGIN),FI(1,KBEGIN),
     2        HAT1,HAT2,HAT3,HAT4,VOL,A3,PSIGSC(KBEGIN),PSIGS2(KBEGIN),
     3        IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,
     3        EPS2,A3XA,A3YA,A3ZA,PR,PRT,
     4        KSCAL,MAXSB,NBL,RLOLIM,FRSDEN,ITURB,
     5        KSTR,IDIR)
         ENDIF
         CALL FLSCAL(RO,F1FI(1,KBEGIN),FI(1,KBEGIN),
     1        HAT1,HAT2,HAT3,HAT4,VOL,A3,PSIGSC(KBEGIN),PSIGS2(KBEGIN),
     2        IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTETK,IDM3,VIS,
     3        EPS2,A3XA,A3YA,A3ZA,PR,PRT,
     4        KSCAL,MAXSB,NBL,RLOLIM,FRSDEN,ITURB,KMAXP,KSTR,
     5        IDIR,ZZZ,MAW,MAXW,RKSI,INCHIML)
      ENDIF                     ! KSCAL

C **********************************************************************



C ... NON-STANDARD FLUX CALCULATION AT THE BOUNDARIES. 
C ... NEEDS DIRECTION CHECK WITH IDIR

      DO 100 L = 1,NPATCH

      ITYP   = ICON(1,L)          ! Boundary type, 1=CON, 3=INL,5=OUT
      IF2    = IHF(ICON(2,L))     ! Starting address of this patch
      IBL    = ICON(8,L)          ! Face is connected with a global block IBL
      IBTYPE = ICON(8,L)          ! In a case of inlets/outlets (mersu)
      IFACE  = ICON(3,L)          ! Face number
      NFACN  = ICON(9,L)          ! Face number in the connected block
        
      KX1 = ICON(4,L)
      KX2 = ICON(5,L)
      KY1 = ICON(6,L)
      KY2 = ICON(7,L)

      IDIMP = IDIMS(L)
      JDIMP = JDIMS(L)

      IF(IDIR == 2) THEN
         KX1SAVE = KX1
         KX2SAVE = KX2
         KX1     = KY1
         KX2     = KY2
         KY1     = KX1SAVE
         KY2     = KX2SAVE
         JDIMP = IDIMS(L)
         IDIMP = JDIMS(L)
      ENDIF

      KBOT = 1
      IF(IDIR == 1) KTOP = IMAXRE
      IF(IDIR == 2) KTOP = JMAXRE
      IF(IDIR == 3) KTOP = KMAXRE

      IF(IFACE <= 3) THEN 
         ILMO   = 1            ! Direction indicator
         KBOTOP = KBOT
      ELSE IF(IFACE > 3) THEN
         ILMO   =-1
         KBOTOP = KTOP
      ELSE
         STOP'Troubles with faces at FLXCYC'
      ENDIF


      DIRECTION          = (IFACE == IDIR .OR. IFACE == IDIR+3)
      SOLID_WALL         = (ITYP >= 8    .AND. ITYP <= 10  .OR.
     &                      ITYP == 15)

      IF(ITYP == 3) THEN       ! An inlet type boundary
         INLETS_AND_OUTLETS = .TRUE.
         INLETS = .TRUE.
         INLOUT = 0
      ELSE IF(ITYP == 5) THEN  ! An outlet type boundary
         INLETS_AND_OUTLETS = .TRUE.
         INLETS = .FALSE.
         INLOUT = 0
       ELSE IF(ITYP == 1 .AND. ICON(20,L) == 2) THEN ! A periodic inlet
         INLETS_AND_OUTLETS = .TRUE.
         INLETS = .TRUE.
         INLOUT = 0
      ELSE IF(ITYP == 17) THEN                       ! A periodic inlet
         INLETS_AND_OUTLETS = .TRUE.                 ! for circulation of
         INLETS = .TRUE.                             ! the velocity
         INLOUT = 0
      ELSE IF(ITYP == 1 .AND.ICON(20,L) == 3) THEN   ! A periodic outlet
         INLETS_AND_OUTLETS = .TRUE.
         INLETS = .FALSE.
         INLOUT = 0
      ELSE                   ! Inactive boundary
         INLETS_AND_OUTLETS = .FALSE.
         INLETS = .FALSE.
      ENDIF


      IF(SOLID_WALL .AND. DIRECTION) THEN ! Solid wall
      
      IF(WALLFUNL) THEN
       
       KOKO    = (KY2-KY1+1)*(KX2-KX1+1)
       ALLOCATE(F2VWF(KOKO),F3VWF(KOKO),F4VWF(KOKO))
       RELAX = 0.9 ! To input?
       
       CALL WALLFUN(UTAUM(IF2),F2VWF,F3VWF,F4VWF,A3,A3XA,A3YA,A3ZA,
     2  VIS,VIST,EPS2,UWALL(IF2),VWALL(IF2),WWALL(IF2),TWALL(IF2),
     3  HFLUX(IF2),ISTRID,JSTRID,KSTRID,IDM3,ILMO,KBOTOP,KX1,KX2,
     4  KY1,KY2,ITURB,ISTR,JSTR,KSTR,IN,JN,KN,VOL,RO,RELAX,U,V,W,
     5  PTUR,REPS,EPSOLD,STRAIN,RBK(IF2),FUN1)
      ENDIF

       CALL BOTSKE(F1R,F1RM,F1RN,F1RW,F1E,P,U,V,W,C,E,VOL,A3,A3XA,A3YA,
     2    A3ZA,OHMI,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     3    PDIFF,PRO,VAR,KX1,KX2,KY1,KY2,CP,PR,PRT,RO,
     4    TOMEGA(L),IFLUX,CX(L),CY(L),CZ(L),CMX(L),CMY(L),CMZ(L),M,
     5    IN,JN,KN,XC,YC,ZC,RKLIM,XMOM,YMOM,ZMOM,ILMO,DX(L),DY(L),DZ(L),
     6    F1RK,F1EPS,RK,REPS,PTUR,WROT,TEMP,CH,QX(L),QY(L),QZ(L),FRSDEN,
     7    FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,
     8    KSTR,ICON(20,L),RCON(1,L),IDIS,PSIGK1,PSIGE1,PSIGK,PSIGE,
     9    UWALL(IF2),VWALL(IF2),WWALL(IF2),CPWALL(IF2),TWALL(IF2),
     +    QWALL(IF2),QWFRIC(IF2),HFLUX(IF2),TAUW1(IF2),TAUW2(IF2),
     1    TAUWX(IF2),TAUWY(IF2),TAUWZ(IF2),SURLE(IF2),DSURLE(IF2),
     2    WMFLUX(IF2),POROS(IF2),WHSTAG(IF2),WTEMP(IF2),RBK(IF2),
     3    RSDIRX(IF2),RSDIRY(IF2),RSDIRZ(IF2),SURFX(IF2),SURFY(IF2),
     4    SURFZ(IF2),XCP(IF2),YCP(IF2),ZCP(IF2),MAX11,CMU,XCO,YCO,ZCO,
     5    INTERK,INTETK,MULPHL,BLKS(NBL)%SOLUTION_TYPE,NBL,TURCOR,
     6    ICYCLE,FRESUL,F1H,IWAVEB,BUX(L),BUY(L),BUZ(L),VMXB(L),VMYB(L),
     7    VMZB(L),STRAIN,TRANSL,TRM,WAVE,SURFPX(IF2),SURFPY(IF2),
     8    SURFPZ(IF2),PRC,UTAUM(IF2),F2VWF,F3VWF,F4VWF,TURLIM)
     
       IF(WALLFUNL) DEALLOCATE(F2VWF,F3VWF,F4VWF)
     
       IF(NSCAL > 0) THEN
       CALL  BOSCAL(F1FI,VOL,A3,A3XA,A3YA,A3ZA,VIS,EPS2,
     2    PSIGSC,PSIGS2,ISTRID,JSTRID,KSTRID,IDM3,
     3    KBOTOP,KX1,KX2,KY1,KY2,PR,PRT,RO,
     4    M,IN,JN,KN,ILMO,FI,NSCAL,MAXSB,ITURB,
     5    ISTR,JSTR,KSTR)
       ENDIF

C ... Extend the solid patches into the ghost cells
 
      CALL EXTPAT(CPWALL(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TWALL(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( QWALL(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT(QWFRIC(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( HFLUX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUW1(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUW2(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUWX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUWY(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUWZ(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFY(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFZ(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFPX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFPY(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFPZ(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURLE(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT(DSURLE(IF2),KX1,KX2,KY1,KY2)

      ENDIF ! Solid wall and direction


C ... Create data on a mirror surface for output

      IF(ITYP == 4 .AND. DIRECTION) THEN

       INLOUT = 0
       CALL BOUMIR(F1R,F1RM,F1RN,F1RW,F1E,P,U,V,W,C,E,VOL,A3,A3XA,A3YA,
     2    A3ZA,OHMI,SS11,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     3    PDIFF,KX1,KX2,KY1,KY2,PR,PRT,RO,RM,RN,RW,CX(L),CY(L),CZ(L),
     4    DX(L),DY(L),DZ(L),CMX(L),CMY(L),CMZ(L),TOMEGA(L),IFLUX,M,M2,
     5    IN,JN,KN,XC,YC,ZC,RKLIM,ILMO,
     6    F1RK,F1EPS,RK,REPS,WROT,TEMP,CH,FRSDEN,
     7    FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,IDIS,
     9    XCP(IF2),YCP(IF2),ZCP(IF2),
     9    UWALL(IF2),VWALL(IF2),WWALL(IF2),CPWALL(IF2),TWALL(IF2),
     +    QWALL(IF2),QWFRIC(IF2),HFLUX(IF2),TAUW1(IF2),TAUW2(IF2),
     1    TAUWX(IF2),TAUWY(IF2),TAUWZ(IF2),SURLE(IF2),DSURLE(IF2),
     2    WMFLUX(IF2),POROS(IF2),WHSTAG(IF2),WTEMP(IF2),RBK(IF2),
     3    RSDIRX(IF2),RSDIRY(IF2),RSDIRZ(IF2),
     4    SURFX(IF2),SURFY(IF2),SURFZ(IF2),
     5    MAX11,XCO,YCO,ZCO,QMFIN,QMEIN,QMFOUT,
     6    QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,QVFIN,QVFOUT,
     7    INTERK,INTETK,NBL,INLOUT,XMOM,YMOM,ZMOM,
     8    CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,INLETS,l,
     9    BLKS(NBL)%CONVL,PRO,VAR,MULPHL,
     4    QGFIN,QGEIN,QGFOUT,QGEOUT,IDIMP,JDIMP,SURFPX(IF2),SURFPY(IF2),
     5    SURFPZ(IF2))
      ENDIF ! ITYP == 4 


C ... Calculate free-surface fluxes

      IF(ITYP == 13 .AND. DIRECTION .AND. IFSBC /= 3) THEN
     
       CALL BOTSFR(F1R,F1RM,F1RN,F1RW,F1E,PDIFF,P,U,V,W,C,E,VOL,A3,
     2    A3XA,A3YA,A3ZA,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     3    KX1,KX2,KY1,KY2,PR,PRT,RO,
     4    IFLUX,M,
     5    IN,JN,KN,RKLIM,ILMO,
     6    F1RK,F1EPS,WROT,TEMP,CH,FRSDEN,
     7    FRSPRE,FRSVEL,FRSVIS,T0,ITURB,ISTR,JSTR,
     8    KSTR,ICON(20,L),RCON(1,L),IDIS,TWALL(IF2),
     +    QWALL(IF2),HFLUX(IF2),XCP(IF2),YCP(IF2),ZCP(IF2),WMFLUX(IF2),
     1    CPWALL(IF2),SURLE(IF2),DSURLE(IF2),SURFX(IF2),SURFY(IF2),    
     5    SURFZ(IF2),INTERK,INTETK,IFSBC,nbl,HAT1,WAVE,SURFPX(IF2),
     6    SURFPY(IF2),SURFPZ(IF2))

       ENDIF ! Free surface
 
       IF(IFACE <= 3) THEN
          KBOTOP = 1
       ELSE IF(IFACE == 4) THEN
          KBOTOP = IMAXRE
       ELSE IF(IFACE == 5) THEN
          KBOTOP = JMAXRE
       ELSE IF(IFACE  == 6) THEN
          KBOTOP = KMAXRE
       ELSE
          STOP'Problems with faces in FLXCYC'
       ENDIF

C ... Correct the flux for pressure losses

      IF(ITYP == 1.AND.ICON(20,L) == 7 .AND. DIRECTION) THEN

       CALL MINOR_LOSS(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,
     1   WROT,POROS(IF2),RMLOSS(IF2),if2,WMFLUX(IF2),SURLE(IF2),
     2   DSURLE(IF2),XCP(IF2),YCP(IF2),ZCP(IF2),SURFX(IF2),SURFY(IF2),
     3   SURFY(IF2),CX(L),CY(L),CZ(L),CPWALL(IF2),SURFPX(IF2),
     4   SURFPY(IF2),SURFPZ(IF2))
      
      ENDIF ! Correct the flux for pressure losses

C ... Correct the flux for actuator discs

      IF(ITYP == 1 .AND. ICON(20,L) == 8 .AND. DIRECTION) THEN 

      IACTU = IGRID(ICON(24,L),3)

       IF(.NOT.ACTDISK) THEN

          WRITE(*,*) ' An actuator disk was found, but none was defined'
     1    ,' in FLIGHT-module. Exiting...'
          WRITE(4,*) ' An actuator disk was found, but none was',
     1    ' defined in FLIGHT-module. Exiting...'
          WRITE(13,*) ' An actuator disk was found, but none was',
     1    ' defined in FLIGHT-module.'
          WRITE(13,*) ' BLOCK=',NBL,' PATCH=',L, 'Exiting...'
          STOP '  ACTUATOR_FORCES'
       ENDIF

C ... Patria's PD-controller for THETA angles
      IF (IFA(IACTU) == 12 .OR. IFA(IACTU) == 13) THEN
         CALL SET_THETAS(IFA(IACTU),IACTU)
      ENDIF


      IF(ISCALE_ACT(IACTU,M2) == 0) THEN  ! Perform scaling only once

C ... Open water calculation routine
*       IF (SHIP.AND.IFA(IACTU) == 8 .OR. SHIP.AND.IFA(IACTU) == 10) THEN
       IF (SHIP .AND. (IFA(IACTU) == 8 .OR. IFA(IACTU) == 10)) THEN
          CALL TQIHM(IACTU,ICYCLE)
       ENDIF

C ... Thrust and torque distribution is normalized
       IF(IFA(IACTU) >= 7 .AND. IFA(IACTU) <= 10  .OR.
     &    IFT(IACTU) >= 7 .AND. IFT(IACTU) <= 10) THEN
c       OSKU(IGRID(ICON(24,L),3))%DAMPT = 1.0
c       OSKU(IGRID(ICON(24,L),3))%DAMPN = 1.0 

       CALL ACTUATOR_FORCES(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,
     1   WROT,POROS(IF2),RMLOSS(IF2),if2,WMFLUX(IF2),SURLE(IF2),
     2   DSURLE(IF2),XCP(IF2),YCP(IF2),ZCP(IF2),SURFX(IF2),SURFY(IF2),
     3   SURFZ(IF2),IACTU,TOMEGA(L),CX(L),CY(L),CZ(L),
     4   CMX(L),CMY(L),CMZ(L),SURFA(IF2),SURFT(IF2),SURF2X(IF2),
     5   SURF2Y(IF2),SURF2Z(IF2),SURFMX(IF2),SURFMY(IF2),SURFMZ(IF2))

       CALL ACTUATOR_SCALE(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,
     1   WROT,POROS(IF2),RMLOSS(IF2),if2,WMFLUX(IF2),SURLE(IF2),
     2   DSURLE(IF2),XCP(IF2),YCP(IF2),ZCP(IF2),SURFX(IF2),SURFY(IF2),
     3   SURFZ(IF2),DX(L),DY(L),DZ(L),CX(L),CY(L),CZ(L),CMX(L),
     4   CMY(L),CMZ(L),IACTU,CPWALL(IF2),TOMEGA(L),1,
     5   SURF2X(IF2),SURF2Y(IF2),SURF2Z(IF2),SURFMX(IF2),SURFMY(IF2),
     6   SURFMZ(IF2),IDIR2)

         ISCALE_ACT(IACTU,M2) = 1 ! Voi Mosse

      ENDIF !  IFA(IGRID(ICON(24,L),3)) ...
      ENDIF !  Scaling

C ... Normal actuator disk calculation
       CALL ACTUATOR_FORCES(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,
     1   WROT,POROS(IF2),RMLOSS(IF2),if2,WMFLUX(IF2),SURLE(IF2),
     2   DSURLE(IF2),XCP(IF2),YCP(IF2),ZCP(IF2),SURFX(IF2),SURFY(IF2),
     3   SURFZ(IF2),IACTU,TOMEGA(L),CX(L),CY(L),CZ(L),
     4   CMX(L),CMY(L),CMZ(L),SURFA(IF2),SURFT(IF2),SURF2X(IF2),
     5   SURF2Y(IF2),SURF2Z(IF2),SURFMX(IF2),SURFMY(IF2),SURFMZ(IF2))

       CALL ACTUATOR_DISC(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,
     1   WROT,POROS(IF2),RMLOSS(IF2),if2,WMFLUX(IF2),SURLE(IF2),
     2   DSURLE(IF2),XCP(IF2),YCP(IF2),ZCP(IF2),SURFX(IF2),SURFY(IF2),
     3   SURFZ(IF2),DX(L),DY(L),DZ(L),CX(L),CY(L),CZ(L),CMX(L),
     4   CMY(L),CMZ(L),IACTU,CPWALL(IF2),TOMEGA(L),0,
     5   SURF2X(IF2),SURF2Y(IF2),SURF2Z(IF2),SURFMX(IF2),SURFMY(IF2),
     6   SURFMZ(IF2),IDIR2)


      ENDIF ! Correct the flux for actuator discs

C ... Calculate inlets and outlets

      IF(INLETS_AND_OUTLETS .AND. DIRECTION) THEN ! Inlet or outlet

       IF(IBTYPE > 10 .AND. IBTYPE <= 20) IBTYPE = IBTYPE - 10
       IF(IBTYPE > 20 .AND. IBTYPE <= 30) IBTYPE = IBTYPE - 20

       IF(IFACE <= 3) THEN
          KBOTOP = 1
       ELSE IF(IFACE == 4) THEN
          KBOTOP = IMAXRE
       ELSE IF(IFACE == 5) THEN
          KBOTOP = JMAXRE
       ELSE IF(IFACE == 6) THEN
          KBOTOP = KMAXRE
       ELSE
          STOP'Problems with faces in FLXCYC'
       ENDIF

C ... Recalculate the inlet and outlet fluxes and update ghost cells on 
C ... the first level. (Flux-based boundary conditions).

      IF(IBTYPE > 6) THEN  ! A flux-based boundary calculation (recalculated)

       IF(ITYP == 3) THEN

       CALL INFLO(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,
     1   HAT1)
   
       ENDIF      

       IF(ITYP == 5) THEN
       CALL OUTFLO      
       ENDIF      

      ENDIF ! IBTYPE > 6

C ... Periodic recalculation only for an incompressible flux (FLUINC)
C ... This should follow more accurately the target mass-flow value

      IF(IFLUX == 4 .AND. M == 1) THEN

      KOKO    = (KX2-KX1+1)*(KY2-KY1+1) ! Is this needed?

       CALL DIVV12(RK,RK,RO,NTOT)
       CALL DIVV12(REPS,REPS,RO,NTOT)

       IF(ITYP == 1.AND.ICON(20,L) == 2.AND.BLKS(NBL)%INLRC > 0 .OR.! Periodic
     1    ITYP == 17.AND.ICON(20,L) == 2.AND.BLKS(NBL)%INLRC > 0.OR.! Cycling
     2    ITYP == 3.AND.BLKS(NBL)%INLRC > 0)                   THEN ! Inlet

C ... Inflow surface

       CALL INFPER(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,1,
     3   KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,ZZZ,
     1   RKSI,D3,WROT,HAT1,HAT2,HAT3,HAT4,XXTRAL,
     2   INCHIML,KOKO,MAXW,IMAX,JMAX,KMAX,NBL,ITYP,BLKS(NBL)%INLRC,1,
     3   ARTSSP,PSEUCO,BLKS(NBL)%FRSTEM,IUPPTL)
   
       ENDIF      


       IF(ITYP == 1.AND.ICON(20,L) == 3.AND.BLKS(NBL)%OUTRC > 0 .OR.! Periodic
     1    ITYP == 17.AND.ICON(20,L) == 3.AND.BLKS(NBL)%OUTRC > 0.OR.! Cycling
     2    ITYP == 5.AND.BLKS(NBL)%OUTRC > 0)                   THEN ! Outlet

C ... Outflow surface

       CALL INFPER(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     2   KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,ZZZ,
     1   RKSI,D3,WROT,HAT1,HAT2,HAT3,HAT4,XXTRAL,
     2   INCHIML,KOKO,MAXW,IMAX,JMAX,KMAX,NBL,ITYP,BLKS(NBL)%INLRC,2,
     3   ARTSSP,PSEUCO,BLKS(NBL)%FRSTEM,IUPPTL)
   
      ENDIF ! ITYP == 1 (Periodic)

       CALL MULV12(RK,RO,NTOT)
       CALL MULV12(REPS,RO,NTOT)

      ENDIF ! IFLUX == 4


C ... Integrate inlet and outlet flows for output
            
       CALL BOUFLO(F1R,F1RM,F1RN,F1RW,F1E,P,U,V,W,C,E,VOL,A3,A3XA,A3YA,
     2    A3ZA,OHMI,SS11,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     3    PDIFF,KX1,KX2,KY1,KY2,PR,PRT,RO,RM,RN,RW,CX(L),CY(L),CZ(L),
     4    DX(L),DY(L),DZ(L),CMX(L),CMY(L),CMZ(L),TOMEGA(L),IFLUX,M,M2,
     5    IN,JN,KN,XC,YC,ZC,RKLIM,ILMO,
     6    F1RK,F1EPS,RK,REPS,WROT,TEMP,CH,FRSDEN,
     7    FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,IDIS,
     9    XCP(IF2),YCP(IF2),ZCP(IF2),
     9    UWALL(IF2),VWALL(IF2),WWALL(IF2),CPWALL(IF2),TWALL(IF2),
     +    QWALL(IF2),QWFRIC(IF2),HFLUX(IF2),TAUW1(IF2),TAUW2(IF2),
     1    TAUWX(IF2),TAUWY(IF2),TAUWZ(IF2),SURLE(IF2),DSURLE(IF2),
     2    WMFLUX(IF2),POROS(IF2),WHSTAG(IF2),WTEMP(IF2),RBK(IF2),
     3    RSDIRX(IF2),RSDIRY(IF2),RSDIRZ(IF2),
     4    SURFX(IF2),SURFY(IF2),SURFZ(IF2),
     5    MAX11,XCO,YCO,ZCO,QMFIN,QMEIN,QMFOUT,
     6    QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,QVFIN,QVFOUT,
     7    INTERK,INTETK,NBL,INLOUT,XMOM,YMOM,ZMOM,
     8    CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,INLETS,l,
     9    BLKS(NBL)%CONVL,PRO,VAR,MULPHL,QGFIN,QGEIN,QGFOUT,QGEOUT,
     1    ICYCLE,IPRINT,NSCAL,ISTRES,BLKS(NBL)%NPHASE,TRANSL,TRM,
     2    BOUNG,BOUNRET,BIJ,MAXSB,MAXEB,ICMAX,SURFPX(IF2),SURFPY(IF2),
     3    SURFPZ(IF2),QLFIN,QLEIN,QLFOUT,QLEOUT)

C ... Extend the patches into the ghost cells

      IF(INLOUT == 0) THEN ! Extend i/o surface patches
         CALL EXTPAT(CPWALL(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TWALL(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( QWALL(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT(QWFRIC(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( HFLUX(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TAUW1(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TAUW2(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TAUWX(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TAUWY(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TAUWZ(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFX(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFY(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFZ(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFPX(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFPY(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFPZ(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURLE(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT(DSURLE(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT(WMFLUX(IF2),KX1,KX2,KY1,KY2)
      ENDIF ! I/o surface patches
      ENDIF ! Inlets and outlets      

 100  CONTINUE

      RETURN
      END SUBROUTINE FLXCYC
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE FLUCYC(NBL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,CP,
     + A3,D3,A3XA,A3YA,A3ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VIS,TEMP,EPS2,VIST,
     + W12,W13,W23,S11,S12,S13,S22,S23,S33,DTDX,DTDY,DTDZ, 
     + RGAS,GAMMA,E0REF,T0REF,DRO,DM,DN,DW,DE,VOL,OHMI,KCP,
     + IMAX,JMAX,KMAX,IN,JN,KN,ISTRID,JSTRID,KSTRID,ICYCLE,ICMAX,INTERK,
     + IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,KBOT,KTOP,IFLUX,
     + WROT,IDM3,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,ITURB,
     + HAT1,HAT2,HAT3,HAT4,RLOLIM,UBK,VBK,WBK,UTK,VTK,WTK,
     + IMAXRE,JMAXRE,KMAXRE,INRE,JNRE,KNRE,KMAXP,
     + ISTR,JSTR,KSTR,IDIR,FULLNS,ZZZ,MAXW,
     + XCO,YCO,ZCO,QMFIN,QVFIN,QMEIN,QMFOUT,QVFOUT,QMEOUT,
     + QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,
     + CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,
     + BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,
     + BOUNA1,BOUNA2,IBF,PRO,VAR,PRC,BLKS,MULPHL,JSTATE,IPRESC,XXTRAL,
     + FRESUL,F1H,WAVE,IFSBC,IWAVEB,FREDIF,BUX,BUY,BUZ,VMXB,VMYB,VMZB,
     + FRSSIE,RK,REPS,RNUT,STRAIN,PSEUCO,RJK2,RJK4,SCALEJ,RKSI,INCHIML,
     + ENTROPY_FIX,QGFIN,QGEIN,QGFOUT,
     + QGEOUT,TRM,TRANSL,BOUNG,BOUNRET,PLE2,PTUR,IDIMS,JDIMS,IUPPTL,
     + BOUNU1,BOUNU2,BOUNV1,BOUNV2,BOUNW1,BOUNW2,SURFPX,SURFPY,SURFPZ,
     + QLFIN,QLEIN,QLFOUT,QLEOUT,UTAUM,EPSOLD)

      USE TYPE_ARRAYS
      USE CHARACTERS
      USE CONSTANTS, ONLY : EPS, PII, SRNU
      USE NS3CO, ONLY : IC9, WALLFUNL

      IMPLICIT NONE

      INTEGER :: IHF(*),KCP(*),ICON(IC9,*),JSTATE(*),
     2           IWAVEB(*),IDIMS(*),JDIMS(*)

      INTEGER :: NBL,M,M2,IMAX,JMAX,KMAX,IN,JN,KN,ISTRID,JSTRID,KSTRID,
     2 ICYCLE,INTERK,IT,IL,IK,IPRINT,NPATCH,KBOT,KTOP,IFLUX,IDM3,
     3 ISTATE,MAXSB,NSCAL,ITURB,IMAXRE,JMAXRE,KMAXRE,KMAXP,ISTR,JSTR,
     4 KSTR,IDIR,MAXW,NTOT,MAW,IJKSTR,IADD,JADD,KADD,MAXEB,L,ISTRES,
     5 ITYP,IF2,IBL,IBTYPE,IFACE,NFACN,KX1,KX2,KY1,KY2,ILMO,KBOTOP,
     6 IDM3Q,INLOUT,IQ2,MAX11,INTETK,MAXSS,IBF,IDIS,IPRESC,IFSBC,III,
     7 KX11,KX22,KY11,KY22,KOKO,IDIMP,JDIMP,ICMAX,IUPPTL,
     8 INRE,JNRE,KNRE

      REAL :: RO(*),RM(*),RN(*),E(*),P(*),PDIFF(*),U(*),V(*),C(*),
     2 A3(*),A3XA(*),A3YA(*),A3ZA(*),DRO(*),DM(*),DN(*),DE(*),VOL(*),
     3 F1R(*),F1RM(*),F1RN(*),F1E(*),F1RW(*),CH(*),TEMP(*),
     4 VIS(*),EPS2(*),VIST(*),CP(*),
     5 UBK(*),VBK(*),WBK(*),UTK(*),VTK(*),WTK(*),
     6 UWALL(*),VWALL(*),WWALL(*),CPWALL(*),TWALL(*),QWALL(*),
     7 QWFRIC(*),TAUW1(*),TAUW2(*),SURFX(*),SURFY(*),SURFZ(*),
     8 TAUWX(*),TAUWY(*),TAUWZ(*),SURLE(*),DSURLE(*),WMFLUX(*),
     9 POROS(*),WHSTAG(*),WTEMP(*),RSDIRX(*),RSDIRY(*),RSDIRZ(*),
     1 RBK(*),HFLUX(*),
     2 RW(*),W(*),DW(*),D3(*),OHMI(*),WROT(*),DTDX(*),DTDY(*),DTDZ(*),
     3 DRDH(*),DRDP(*),PSIGSC(*),PSIGS2(*),RCON(IC9,*),
     4 FI(MAXSB,MAX(1,NSCAL)),F1FI(MAXSB,MAX(1,NSCAL)),
     5 DFI(MAXSB,MAX(1,NSCAL)),SFI(MAXSB,MAX(1,NSCAL)),
     6 HAT1(*),HAT2(*),HAT3(*),HAT4(*),
     7 RLOLIM(*),F1RK(*),F1EPS(*),CX(*),CY(*),CZ(*),CMX(*),
     8 CMY(*),CMZ(*),DX(*),DY(*),DZ(*),QX(*),QY(*),QZ(*),TOMEGA(*),
     9 W12(*),W13(*),W23(*),S11(*),S12(*),S13(*),S22(*),S23(*),S33(*),
     1 ZZZ(*),BOUNR(*),BOUNU(*),BOUNV(*),
     2 BOUNW(*),BOUNE(*),BOUNT(*),BOUNRK(*),BOUNEP(*),BOUNFI(IBF,*),
     3 BOUNBI(IBF,*),BOUNP(*),BOUNPD(*),BOUNMF(*),BOUNA1(*),BOUNA2(*),
     4 F1H(*),WAVE(*),BUX(*),BUY(*),BUZ(*),VMXB(*),VMYB(*),VMZB(*),
     5 REPS(*),RNUT(*),STRAIN(*),SCALEJ(*),RKSI(*),BOUNG(*),BOUNRET(*),
     6 PLE2(*),BOUNU1(*),BOUNU2(*),BOUNV1(*),BOUNV2(*),BOUNW1(*),
     7 BOUNW2(*),SURFPX(*),SURFPY(*),SURFPZ(*),UTAUM(*),EPSOLD(*)

      REAL :: RK(*),BIJ(1,1),SS11(1,1) ! Dummy with algebraic model, mersu

      REAL :: PSIGK1,PSIGE1,PSIGK,PSIGE,CMU,PTUR(*) ! Dummy

      REAL :: RGAS,GAMMA,E0REF,T0REF,PR,PRT,OMEGA,
     2 FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,FRSDEN,QMFIN,
     3 QMEIN,QMFOUT,QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,
     4 CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,RKLIM,EPSLIM,TURLIM,
     5 QVFIN,QVFOUT,ARTSSP,FREDIF,FRSSIE,PSEUCO,RJK2,RJK4,QGFIN,QGEIN,
     6 QGFOUT,QGEOUT,QLFIN,QLEIN,QLFOUT,QLEOUT,RELAX

      REAL :: XCO(*), YCO(*), ZCO(*), XC(*), YC(*), ZC(*),
     2                    XCP(*), YCP(*), ZCP(*)

      REAL :: XMOM,YMOM,ZMOM

      LOGICAL :: FULLNS,SOLID_WALL,DIRECTION,INLETS,INLETS_AND_OUTLETS,
     2 MULPHL,XXTRAL,FRESUL,INCHIML,ENTROPY_FIX,TRANSL

      REAL,ALLOCATABLE :: F2VWF(:),F3VWF(:),F4VWF(:),FUNNY1(:)

      TYPE(PROPERTIES)       :: PRO(*)
      TYPE(MPHASE_VARIABLES) :: VAR(*)
      TYPE(BLOCKS)           :: BLKS(*)
      TYPE(PRE_COR)          :: PRC(*)
      TYPE(INTERMITTENCY)    :: TRM(*)

C ... FLUXES WITH ALGEBRAIC TURBULENCE MODELS

      NTOT   = ISTRID*JSTRID*KSTRID
      RKLIM  = 0.
      EPSLIM = 0.

*      CALL DOMAW(MAXW,IMAXRE,JMAXRE,MAW)
      CALL DOMAW(MAXW,IMAXRE,JMAXRE,INRE,JNRE,MAW)

      IF(IDIR == 1) THEN
        IJKSTR = ISTR
        IADD   = 1
        JADD   = 0
        KADD   = 0
      ELSE IF(IDIR == 2) THEN
        IJKSTR = JSTR
        IADD   = 0
        JADD   = 1
        KADD   = 0
      ELSE IF(IDIR == 3) THEN
        IJKSTR = KSTR
        IADD   = 0
        JADD   = 0
        KADD   = 1
      ELSE
        STOP 'In FLUCYC'
      ENDIF
       
      CALL ZEROZZ(F1R,  NTOT)
      CALL ZEROZZ(F1RM, NTOT)
      CALL ZEROZZ(F1RN, NTOT)
      CALL ZEROZZ(F1RW, NTOT)
      CALL ZEROZZ(F1E,  NTOT)
      CALL ZEROZZ(F1EPS,NTOT)   
      IF(FRESUL) F1H(1:NTOT) = 0.

      ARTSSP = BLKS(NBL)%ARTSSP

C ... Default values for the dummy variables

      PSIGK1 = 0.
      PSIGE1 = 0.
      PSIGK  = 0.
      PSIGE  = 0.
      CMU    = 0.
      PTUR(1)= 0.
 
      IF(M == 1) THEN
         
**********************************************************************

C ... Update the inlet and outlet surfaces
     
      DO L = 1,NPATCH

      ITYP   = ICON(1,L)          ! Boundary type, 1=CON, 3=INL,5=OUT
      IF2    = IHF(ICON(2,L))     ! Starting address of this patch
      IFACE  = ICON(3,L)          ! Face number
      IBTYPE = ICON(8,L)          ! I/O specification

      IF(IBTYPE > 10 .AND. IBTYPE <= 20) IBTYPE = IBTYPE - 10
      IF(IBTYPE > 20 .AND. IBTYPE <= 30) IBTYPE = IBTYPE - 20

      IF(NSCAL == 0) THEN
         IQ2 = 1
      ELSE
         IQ2 = IF2
      ENDIF

      MAX11  = 1 ! Unused
      INTETK = 1 ! Discretization of turbulence variables, unused
      MAXEB  = 1 ! Size of the BIJ array, unused
      MAXSS  = 1 ! Size of the SS11 array, unused
      TURLIM = 1.E-6 ! Unused
      IDIS   = 0

      IF(IFACE <= 3) THEN 
         ILMO =  1               ! Direction indicator
      ELSE IF(IFACE > 3) THEN
         ILMO = -1
      ELSE
         STOP'Troubles with faces at FLUCYC'
      ENDIF

      DIRECTION          = (IFACE == IDIR .OR. IFACE == IDIR+3)
      INLETS_AND_OUTLETS = ((ITYP == 3 .AND. IBTYPE <= 6) .OR. 
     +                      (ITYP == 5 .AND. IBTYPE <= 5))

C ... Update inlets and outlets for standard flux calculation
     
      IF(INLETS_AND_OUTLETS .AND. DIRECTION) THEN ! Inlet or outlet patch

         KX1 = ICON(4,L)
         KX2 = ICON(5,L)
         KY1 = ICON(6,L)
         KY2 = ICON(7,L)

      IF(IDIR == 2) THEN
         KY1 = ICON(4,L)
         KY2 = ICON(5,L)
         KX1 = ICON(6,L)
         KX2 = ICON(7,L)
      ENDIF

       IF(IFACE <= 3) THEN
          KBOTOP = 1
       ELSE IF(IFACE == 4) THEN
          KBOTOP = IMAXRE
       ELSE IF(IFACE == 5) THEN
          KBOTOP = JMAXRE
       ELSE IF(IFACE == 6) THEN
          KBOTOP = KMAXRE
       ELSE
          STOP'Problems with faces in FLUCYC'
       ENDIF

C ... Define the variables at the inlets and outlets

      IF(ITYP == 3) THEN

      ISTRES = 0   ! Not defined in laminar flow   

      CALL INLET(P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,XC,YC,ZC,OHMI,
     2  S11,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,
     3  KY2,RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,CP,PRT,IFLUX,M,M2,IN,JN,KN,
     4  FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5  ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6  RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7  BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8  BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9  BOUNA1(IF2),BOUNA2(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,
     1  IPRINT,JSTATE,PRO,VAR,BLKS(NBL)%NPHASE,IWAVEB,FRESUL,FRSSIE,
     2  RNUT,TRANSL,TRM,BOUNG(IF2),BOUNRET(IF2),PLE2,BOUNU1(IF2),
     4  BOUNU2(IF2),BOUNV1(IF2),BOUNV2(IF2),BOUNW1(IF2),BOUNW2(IF2),
     5  BLKS(NBL)%SOLUTION_TYPE,PRC)
      ENDIF ! ITYP == 3

      IF(ITYP == 5) THEN

      ISTRES = 0

      CALL OUTLET(P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,XC,YC,ZC,OHMI,
     2  S11,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,
     3  KY2,RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,CP,PRT,IFLUX,M,M2,IN,JN,KN,
     4  FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5  ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6  RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7  BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8  BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9  BOUNA1(IF2),BOUNA2(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,
     1  IPRINT,JSTATE,PRO,VAR,BLKS(NBL)%NPHASE,IWAVEB,FRESUL,RNUT,
     2  TRANSL,TRM,BOUNG(IF2),BOUNRET(IF2),PLE2,BOUNU1(IF2),
     4  BOUNU2(IF2),BOUNV1(IF2),BOUNV2(IF2),BOUNW1(IF2),BOUNW2(IF2),
     5  BLKS(NBL)%SOLUTION_TYPE,IF2,PRC)
      ENDIF ! ITYP == 5
                      
      ENDIF ! Inlets and outlets      
      ENDDO ! L = 1, NPATCH
      ENDIF ! M == 1
C ... CALCULATE THE DIFFUSION FLUX

C *********************************************************************
      IF(FULLNS .AND. M == 1) THEN
c       write(6,*) 'vai ei vaikuta'
c       CALL FLUXNS(F1R,F1RM,F1RN,F1RW,F1E,VOL,A3,RO,RM,RN,RW,P,U,V,W,E,
c     2      C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,EPS2,VIST,
c     3      W12,W13,W23,S11,S12,S13,S22,S23,S33,DTDX,DTDY,DTDZ, 
c     4      A3XA,A3YA,A3ZA,PR,PRT,WROT,
c     5      TEMP,CH,DRDH,DRDP,ISTATE,GAMMA,FRSDEN,FRSPRE,
c     6      HAT1,HAT2,HAT3,HAT4,KSTR,IDIR,ITURB)

      CALL FLUXBL(F1R,F1RM,F1RN,F1RW,F1E,VOL,A3,XC,YC,ZC,RO,RM,RN,RW,
     2      P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,
     3      EPS2,VIST,W12,W13,W23,S11,S12,S13,S22,S23,S33,DTDX, 
     4      DTDY,DTDZ,D3,A3XA,A3YA,A3ZA,CP,PR,PRT,WROT,PRO,
     5      VAR,TEMP,CH,DRDH,DRDP,ISTATE,GAMMA,FRSDEN,FRSPRE,
     6      HAT1,HAT2,HAT3,HAT4,KSTR,IDIR,ITURB,MULPHL,BLKS(NBL)%IDIFF)
       ELSE

       CALL FLUXDO(F1R,F1RM,F1RN,F1RW,F1E,VOL,A3,RO,RM,RN,RW,P,U,V,W,E,
     2      C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,EPS2,VIST,
     3      A3XA,A3YA,A3ZA,CP,PR,PRT,WROT,PRO,VAR,TEMP,CH,DRDH,
     4      DRDP,ISTATE,GAMMA,FRSDEN,FRSPRE,HAT1,HAT2,HAT3,HAT4,KSTR,
     5      IDIR,MULPHL,BLKS(NBL)%NPHASE,FRESUL,FREDIF,F1H,WAVE,M,
     6      BLKS(NBL)%IDIFF)
      ENDIF ! FULLNS

      IF(ITURB == 9) THEN ! Spalart-Allmaras (thin-layer)
       CALL FLSCSA(RO,F1EPS,REPS,VOL,A3,SRNU,IMAXRE,JMAXRE,KMAXRE,
     2      ICYCLE,INTERK,IDM3,VIS,NBL,FRSDEN,ITURB,KSTR,
     3      IDIR)
      ENDIF


C ... INVISCID FLUX IS ADDED
C *********************************************************************
C     Viscous fluxes are updated. Add inviscid flux
C **********************************************************************
     
      IF(IDIR == 3 .AND. KMAXRE == 1) THEN ! Axisymmetric
       
      IF(IFLUX == 4 .OR. IFLUX == 7) THEN
      CALL FLUXA(F1RM,F1RN,F1RW,RO,RM,RN,RW,PDIFF,RK,F1R,WROT,A3,A3XA,
     2  A3YA,A3ZA,IMAXRE,JMAXRE,KMAXRE,IJKSTR,JADD,KADD,MAXEB,ITURB,
     3  ISTRES,m2)
      ELSE
      CALL FLUXA(F1RM,F1RN,F1RW,RO,RM,RN,RW,P,RK,F1R,WROT,A3,A3XA,
     2  A3YA,A3ZA,IMAXRE,JMAXRE,KMAXRE,IJKSTR,JADD,KADD,MAXEB,ITURB,
     3  ISTRES,m2)
      ENDIF ! IFLUX == 4

      ELSE ! A normal case
     
      IF(IFLUX == 1) THEN       ! ROE'S FLUX-DIFFERENCE SPLITTING
       CALL FLUXKE(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,9,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,XXTRAL,RKSI,INCHIML,ENTROPY_FIX,TRANSL,TRM)

      IF(RJK2 > 0..AND.M == 1 .OR. RJK4 > 0..AND.M == 1) THEN
      CALL JAMESON(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,JSTATE,IPRESC,ARTSSP,XXTRAL,FRESUL,M,F1H,WAVE,FRSSIE,PRC,
     7  PSEUCO,RJK2,RJK4,SCALEJ)
      ENDIF

       ELSE IF(IFLUX == 0) THEN ! VAN LEER'S FLUX-VECTOR SPLITTING
       CALL FLUXVL(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,
     3  EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,PR,PRT,
     4  WROT,TEMP,CH,DRDH,DRDP,ISTATE,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,RKSI,INCHIML)

       ELSE IF(IFLUX == 2) THEN ! WAVE/PARTICLE SPLIT (WPS) SCHEME
       CALL FLUXWP(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,
     3  EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,PR,PRT,
     4  WROT,TEMP,CH,DRDH,DRDP,ISTATE,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,RKSI,INCHIML)

       ELSE IF(IFLUX == 3) THEN ! WPS / AUSM-IMPLEMETATION SCHEME
       CALL FLUXAU(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,
     3  EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,PR,PRT,
     4  WROT,TEMP,CH,DRDH,DRDP,ISTATE,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,RKSI,INCHIML)

       ELSE IF(IFLUX == 4) THEN ! SIMPLIFIED INCOMPRESSIBLE SCHEME  
       CALL PRIMVE(U,V,W,RK,RO,E,XC,YC,ZC,NTOT,FRSDEN,ITURB)
       IF(ITURB ==  9) CALL DIVV12(REPS,REPS,RO,NTOT) ! Spalart-Allmaras
       CALL FLUINC(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,9,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,JSTATE,IPRESC,ARTSSP,XXTRAL,FRESUL,M,F1H,WAVE,FRSSIE,PRC,
     7  PSEUCO,RKSI,INCHIML,NBL,TRANSL,TRM,BLKS(NBL)%FRSTEM,IUPPTL)
      IF(RJK2 > 0..AND.M == 1 .OR. RJK4 > 0..AND.M == 1) THEN
      CALL JAMESON(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,JSTATE,IPRESC,ARTSSP,XXTRAL,FRESUL,M,F1H,WAVE,FRSSIE,PRC,
     7  PSEUCO,RJK2,RJK4,SCALEJ)
      ENDIF
       IF(ITURB == 9) CALL MULV12(REPS,RO,NTOT) ! Spalart-Allmaras
       CALL CONSVE(E,U,V,W,RK,RO,XC,YC,ZC,NTOT,ITURB,FI,MAXSB,NSCAL)

      ELSE IF(IFLUX == 7) THEN ! KURGANOV-TADMOR SCHEME  
      CALL FLUXKT(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,XXTRAL,RKSI,INCHIML,ENTROPY_FIX,FRSSIE,PDIFF,PSEUCO,ARTSSP,
     7  NBL,BLKS(NBL)%FRSTEM,IUPPTL)

       ELSE IF(IFLUX == 8) THEN ! H-CUSP scheme

      CALL FLUCUSP(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,VOL,A3,RO,RM,RN,RW,
     2  RK,REPS,P,U,V,W,E,C,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,INTETK,
     3  IDM3,VIS,EPS2,VIST,PDIFF,A3XA,A3YA,A3ZA,D3,PR,PRT,IN,JN,KN,WROT,
     4  TEMP,CH,DRDH,DRDP,ISTATE,RGAS,GAMMA,E0REF,T0REF,FRSDEN,FRSPRE,
     5  RKLIM,EPSLIM,HAT1,HAT2,HAT3,HAT4,KMAXP,KSTR,IDIR,ITURB,ZZZ,MAW,
     6  MAXW,XXTRAL,RKSI,INCHIML,ENTROPY_FIX,TRANSL,TRM)

      ENDIF

      ENDIF ! IDIR == 3 .AND. KMAXRE == 1

C ... Spalart-Allmaras NEEDS HAT VARIABLES. BE CAREFULL
c      IF(ITURB == 9) THEN
c       CALL FLSCSA(RO,F1EPS,REPS,VOL,A3,
c     2      SRNU,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,
c     3      EPS2,A3XA,A3YA,A3ZA,
c     4      1,MAXB,NBL,FRSDEN,ITURB,
c     5      KSTR,IDIR)
c       CALL FLSCAL(RO,F1EPS,REPS,HAT1,HAT2,HAT3,HAT4,VOL,A3,
c     2      PSIGSC,PSIGS2,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,
c     3      IDM3,VIS,EPS2,A3XA,A3YA,A3ZA,PR,PRT,
c     4      1,MAXB,NBL,RKLIM,FRSDEN,ITURB,KMAXP,KSTR,
c     5      IDIR,ZZZ,MAW,MAXW,RKSI,INCHIML)
c      ENDIF

C ... SCALARS NEED HAT VARIABLES. BE CAREFULL
      IF(NSCAL > 0) THEN 
       CALL FLSCLD(RO,F1FI,FI,HAT1,HAT2,HAT3,HAT4,VOL,A3,
     2      PSIGSC,PSIGS2,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,IDM3,VIS,
     3      EPS2,A3XA,A3YA,A3ZA,PR,PRT,
     4      NSCAL,MAXSB,NBL,RLOLIM,FRSDEN,ITURB,
     5      KSTR,IDIR)
       CALL FLSCAL(RO,F1FI,FI,HAT1,HAT2,HAT3,HAT4,VOL,A3,
     2      PSIGSC,PSIGS2,IMAXRE,JMAXRE,KMAXRE,ICYCLE,INTERK,
     3      IDM3,VIS,EPS2,A3XA,A3YA,A3ZA,PR,PRT,
     4      NSCAL,MAXSB,NBL,RLOLIM,FRSDEN,ITURB,KMAXP,KSTR,
     5      IDIR,ZZZ,MAW,MAXW,RKSI,INCHIML)
      ENDIF
C *********************************************************************

C ... NON-STANDARD FLUX CALCULATION AT THE BOUNDARIES

      DO 100 L = 1,NPATCH

      ITYP   = ICON(1,L)          ! Boundary type, 1=CON, 3=INL,5=OUT
      IF2    = IHF(ICON(2,L))     ! Starting address of this patch
      IBL    = ICON(8,L)          ! Face is connected with a global block IBL
      IBTYPE = ICON(8,L)          ! In a case of inlets/outlets (mersu)
      IFACE  = ICON(3,L)          ! Face number
      NFACN  = ICON(9,L)          ! Face number in the connected block

      KX1 = ICON(4,L)
      KX2 = ICON(5,L)
      KY1 = ICON(6,L)
      KY2 = ICON(7,L)
      IDIMP = IDIMS(L)
      JDIMP = JDIMS(L)

      IF(IDIR == 2) THEN
         KY1 = ICON(4,L)
         KY2 = ICON(5,L)
         KX1 = ICON(6,L)
         KX2 = ICON(7,L)
         JDIMP = IDIMS(L)
         IDIMP = JDIMS(L)
      ENDIF

      KBOT = 1
      IF(IDIR == 1) KTOP = IMAXRE
      IF(IDIR == 2) KTOP = JMAXRE
      IF(IDIR == 3) KTOP = KMAXRE

      IF(IFACE <= 3) THEN 
         ILMO   =  1          ! Direction indicator
         KBOTOP = KBOT
      ELSE IF(IFACE > 3) THEN
         ILMO   = -1
         KBOTOP = KTOP
      ELSE
         STOP'Troubles with faces at FLUCYC'
      ENDIF

      DIRECTION  = (IFACE == IDIR .OR. IFACE == IDIR+3)
      SOLID_WALL = (ITYP >= 8 .AND. ITYP <= 10)
     
      IF(ITYP == 3) THEN      ! An inlet type boundary
         INLETS_AND_OUTLETS = .TRUE.
         INLETS = .TRUE.
         INLOUT = 0
      ELSE IF(ITYP == 5) THEN ! An outlet type boundary
         INLETS_AND_OUTLETS = .TRUE.
         INLETS = .FALSE.
         INLOUT = 0
       ELSE IF(ITYP == 1 .AND.ICON(20,L) == 2) THEN ! A periodic inlet
         INLETS_AND_OUTLETS = .TRUE.
         INLETS = .TRUE.
         INLOUT = 0
      ELSE IF(ITYP == 17) THEN                      ! A periodic inlet
         INLETS_AND_OUTLETS = .TRUE.                ! for circulation of
         INLETS = .TRUE.                            ! the velocity
         INLOUT = 0
      ELSE IF(ITYP == 1 .AND.ICON(20,L) == 3) THEN  ! A periodic outlet
         INLETS_AND_OUTLETS = .TRUE.
         INLETS = .FALSE.
         INLOUT = 0
      ELSE                   ! Inactive boundary
         INLETS_AND_OUTLETS = .FALSE.
         INLETS = .FALSE.
      ENDIF
         

      IF(SOLID_WALL .AND. DIRECTION) THEN ! Solid wall
 
       IF(WALLFUNL) THEN
       
       KOKO    = (KY2-KY1+1)*(KX2-KX1+1)
       ALLOCATE(F2VWF(KOKO),F3VWF(KOKO),F4VWF(KOKO),FUNNY1(KOKO))
       RELAX = 0.9 ! To input?
       STOP'No wall function yet to S-A model. Contact administration'
       
       CALL WALLFUN(UTAUM(IF2),F2VWF,F3VWF,F4VWF,A3,A3XA,A3YA,A3ZA,
     2  VIS,VIST,EPS2,UWALL(IF2),VWALL(IF2),WWALL(IF2),TWALL(IF2),
     3  HFLUX(IF2),ISTRID,JSTRID,KSTRID,IDM3,ILMO,KBOTOP,KX1,KX2,
     4  KY1,KY2,ITURB,ISTR,JSTR,KSTR,IN,JN,KN,VOL,RO,RELAX,U,V,W,
     5  PTUR,REPS,EPSOLD,STRAIN,RBK(IF2),FUNNY1) ! Works not for the S-A model
       ENDIF

       CALL BOTSKE(F1R,F1RM,F1RN,F1RW,F1E,P,U,V,W,C,E,VOL,A3,A3XA,A3YA,
     2    A3ZA,OHMI,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     3    PDIFF,PRO,VAR,KX1,KX2,KY1,KY2,CP,PR,PRT,RO,
     4    TOMEGA(L),IFLUX,CX(L),CY(L),CZ(L),CMX(L),CMY(L),CMZ(L),M,
     5    IN,JN,KN,XC,YC,ZC,RKLIM,XMOM,YMOM,ZMOM,ILMO,DX(L),DY(L),DZ(L),
     6    F1RK,F1EPS,RK,REPS,PTUR,WROT,TEMP,CH,QX(L),QY(L),QZ(L),FRSDEN,
     7    FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,
     8    KSTR,ICON(20,L),RCON(1,L),IDIS,PSIGK1,PSIGE1,PSIGK,PSIGE,
     9    UWALL(IF2),VWALL(IF2),WWALL(IF2),CPWALL(IF2),TWALL(IF2),
     +    QWALL(IF2),QWFRIC(IF2),HFLUX(IF2),TAUW1(IF2),TAUW2(IF2),
     1    TAUWX(IF2),TAUWY(IF2),TAUWZ(IF2),SURLE(IF2),DSURLE(IF2),
     2    WMFLUX(IF2),POROS(IF2),WHSTAG(IF2),WTEMP(IF2),RBK(IF2),
     3    RSDIRX(IF2),RSDIRY(IF2),RSDIRZ(IF2),SURFX(IF2),SURFY(IF2),
     4    SURFZ(IF2),XCP(IF2),YCP(IF2),ZCP(IF2),MAX11,CMU,XCO,YCO,ZCO,
     5    INTERK,INTETK,MULPHL,BLKS(NBL)%SOLUTION_TYPE,NBL,.FALSE.,
     6    ICYCLE,FRESUL,F1H,IWAVEB,BUX(L),BUY(L),BUZ(L),VMXB(L),VMYB(L),
     7    VMZB(L),STRAIN,TRANSL,TRM,WAVE,SURFPX(IF2),SURFPY(IF2),
     4    SURFPZ(IF2),PRC,UTAUM(IF2),F2VWF,F3VWF,F4VWF,TURLIM)
     
       IF(WALLFUNL) DEALLOCATE(F2VWF,F3VWF,F4VWF,FUNNY1)

      IF(NSCAL > 0) THEN
      CALL BOSCAL(F1FI,VOL,A3,A3XA,A3YA,A3ZA,VIS,EPS2,
     2     PSIGSC,PSIGS2,ISTRID,JSTRID,KSTRID,IDM3,
     3     KBOTOP,KX1,KX2,KY1,KY2,PR,PRT,RO,
     4     M,IN,JN,KN,ILMO,FI,NSCAL,MAXSB,0,
     5     ISTR,JSTR,KSTR)
      ENDIF

C ... Extend the solid patches into the ghost cells

      CALL EXTPAT(CPWALL(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TWALL(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( QWALL(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT(QWFRIC(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( HFLUX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUW1(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUW2(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUWX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUWY(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUWZ(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFY(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFZ(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFPX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFPY(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFPZ(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURLE(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT(DSURLE(IF2),KX1,KX2,KY1,KY2)

      ENDIF ! Solid wall
         
C ... Create data on a mirror surface for output

      IF(ITYP == 4 .AND. DIRECTION) THEN

      INLOUT = 0

       CALL BOUMIR(F1R,F1RM,F1RN,F1RW,F1E,P,U,V,W,C,E,VOL,A3,A3XA,A3YA,
     2    A3ZA,OHMI,SS11,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     3    PDIFF,KX1,KX2,KY1,KY2,PR,PRT,RO,RM,RN,RW,CX(L),CY(L),CZ(L),
     4    DX(L),DY(L),DZ(L),CMX(L),CMY(L),CMZ(L),TOMEGA(L),IFLUX,M,M2,
     5    IN,JN,KN,XC,YC,ZC,RKLIM,ILMO,
     6    F1RK,F1EPS,RK,REPS,WROT,TEMP,CH,FRSDEN,
     7    FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,IDIS,
     9    XCP(IF2),YCP(IF2),ZCP(IF2),
     9    UWALL(IF2),VWALL(IF2),WWALL(IF2),CPWALL(IF2),TWALL(IF2),
     +    QWALL(IF2),QWFRIC(IF2),HFLUX(IF2),TAUW1(IF2),TAUW2(IF2),
     1    TAUWX(IF2),TAUWY(IF2),TAUWZ(IF2),SURLE(IF2),DSURLE(IF2),
     2    WMFLUX(IF2),POROS(IF2),WHSTAG(IF2),WTEMP(IF2),RBK(IF2),
     3    RSDIRX(IF2),RSDIRY(IF2),RSDIRZ(IF2),
     4    SURFX(IF2),SURFY(IF2),SURFZ(IF2),
     5    MAX11,XCO,YCO,ZCO,QMFIN,QMEIN,QMFOUT,
     6    QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,QVFIN,QVFOUT,
     7    INTERK,INTETK,NBL,INLOUT,XMOM,YMOM,ZMOM,
     8    CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,INLETS,l,
     9    BLKS(NBL)%CONVL,PRO,VAR,MULPHL,
     4    QGFIN,QGEIN,QGFOUT,QGEOUT,IDIMP,JDIMP,SURFPX(IF2),SURFPY(IF2),
     5    SURFPZ(IF2))
      ENDIF ! ITYP == 4 

C ... Calculate free surfaces

      IF(ITYP == 13 .AND. DIRECTION) THEN  ! A freesurface

      IF(ICON(3,L) <= 3) THEN 
        IDM3Q  = IDM3
        KBOTOP = KBOT
C      IF(ITYP == 13) THEN ! free-surface is inviscid wall
      ELSEIF(ICON(3,L) >= 4) THEN
        IDM3Q  = 0
        KBOTOP = KMAX
      ENDIF
                
c      IF(KBOT /= 0.AND. ICON(3,L)  <= 3) THEN ! KBOT turha?? FRESUR
      IF(IFSBC == 3) THEN

      CALL BOTSF(F1R,F1RM,F1RN,F1RW,F1E,P,U,V,W,C,E,VOL,A3,A3XA,A3YA,
     2     A3ZA,OHMI,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3Q,KBOTOP,
     3     PDIFF,KX1,KX2,KY1,KY2,PR,PRT,RO,
     4     TOMEGA(L),IFLUX,CX(L),CY(L),CZ(L),CMX(L),CMY(L),CMZ(L),M,
     5     IN,JN,KN,XC,YC,ZC,XMOM,YMOM,ZMOM,1,DX(L),DY(L),DZ(L),WROT,
     6     TEMP,CH,QX(L),QY(L),QZ(L),FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,
     7     DIFPRE,ISTR,JSTR,KSTR,ICON(20,L),RCON(1,L),
     8     HFLUX(IHF(ICON(2,L))),XCO,YCO,ZCO,ICYCLE)

      ELSE 

      CALL BOTSFR(F1R,F1RM,F1RN,F1RW,F1E,PDIFF,P,U,V,W,C,E,VOL,A3,
     2    A3XA,A3YA,A3ZA,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3Q,
     3    KBOTOP,KX1,KX2,KY1,KY2,PR,PRT,RO,
     4    IFLUX,M,
     5    IN,JN,KN,RKLIM,ILMO,
     6    F1RK,F1EPS,WROT,TEMP,CH,FRSDEN,
     7    FRSPRE,FRSVEL,FRSVIS,T0,ITURB,ISTR,JSTR,
     8    KSTR,ICON(20,L),RCON(1,L),IDIS,TWALL(IF2),
     +    QWALL(IF2),HFLUX(IF2),XCP(IF2),YCP(IF2),ZCP(IF2),WMFLUX(IF2),
     1    CPWALL(IF2),SURLE(IF2),DSURLE(IF2),SURFX(IF2),SURFY(IF2),    
     5    SURFZ(IF2),INTERK,INTETK,IFSBC,nbl,HAT1,WAVE,SURFPX(If2),
     6    SURFPY(IF2),SURFPZ(IF2))

      ENDIF ! IFSBC == 13

      ENDIF ! ITYP == 13
             
C ... Calculate inlets and outlets
         
      IF(INLETS_AND_OUTLETS .AND. DIRECTION) THEN ! Inlet or outlet
        
       IF(IBTYPE > 10 .AND. IBTYPE <= 20) IBTYPE = IBTYPE - 10
       IF(IBTYPE > 20 .AND. IBTYPE <= 30) IBTYPE = IBTYPE - 20

       IF(IFACE <= 3) THEN
          KBOTOP = 1
       ELSE IF(IFACE == 4) THEN
          KBOTOP = IMAXRE
       ELSE IF(IFACE == 5) THEN
          KBOTOP = JMAXRE
       ELSE IF(IFACE == 6) THEN
          KBOTOP = KMAXRE
       ELSE
          STOP'Problems with faces in FLUCYC'
       ENDIF

C ... Recalculate the inlet and outlet fluxes and update ghost cells on 
C ... the first level.(Flux-based boundary conditions).
                  
      IF(IBTYPE > 6) THEN  ! A flux-based boundary calculation (recalculated)

       IF(ITYP == 3) THEN
              
       CALL INFLO(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,
     1   HAT1)
   
       ENDIF      

       IF(ITYP == 5) THEN
       CALL OUTFLO      
       ENDIF      

      ENDIF ! IBTYPE > 6

      IF(IFLUX == 4 .AND. M == 1) THEN

      KOKO = (KX2-KX1+1)*(KY2-KY1+1) ! Is this needed?

      CALL DIVV12(RK,RK,RO,NTOT)
      CALL DIVV12(REPS,REPS,RO,NTOT)

       IF(ITYP == 1.AND.ICON(20,L) == 2.AND.BLKS(NBL)%INLRC > 0 .OR.! Periodic
     1    ITYP == 17.AND.ICON(20,L) == 2                         .OR.! Cycling
     2    ITYP == 3.AND.BLKS(NBL)%INLRC > 0)                   THEN ! Inlet

C ... Inflow surface

       CALL INFPER(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     3   KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,ZZZ,
     1   RKSI,D3,WROT,HAT1,HAT2,HAT3,HAT4,XXTRAL,
     2   INCHIML,KOKO,MAXW,IMAX,JMAX,KMAX,NBL,ITYP,BLKS(NBL)%INLRC,1,
     3   ARTSSP,PSEUCO,BLKS(NBL)%FRSTEM,IUPPTL)
   
       ENDIF      


       IF(ITYP == 1.AND.ICON(20,L) == 3.AND.BLKS(NBL)%OUTRC > 0 .OR.! Periodic
     1    ITYP == 17.AND.ICON(20,L) == 3                         .OR.! Cycling
     2    ITYP == 5.AND.BLKS(NBL)%OUTRC > 0)                   THEN ! Outlet

C ... Outflow surface

       CALL INFPER(F1R,F1RM,F1RN,F1RW,F1E,F1RK,F1EPS,
     1   P,PDIFF,U,V,W,C,E,VOL,A3,A3XA,A3YA,A3ZA,OHMI,SS11,
     2   VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     2   KX1,KX2,KY1,KY2,
     3   RO,RM,RN,RW,RK,REPS,WROT,TEMP,CH,PR,PRT,IFLUX,M,M2,IN,JN,KN,
     4   FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,
     5   ISTRES,ICYCLE,ISTATE,ILMO,MAX11,INTERK,INTETK,NBL,IBTYPE,
     6   RGAS,GAMMA,E0REF,T0REF,FI,BIJ,BOUNR(IF2),BOUNU(IF2),
     7   BOUNV(IF2),BOUNW(IF2),BOUNE(IF2),BOUNP(IF2),BOUNPD(IF2),
     8   BOUNT(IF2),BOUNRK(IF2),BOUNEP(IF2),BOUNFI(IF2,1),BOUNBI(IF2,1),
     9   BOUNMF(IF2),MAXSB,MAXSS,MAXEB,IBF,NSCAL,TURLIM,FRSSIE,RNUT,ZZZ,
     1   RKSI,D3,WROT,HAT1,HAT2,HAT3,HAT4,XXTRAL,
     2   INCHIML,KOKO,MAXW,IMAX,JMAX,KMAX,NBL,ITYP,BLKS(NBL)%OUTRC,2,
     3   ARTSSP,PSEUCO,BLKS(NBL)%FRSTEM,IUPPTL)
   
      ENDIF ! ITYP == 1 (Periodic)

      CALL MULV12(RK,RO,NTOT)
      CALL MULV12(REPS,RO,NTOT)

      ENDIF ! IFLUX == 4


C ... Integrate inlet and outlet flows for output

       CALL BOUFLO(F1R,F1RM,F1RN,F1RW,F1E,P,U,V,W,C,E,VOL,A3,A3XA,A3YA,
     2    A3ZA,OHMI,SS11,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     3    PDIFF,KX1,KX2,KY1,KY2,PR,PRT,RO,RM,RN,RW,CX(L),CY(L),CZ(L),
     4    DX(L),DY(L),DZ(L),CMX(L),CMY(L),CMZ(L),TOMEGA(L),IFLUX,M,M2,
     5    IN,JN,KN,XC,YC,ZC,RKLIM,ILMO,
     6    F1RK,F1EPS,RK,REPS,WROT,TEMP,CH,FRSDEN,
     7    FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,ITURB,ISTR,JSTR,KSTR,IDIS,
     9    XCP(IF2),YCP(IF2),ZCP(IF2),
     9    UWALL(IF2),VWALL(IF2),WWALL(IF2),CPWALL(IF2),TWALL(IF2),
     +    QWALL(IF2),QWFRIC(IF2),HFLUX(IF2),TAUW1(IF2),TAUW2(IF2),
     1    TAUWX(IF2),TAUWY(IF2),TAUWZ(IF2),SURLE(IF2),DSURLE(IF2),
     2    WMFLUX(IF2),POROS(IF2),WHSTAG(IF2),WTEMP(IF2),RBK(IF2),
     3    RSDIRX(IF2),RSDIRY(IF2),RSDIRZ(IF2),
     4    SURFX(IF2),SURFY(IF2),SURFZ(IF2),
     5    MAX11,XCO,YCO,ZCO,QMFIN,QMEIN,QMFOUT,
     6    QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,QVFIN,QVFOUT,
     7    INTERK,INTETK,NBL,INLOUT,XMOM,YMOM,ZMOM,
     8    CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,CMZOUT,INLETS,l,
     9    BLKS(NBL)%CONVL,PRO,VAR,MULPHL,QGFIN,QGEIN,QGFOUT,QGEOUT,
     1    ICYCLE,IPRINT,NSCAL,ISTRES,BLKS(NBL)%NPHASE,TRANSL,TRM,
     2    BOUNG,BOUNRET,BIJ,MAXSB,MAXEB,ICMAX,SURFPX(IF2),SURFPY(IF2),
     3    SURFPZ(IF2),QLFIN,QLEIN,QLFOUT,QLEOUT)

C ... Extend the patches into the ghost cells

      IF(INLOUT == 0) THEN ! Extend i/o surface patches
         CALL EXTPAT(CPWALL(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TWALL(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( QWALL(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT(QWFRIC(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( HFLUX(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TAUW1(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TAUW2(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TAUWX(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TAUWY(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( TAUWZ(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFX(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFY(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFZ(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFPX(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFPY(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURFPZ(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT( SURLE(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT(DSURLE(IF2),KX1,KX2,KY1,KY2)
         CALL EXTPAT(WMFLUX(IF2),KX1,KX2,KY1,KY2)
      ENDIF ! I/o surface patches
      ENDIF ! Inlets and outlets      

 100  CONTINUE
            
      RETURN
      END SUBROUTINE FLUCYC
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE FLXSOL(NBL,M,M2,RO,RM,RN,RW,E,P,PDIFF,U,V,W,C,CH,
     + A3,D3,A3XA,A3YA,A3ZA,XC,YC,ZC,
     + F1R,F1RM,F1RN,F1RW,F1E,VIS,TEMP,EPS2,VIST,
     + W12,W13,W23,SS11,SS12,SS13,SS22,
     + SS23,SS33,DTDX,DTDY,DTDZ,DKDX,
     + DKDY,DKDZ,DEPSDX,DEPSDY,DEPSDZ,RGAS,GAMMA,E0REF,T0REF,
     + DRO,DM,DN,DW,DE,VOL,OHMI,KCP,IMAX,JMAX,KMAX,
     + IN,JN,KN,ISTRID,JSTRID,KSTRID,ICYCLE,ICMAX,INTERK,INTETK,
     + IT,IL,IK,IPRINT,
     + PR,PRT,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,DZ,QX,QY,QZ,
     + TOMEGA,OMEGA,S11,MAXSS,ICON,RCON,NPATCH,
     + UWALL,VWALL,WWALL,CPWALL,TWALL,QWALL,
     + HFLUX,QWFRIC,TAUW1,TAUW2,SURFX,SURFY,SURFZ,
     + TAUWX,TAUWY,TAUWZ,SURLE,DSURLE,WMFLUX,POROS,
     + WHSTAG,WTEMP,RSDIRX,RSDIRY,RSDIRZ,RBK,XCP,YCP,ZCP,IHF,
     + XMOM,YMOM,ZMOM,KBOT,KTOP,LAMIN3,IFLUX,
     + WROT,IDM3,UBK,VBK,WBK,UTK,VTK,WTK,
     + RK,REPS,DDEPS,DRK,DEPS,SRK,SEPS,
     + PTUR,F1RK,F1EPS,FUN1,BIJ,MAXEB,ISTRES,TURLIM,RKLIM,
     + EPSLIM,PSIGK1,PSIGE1,PSIGK,PSIGE,C1,C2,CMU,CTA,
     + FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,DIFPRE,DRDH,DRDP,ISTATE,
     + ITURB,IDIS,PSIGSC,PSIGS2,FI,F1FI,DFI,SFI,MAXSB,NSCAL,KBEGIN,
     + KSCAL,HAT1,HAT2,HAT3,HAT4,RLOLIM,PROD,PI,DIF,DIS,VVIS,FWLL,
     + JRDIF,JRDIS,JRPRE,SOURL,IMAXRE,JMAXRE,KMAXRE,
     + INRE,JNRE,KNRE,KMAXP,ISTR,JSTR,KSTR,IDIR,FULLNS,ZZZ,MAXW,MAX11,
     + XCO,YCO,ZCO,QMFIN,QMEIN,QMFOUT,
     + QMEOUT,QMXIN,QMXOUT,QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMYIN,
     + CMZIN,CMXOUT,CMYOUT,CMZOUT,BOUNMF,BOUNR,BOUNU,BOUNV,BOUNW,
     + BOUNE,BOUNP,BOUNPD,BOUNT,BOUNRK,BOUNEP,BOUNFI,BOUNBI,IBF)

      USE CHARACTERS
      USE NS3CO, ONLY : IC9

      IMPLICIT NONE

      INTEGER :: NBL,M,M2,IMAX,JMAX,KMAX,IN,JN,KN,ISTRID,JSTRID,KSTRID,
     2 ICYCLE,INTERK,INTETK,IT,IL,IK,IPRINT,MAXSS,NPATCH,KBOT,
     3 KTOP,LAMIN3,IFLUX,IDM3,MAXEB,ISTRES,ISTATE,ITURB,IDIS,MAXSB,
     4 NSCAL,KBEGIN,KSCAL,JRDIF,JRDIS,JRPRE,IMAXRE,JMAXRE,KMAXRE,
     5 KMAXP,ISTR,JSTR,KSTR,IDIR,MAX11,MAW,NTOT,IJKSTR,IADD,JADD,
     6 KADD,L,ITYP,KX1,KX2,KY1,KY2,IF2,IFACE,ILMO,KBOTOP,
     7 IBF,II,IBL,IBTYPE,NFACN,ICMAX,MAXW,INRE,JNRE,KNRE

      REAL :: RO(*),RM(*),RN(*),E(*),P(*),PDIFF(*),U(*),V(*),C(*),
     2 A3(*),A3XA(*),A3YA(*),A3ZA(*),DRO(*),DM(*),DN(*),DE(*),VOL(*),
     3 F1R(*),F1RM(*),F1RN(*),F1E(*),F1RW(*),CH(*),TEMP(*),
     4 VIS(*),EPS2(*),VIST(*),
     5 UWALL(*),VWALL(*),WWALL(*),CPWALL(*),TWALL(*),QWALL(*),
     6 QWFRIC(*),TAUW1(*),TAUW2(*),SURFX(*),SURFY(*),SURFZ(*),
     7 TAUWX(*),TAUWY(*),TAUWZ(*),SURLE(*),DSURLE(*),WMFLUX(*),
     8 POROS(*),WHSTAG(*),WTEMP(*),RSDIRX(*),RSDIRY(*),RSDIRZ(*),
     9 RBK(*),HFLUX(*),
     1 UBK(*),VBK(*),WBK(*),UTK(*),VTK(*),WTK(*),
     2 RW(*),W(*),DW(*),D3(*),
     3 OHMI(*),WROT(*),PTUR(*),
     4 RK(*),REPS(*),DRK(*),DEPS(*),SRK(*),SEPS(*),F1RK(*),F1EPS(*),
     5 DRDH(*),DRDP(*),PSIGSC(*),PSIGS2(*),
     6 FI(MAXSB,MAX(1,NSCAL)),F1FI(MAXSB,MAX(1,NSCAL)),
     7 DFI(MAXSB,MAX(1,NSCAL)),SFI(MAXSB,MAX(1,NSCAL)),
     8 HAT1(*),HAT2(*),HAT3(*),HAT4(*),
     9 PROD(MAXSB,6),PI(MAXSB,6),DIF(MAXSB,6),DIS(MAXSB,6),S11(MAXSS,6),
     1 VVIS(MAXSB,6),FWLL(*),RLOLIM(*),DDEPS(*),
     2 CX(*),CY(*),CZ(*),CMX(*),CMY(*),CMZ(*),DX(*),DY(*),DZ(*),
     3 QX(*),QY(*),QZ(*),TOMEGA(*),RCON(IC9,*),FUN1(*),BIJ(MAXEB,6),
     4 W12(*),W13(*),W23(*),SS11(*),SS12(*),SS13(*),SS22(*),SS23(*),
     5 SS33(*),DTDX(*),DTDY(*),DTDZ(*),DKDX(*),DKDY(*),DKDZ(*),
     6 DEPSDX(*),DEPSDY(*),DEPSDZ(*),ZZZ(*),BOUNR(*),BOUNU(*),BOUNV(*),
     7 BOUNW(*),BOUNE(*),BOUNT(*),BOUNRK(*),BOUNEP(*),BOUNFI(IBF,*),
     8 BOUNBI(IBF,*),BOUNP(*),BOUNPD(*),BOUNMF(*)

      REAL :: RGAS,GAMMA,E0REF,T0REF,OMEGA,TURLIM,RKLIM,
     2 EPSLIM,PSIGK1,PSIGE1,PSIGK,PSIGE,C1,C2,CMU,CTA,FRSDEN,FRSPRE,
     3 FRSVEL,FRSVIS,T0,DIFPRE,QMFIN,QMEIN,QMFOUT,QMEOUT,QMXIN,QMXOUT,
     4 QMYIN,QMYOUT,QMZIN,QMZOUT,CMXIN,CMYIN,CMZIN,CMXOUT,CMYOUT,
     5 CMZOUT,PR,PRT

      INTEGER :: IHF(*),ICON(IC9,*),KCP(*)

      REAL :: XCO(*), YCO(*), ZCO(*), XC(*), YC(*), ZC(*),
     2                    XCP(*), YCP(*), ZCP(*)

      REAL :: XMOM,YMOM,ZMOM

      LOGICAL :: SOURL, FULLNS, DIRECTION, SOLID_WALL

C ... CALCULATIONS OF FLUXES FOR SOLID SURFACES.

*      CALL DOMAW(MAXW,IMAXRE,JMAXRE,MAW)
      CALL DOMAW(MAXW,IMAXRE,JMAXRE,INRE,JNRE,MAW)

      NTOT = ISTRID*JSTRID*KSTRID

      IF(IDIR == 1) THEN
        IJKSTR = ISTR
        IADD   = 1
        JADD   = 0
        KADD   = 0
      ELSE IF(IDIR == 2) THEN
        IJKSTR = JSTR
        IADD   = 0
        JADD   = 1
        KADD   = 0
      ELSE IF(IDIR == 3) THEN
        IJKSTR = KSTR
        IADD   = 0
        JADD   = 0
        KADD   = 1
      ELSE
        STOP 'In FLXCYX'
      ENDIF
       
C **********************************************************************

      DO II = 1,NTOT  ! Initialize all the fluxes to zero
         F1R(II)   = 0.
         F1RM(II)  = 0.
         F1RN(II)  = 0.
         F1RW(II)  = 0.
         F1E(II)   = 0.
         F1RK(II)  = 0.
         F1EPS(II) = 0.
      ENDDO

C ... Calculate the heat flux

      CALL FLUXHS(F1E,A3,XC,YC,ZC,E,IMAXRE,JMAXRE,KMAXRE,ICYCLE,
     2     INTERK,IDM3,DTDX,DTDY,DTDZ,D3,A3XA,A3YA,A3ZA,
     3     TEMP,CH,KSTR,IDIR)

C **********************************************************************

C ... NON-STANDARD FLUX CALCULATION AT THE BOUNDARIES. 
C ... NEEDS DIRECTION CHECK WITH IDIR

      DO 100 L = 1,NPATCH

      ITYP   = ICON(1,L)          ! Boundary type, 15=HTS
      IF2    = IHF(ICON(2,L))     ! Starting address of this patch
      IBL    = ICON(8,L)          ! Face is connected with a global block IBL
      IBTYPE = ICON(8,L)          ! In a case of inlets/outlets (mersu)
      IFACE  = ICON(3,L)          ! Face number
      NFACN  = ICON(9,L)          ! Face number in the connected block
        
      KX1 = ICON(4,L)
      KX2 = ICON(5,L)
      KY1 = ICON(6,L)
      KY2 = ICON(7,L)

      IF(IDIR == 2) THEN
         KY1 = ICON(4,L)
         KY2 = ICON(5,L)
         KX1 = ICON(6,L)
         KX2 = ICON(7,L)
      ENDIF

      IF(IFACE <= 3) THEN 
         ILMO   =  1               ! Direction indicator
         KBOTOP = KBOT
      ELSE IF(IFACE > 3) THEN
         ILMO   = -1
         KBOTOP = KTOP
      ELSE
         STOP'Troubles with faces at FLXCYC'
      ENDIF

      DIRECTION  = (IFACE == IDIR .OR. IFACE == IDIR+3)
      SOLID_WALL = (ITYP == 15)

      IF(SOLID_WALL .AND. DIRECTION) THEN ! Coupling with fluid block
        
       CALL BOTSOL(F1R,F1RM,F1RN,F1RW,F1E,P,U,V,W,C,E,VOL,A3,A3XA,A3YA,
     2    A3ZA,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDM3,KBOTOP,
     3    KX1,KX2,KY1,KY2,PR,PRT,RO,
     4    IFLUX,M,
     5    IN,JN,KN,RKLIM,ILMO,
     6    F1RK,F1EPS,WROT,TEMP,CH,FRSDEN,
     7    FRSPRE,FRSVEL,FRSVIS,T0,ITURB,ISTR,JSTR,
     8    KSTR,ICON(20,L),RCON(1,L),IDIS,TWALL(IF2),
     +    QWALL(IF2),HFLUX(IF2),XCP(IF2),YCP(IF2),ZCP(IF2),
     5    INTERK,INTETK,nbl,if2,HAT1(IF2))

C ... Extend the solid patches into the ghost cells

      CALL EXTPAT(CPWALL(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TWALL(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( QWALL(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT(QWFRIC(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( HFLUX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUW1(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUW2(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUWX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUWY(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( TAUWZ(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFX(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFY(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURFZ(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT( SURLE(IF2),KX1,KX2,KY1,KY2)
      CALL EXTPAT(DSURLE(IF2),KX1,KX2,KY1,KY2)

      ENDIF ! Solid walls

 100  CONTINUE

      RETURN
      END SUBROUTINE FLXSOL
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SETFLX(RO,U,V,W,E,XC,YC,ZC,A1,A1XA,A1YA,A1ZA,
     + A2,A2XA,A2YA,A2ZA,A3,A3XA,A3YA,A3ZA,INITC,IMAX,JMAX,KMAX,
     + ZZZ)

      USE CHARACTERS
      USE NS3CO, ONLY : IN, JN, KN

      REAL :: RO(*),U(*),V(*),W(*),E(*),A1(*),
     +        A1XA(*),A1YA(*),A1ZA(*),A2(*),A2XA(*),
     +        A2YA(*),A2ZA(*),A3(*),A3XA(*),A3YA(*),A3ZA(*),ZZZ(*)

      REAL :: XC(*),YC(*),ZC(*)

C **********************************************************
C                                                          *
C  CALLING ROUTINE FOR THE MASS FLUX INITIALIZATION        *
C                                                          *
C **********************************************************

      ISTRID  = IMAX + 2*IN
      JSTRID  = JMAX + 2*JN
      KSTRID  = KMAX + 2*KN

      IF(INITC == 11 .OR. INITC == 14) INTO = 1
      IF(INITC == 12 .OR. INITC == 15) INTO = 2
      IF(INITC == 13 .OR. INITC == 16) INTO = 3

      ISTEP = 1
      IF(INITC >= 14 .AND. INITC <= 16) ISTEP = -1

      GO TO(1,2,3),INTO

C******************************************************************
C                                                                 *
C ... BALANCE IN ZETA (=K) -DIRECTION                             *
C                                                                 *
C******************************************************************
 3    CONTINUE

      CALL FLUXIN(RO,U,V,W,E,A3,A3XA,A3YA,A3ZA,XC,YC,ZC,IMAX,
     + JMAX,KMAX,IN,JN,KN,ISTEP,INITC)

      GO TO 4
C******************************************************************
C                                                                 *
C ... FOR THE CALCULATION OF BALANCE IN XI (=I) -DIRECTION SORT   *
C ... GEOMETRY AND VARIABLES FROM IJK TO JKI                      *
C                                                                 *
C******************************************************************
1     CALL SORT39(A1,A1XA,A1YA,A1ZA,ISTRID,JSTRID,KSTRID,1,ZZZ)
      CALL SORT51(XC,YC,ZC,ISTRID,JSTRID,KSTRID,1,ZZZ)
      CALL SORT41(RO,U,V,W,E,ISTRID,JSTRID,KSTRID,1,ZZZ)

      CALL FLUXIN(RO,U,V,W,E,A1,A1XA,A1YA,A1ZA,XC,YC,ZC,JMAX,
     + KMAX,IMAX,JN,KN,IN,ISTEP,INITC)

C ... AFTER CALCULATING BALANCE SORT GEOMETRY FROM JKI TO IJK
      CALL SORT39(A1,A1XA,A1YA,A1ZA,JSTRID,KSTRID,ISTRID,2,ZZZ)
      CALL SORT51(XC,YC,ZC,JSTRID,KSTRID,ISTRID,2,ZZZ)
      CALL SORT41(RO,U,V,W,E,JSTRID,KSTRID,ISTRID,2,ZZZ)
      GO TO 4

C******************************************************************
C ... CALCULATE MASS BALANCE IN ETA (=J)-DIRECTION                *
C ... SORT GEOMETRY AND VARIABLES FROM IJK TO KIJ                 *
C******************************************************************

2     CALL SORT39(A2,A2XA,A2YA,A2ZA,ISTRID,JSTRID,KSTRID,2,ZZZ)
      CALL SORT51(XC,YC,ZC,ISTRID,JSTRID,KSTRID,2,ZZZ)
      CALL SORT41(RO,U,V,W,E,ISTRID,JSTRID,KSTRID,2,ZZZ)

      CALL FLUXIN(RO,U,V,W,E,A2,A2XA,A2YA,A2ZA,XC,YC,ZC,KMAX,
     + IMAX,JMAX,KN,IN,JN,ISTEP,INITC)

C ... AFTER CALCULATING BALANCE VARIABLES FROM KIJ TO IJK
      CALL SORT39(A2,A2XA,A2YA,A2ZA,KSTRID,ISTRID,JSTRID,1,ZZZ)
      CALL SORT51(XC,YC,ZC,KSTRID,ISTRID,JSTRID,1,ZZZ)
      CALL SORT41(RO,U,V,W,E,KSTRID,ISTRID,JSTRID,1,ZZZ)

4     CONTINUE

      RETURN
      END SUBROUTINE SETFLX
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE RESL3(RO,RM,RN,RW,E,FI,RK,REPS,PTUR,VOL,P,PDIFF,VAR,
     +     F1E,TEMP,DRO,DM,DN,DW,DE,DFI,DRK,DEPS,RESI,IMAX,JMAX,KMAX,
     +     ITURB,NSCAL,MAXSB,NRESI,RKLIM,EPSLIM,HAT2,DDEPS,RMAV3,
     +     RNAV3,RWAV3,TIMEL,MULPHL,NGL,TRANSL,TRM)

      USE TYPE_ARRAYS
      USE NS3CO, ONLY : IN, JN, KN
      USE CONSTANTS, ONLY : EPS10

      IMPLICIT NONE

      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(INTERMITTENCY)    TRM(*)

      INTEGER :: I,J,K,IMAX,JMAX,KMAX,ISTRID,JSTRID,KSTRID,IL,NTOT,IA,
     +     II,KA,ITURB,NS,MAXSB,NRESI,NGL,NSCAL

      REAL :: EPS,XKIN,RKLIM,EPSLIM
    
      REAL :: DRO(*),DM(*),DN(*),DW(*),DE(*),RESI(*),
     +     DFI(MAXSB,MAX(1,NSCAL)),
     +     DRK(*),DEPS(*),PTUR(*),RO(*),RM(*),RN(*),RW(*),E(*),
     +        FI(MAXSB,MAX(1,NSCAL)),RK(*),REPS(*),SUM(100),P(*),
     +        PDIFF(*),VOL(*),F1E(*),TEMP(*),HAT2(*),DDEPS(*),RMAV3(*),
     +        RNAV3(*),RWAV3(*)

      LOGICAL :: TIMEL, MULPHL, TRANSL

C
C ... CALCULATE THE L2-NORM OF THE RESIDUALS AND THE AVERAGED VALUES
C
C     RESI  1- 7:     L2- norms of DRO, DM, DN, DW, DE, DRK, DEPS
C     RESI  8-13:     L2- norms of DUU, DUV, DUW, DVV, DVW, DWW
C     RESI 14-15:     L2- norms DRK/RK, DEPS/REPS
C     RESI 16-21:     L2- norms DRS(N)/RS(N) (N=1,6)
C     RESI    22:     Avaraged pressure
C     RESI    23:     Avaraged temperature
C     RESI    24:     Total mass
C     RESI    25:     Total energy
C     RESI    26:     Total internal energy
C     RESI    27:     Total kinetic energy
C     RESI    28:     Total turbulent kinectic energy
C     RESI    29:     Total dissipation of turbulent kinectic energy
C     RESI    30:     Total production of turbulent kinectic energy
C     RESI 31-37:     L2- norms of explicit residuals (RESL2)
C     RESI    38:     Viscous dissipation
C     RESI    39:     L2- norm of explicit residuals (RESL2)
C     RESI    40:     Time-dependent turbulent kinetic energy
C     RESI 41-43:     L2- norms of explicit residuals (RESL2)
C     RESI    46:     Total evaporation rate
C     RESI    47:     Total gas mass
C     RESI    48:     Total gas energy
C     RESI    49:     L2- norm of DG   (intermittency variable)
C     RESI    50:     L2- norm of DRET (intermittency variable)
C     RESI    51:     Gas mass flux out
C     RESI    52:     Gas energy flux out
C     RESI    53:     Sink of the first ship
C     RESI    54:     Trim of the first ship
C     RESI    55:     L1-norm of the wave height residual
C     RESI    56:     Maximum wave height
C     RESI    57:     Minimum wave height
C     RESI    58:     Maximum change in wave height
C     RESI    59:     Surface total volumetric flow
C     RESI    60:     Volume flux in
C     RESI    61:     Volume flux out
C     RESI 62-67:     L2- norms of explicit residuals (RESL2)

C     To add n parameters into convergence follow up: 
C      - increase NRESI in charac.f by n
C      - add the new parameter into above explanations 
C      - add calculations into this subroutine (RESL3) and into the   
C        code in ns3c.f between CALL RESL3 and CALL IBDWRI
C      - modify IBDWRI in messp.f
C      - customize convergence and guiconvergence programs
C     

      EPS = EPS10

      DO I = 1,30
         RESI(I) = 0.
         SUM(I)  = 0.
      ENDDO

      RESI(38) = 0. ; RESI(40) = 0.
      RESI(44) = 0. ; RESI(45) = 0. ! It seems that these are unused options

      DO I = 46,50
          RESI(I) = 0.
      ENDDO
      
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      KSTRID = ISTRID*JSTRID
      IL     = KSTRID
      NTOT   = IMAX*JMAX*KMAX

      DO K = 1,KMAX
         KA = (KN+K-1)*IL + IN
         DO J = 1,JMAX
            II = (JN+J-1)*ISTRID + KA
            DO I = 1,IMAX
               IA = I+II
               XKIN = .5*(RM(IA)**2 + RN(IA)**2 + RW(IA)**2)/RO(IA)
               RESI(1)  = RESI(1)  + DRO(IA)**2
               RESI(2)  = RESI(2)  + DM(IA)**2
               RESI(3)  = RESI(3)  + DN(IA)**2
               RESI(4)  = RESI(4)  + DW(IA)**2
               RESI(5)  = RESI(5)  + DE(IA)**2
               RESI(22) = RESI(22) + PDIFF(IA)*VOL(IA)
               RESI(23) = RESI(23) + TEMP(IA)*VOL(IA)
               RESI(24) = RESI(24) + RO(IA)*VOL(IA)
               RESI(25) = RESI(25) + E(IA)*VOL(IA)
               RESI(26) = RESI(26) + F1E(IA)*VOL(IA)
               RESI(27) = RESI(27) + XKIN*VOL(IA)
            ENDDO
         ENDDO
      ENDDO

      IF (ITURB >= 3) THEN

         DO K = 1,KMAX
            KA = (KN+K-1)*IL + IN
            DO J = 1,JMAX
               II = (JN+J-1)*ISTRID + KA
               DO I = 1,IMAX
                  IA = I+II
                  RESI(6)  = RESI(6)  + DRK(IA)**2
                  RESI(7)  = RESI(7)  + DEPS(IA)**2
                  RESI(28) = RESI(28) + (RK(IA)-RKLIM)*VOL(IA)

                  IF(ITURB == 6) THEN      ! k-omega
                     RESI(29) = RESI(29) + 0.09*(REPS(IA)
     &                        - EPSLIM)*RK(IA)/RO(IA)*VOL(IA)
                  ELSE IF(ITURB == 9) THEN ! S-A
                     RESI(29) = RESI(29) + (REPS(IA)-0.1*EPSLIM)*VOL(IA)
                  ELSE                     ! k-epsilon
                     RESI(29) = RESI(29) 
     &                        + (REPS(IA)-EPSLIM+DDEPS(IA))*VOL(IA)
                  ENDIF

                  IF(TRANSL) THEN ! Intermittency variables, mersu
                     RESI(8) = RESI(8) + TRM(IA)%DG**2
                     RESI(9) = RESI(9) + TRM(IA)%DRET**2
                     SUM(10) = SUM(10) + TRM(IA)%G**2
                     SUM(11) = SUM(11) + TRM(IA)%RET**2
                  ENDIF

                  RESI(30) = RESI(30) + PTUR(IA)*VOL(IA)
                  SUM(1)   = SUM(1)   + RK(IA)**2
                  SUM(2)   = SUM(2)   + REPS(IA)**2
                  RESI(38) = RESI(38) + HAT2(IA)*VOL(IA)

               ENDDO
            ENDDO
         ENDDO

         RESI(14) = RESI(6)/(SUM(1)+EPS)
         RESI(15) = RESI(7)/(SUM(2)+EPS)

         IF(TRANSL) THEN ! mersu
            RESI(49) = RESI(8)/(SUM(10)+EPS)
            RESI(50) = RESI(9)/(SUM(11)+EPS)
         ENDIF

         RESI(49) = MAX(RESI(49),EPS10) ! Set a minimum value
         RESI(50) = MAX(RESI(50),EPS10)

      ENDIF  ! ITURB >= 3


      IF(MULPHL) THEN ! Multiphase quatities

         DO K = 1,KMAX
            KA = (KN+K-1)*IL + IN
            DO J = 1,JMAX
               II = (JN+J-1)*ISTRID + KA
               DO I = 1,IMAX
                  IA = I+II
                  RESI(46) = RESI(46) + VAR(IA)%EVAPR(2)*VOL(IA)
                  RESI(47) = RESI(47) + VAR(IA)%ARO(2)*VOL(IA)
                  RESI(48) = RESI(48) + VAR(IA)%ARE(2)*VOL(IA)
               ENDDO
            ENDDO
         ENDDO

         RESI(47) = MAX(RESI(47),EPS10) ! Set a minimum value
         RESI(48) = MAX(RESI(48),EPS10)

      ENDIF


      IF(TIMEL) THEN ! Time-dependent kinetic energy

         DO K = 1,KMAX
            KA = (KN+K-1)*IL + IN
            DO J = 1,JMAX
               II = (JN+J-1)*ISTRID + KA
               DO I = 1,IMAX
                  IA = I+II
                  RESI(40) = RESI(40) + 
     +                 .5*(RMAV3(IA)+RNAV3(IA)+RWAV3(IA))*VOL(IA)
               ENDDO
            ENDDO
         ENDDO

      ENDIF


      IF (NSCAL >= 1) THEN

         DO NS = 1,NSCAL

            DO K = 1,KMAX
               KA = (KN+K-1)*IL + IN
               DO J = 1,JMAX
                  II = (JN+J-1)*ISTRID + KA
                  DO I = 1,IMAX
                     RESI(7+NS) = RESI(7+NS) + DFI(I+II,NS)**2
                     SUM(2+NS)  = SUM(2+NS)  +  FI(I+II,NS)**2
                  ENDDO
               ENDDO
            ENDDO

            RESI(15+NS)= RESI(7+NS)/(SUM(2+NS)+EPS)

         ENDDO

      ENDIF

      DO NS = 6,21
         IF(RESI(NS) == 0.) RESI(NS) = 1.5E-10
      ENDDO
 
      RETURN
      END SUBROUTINE RESL3
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE RESL2(VOL,DRO,DM,DN,DW,DE,DFI,DRK,DEPS,VAR,RESI,RKSI,
     +     IMAX,JMAX,KMAX,ITURB,NSCAL,MAXSB,NRESI,RKLIM,EPSLIM,MULPHL,
     +     NGL,M,M2,PRC)

      USE TYPE_ARRAYS
      USE NS3CO, ONLY : IN, JN, KN, TWO_FLUIDL
      USE CONSTANTS, ONLY : EPS10

      IMPLICIT NONE

      TYPE(MPHASE_VARIABLES) VAR(*)
      TYPE(PRE_COR) PRC(*)

      INTEGER :: ITURB,NSCAL,MAXSB,NRESI,IMAX,JMAX,KMAX,NGL,M,M2,I,J,K,
     &        ISTRID,JSTRID,KSTRID,IL,NTOT,IA,II,KA

      REAL :: RKLIM,EOSLIM,DEPSIA,ADDE1,ADDE2,EPS,EPSLIM,ALFA1,ALFA2

      REAL :: DRO(*),DM(*),DN(*),DW(*),DE(*),RESI(*),RKSI(*),
     &        DFI(MAXSB,MAX(1,NSCAL)),DRK(*),DEPS(*),VOL(*)

      LOGICAL :: MULPHL
C
C ... CALCULATE THE L2-NORM OF THE EXPLICIT RESIDUALS
C
C     RESI 31-37:     L2- norms of explicit residuals
C     RESI 39,41-43:  L2- norms of explicit residuals (multi phase)
C     RESI 62-67:     L2- norms of explicit residuals (multi phase)

      EPS = EPS10

      DO I = 31,37
         RESI(I) = 0.
      ENDDO

      RESI(39)= 0.  

      DO I = 41,43
         RESI(I) = 0.
      ENDDO

      DO I = 62,67
         RESI(I) = 0.
      ENDDO

      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      KSTRID = ISTRID*JSTRID
      IL     = KSTRID
      NTOT   = IMAX*JMAX*KMAX

      DO K = 1,KMAX
         KA = (KN+K-1)*IL + IN
         DO J = 1,JMAX
            II = (JN+J-1)*ISTRID + KA
            DO I = 1,IMAX
               IA = I+II
               IF(RKSI(IA) < 1.0) THEN
                  IF(.NOT. TWO_FLUIDL) THEN
                  RESI(31) = RESI(31) + (DRO(IA))**2
                  RESI(32) = RESI(32) + (DM(IA))**2
                  RESI(33) = RESI(33) + (DN(IA))**2
                  RESI(34) = RESI(34) + (DW(IA))**2
                  ELSEIF(TWO_FLUIDL) THEN
                  RESI(31) = RESI(31) + (VAR(IA)%DX(2)+VAR(IA)%DX(1))**2
                  RESI(32) = RESI(32) + (VAR(IA)%DM(2)+VAR(IA)%DM(1))**2
                  RESI(33) = RESI(33) + (VAR(IA)%DN(2)+VAR(IA)%DN(1))**2
                  RESI(34) = RESI(34) + (VAR(IA)%DW(2)+VAR(IA)%DW(1))**2
                  ENDIF
                  RESI(35) = RESI(35) + (DE(IA))**2
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      IF(ITURB >= 3 .AND. ITURB /= 9) THEN

         DO K = 1,KMAX
            KA = (KN+K-1)*IL + IN
            DO J = 1,JMAX
               II = (JN+J-1)*ISTRID + KA
               DO I = 1,IMAX
                  IA = I+II
                  IF(RKSI(IA) < 1.0) THEN
                     DEPSIA   = MIN(ABS(DEPS(IA)),1.E15)
                     RESI(36) = RESI(36) + (DRK(IA))**2
                     RESI(37) = RESI(37) + (DEPSIA)**2
                  ENDIF
               ENDDO
            ENDDO
         ENDDO

      ELSEIF(ITURB == 9) THEN

         DO K = 1,KMAX
            KA = (KN+K-1)*IL + IN
            DO J = 1,JMAX
               II = (JN+J-1)*ISTRID + KA
               DO I = 1,IMAX
                  IA = I+II
                  IF(RKSI(IA) < 1.0) THEN
                     DEPSIA   = MIN(ABS(DEPS(IA)),1.E10)*1000.
                     RESI(37) = RESI(37) + (DEPSIA)**2
                  ENDIF
               ENDDO
            ENDDO
         ENDDO

         RESI(37) = RESI(37)*1.E-6 ! Scaling because of the large values

      ENDIF

      IF (MULPHL) THEN

         DO K = 1,KMAX
            KA = (KN+K-1)*IL + IN
            DO J = 1,JMAX
               II = (JN+J-1)*ISTRID + KA
               DO I = 1,IMAX
                  IA = I+II
                  IF(RKSI(IA) < 1.0) THEN
                     RESI(39) = RESI(39) + (VAR(IA)%DX(2))**2
                     RESI(41) = RESI(41) + (VAR(IA)%DX(1))**2
                     RESI(42) = RESI(42) + (VAR(IA)%DE(2))**2
                     RESI(43) = RESI(43) + (VAR(IA)%DE(1))**2
                  ENDIF
               ENDDO
            ENDDO
         ENDDO

      ENDIF

      IF (TWO_FLUIDL) THEN

         DO K = 1,KMAX
            KA = (KN+K-1)*IL + IN
            DO J = 1,JMAX
               II = (JN+J-1)*ISTRID + KA
               DO I = 1,IMAX
                  IA = I+II
                  IF(RKSI(IA) < 1.0) THEN
                  ALFA1 = VAR(IA)%ALFA(1)
                  ALFA2 = VAR(IA)%ALFA(2)
             RESI(62) = RESI(62) + (VAR(IA)%DM(2))**2
             RESI(63) = RESI(63) + (VAR(IA)%DM(1))**2
             RESI(64) = RESI(64) + (VAR(IA)%DN(2))**2
             RESI(65) = RESI(65) + (VAR(IA)%DN(1))**2
             RESI(66) = RESI(66) + (VAR(IA)%DW(2))**2
             RESI(67) = RESI(67) + (VAR(IA)%DW(1))**2

c                     RESI(62) = RESI(62) + (VAR(IA)%DM(2)-
c     +                          VAR(IA)%U(2)*VAR(IA)%DX(2))**2
c                     RESI(63) = RESI(63) + (VAR(IA)%DM(1)-
c     +                          VAR(IA)%U(1)*VAR(IA)%DX(1))**2
c                     RESI(64) = RESI(64) + (VAR(IA)%DN(2)-
c     +                          VAR(IA)%V(2)*VAR(IA)%DX(2))**2
c                     RESI(65) = RESI(65) + (VAR(IA)%DN(1)-
c     +                          VAR(IA)%V(1)*VAR(IA)%DX(1))**2
c                     RESI(66) = RESI(66) + (VAR(IA)%DW(2)-
c     +                          VAR(IA)%W(2)*VAR(IA)%DX(2))**2
c                     RESI(67) = RESI(67) + (VAR(IA)%DW(1)-
c     +                          VAR(IA)%W(1)*VAR(IA)%DX(1))**2
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
         RESI(62) = MAX(RESI(62),1.E-6*NTOT**2) ! Was EPS10
         RESI(63) = MAX(RESI(63),1.E-6*NTOT**2)
         RESI(64) = MAX(RESI(64),1.E-6*NTOT**2)
         RESI(65) = MAX(RESI(65),1.E-6*NTOT**2)
         RESI(66) = MAX(RESI(66),1.E-6*NTOT**2)
         RESI(67) = MAX(RESI(67),1.E-6*NTOT**2)
         RESI(42) = MAX(RESI(42),1.E6 *NTOT**2) ! Looks better
         RESI(43) = MAX(RESI(43),1.E6 *NTOT**2) ! Lower level 1E3
         RESI(39) = MAX(RESI(39),1.E-6*NTOT**2)
         RESI(41) = MAX(RESI(41),1.E-6*NTOT**2)

      ENDIF

      RETURN
      END SUBROUTINE RESL2
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SUMFU(SUMP,P,VOL,IMAX,JMAX,KMAX,PLIM)

      USE NS3CO, ONLY : IN, JN, KN

      IMPLICIT NONE

      REAL, DIMENSION(*) :: P, VOL
      REAL :: SUMP, PLIM

      INTEGER :: IMAX, JMAX, KMAX, ISTRID, JSTRID, IL
      INTEGER :: I, J, K, KA, II
C
C ... CALCULATE THE AVERAGE PROPERTY INSIDE THE BLOCK
C
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID

      SUMP = 0.0

      DO K = 1,KMAX
         KA = (KN+K-1)*IL + IN
         DO J = 1,JMAX
            II = (JN+J-1)*ISTRID + KA
            DO I = 1,IMAX
               SUMP = SUMP + (P(I+II)-PLIM)*VOL(I+II)
            ENDDO
         ENDDO
      ENDDO

      RETURN
      END SUBROUTINE SUMFU
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SUMFA(SUMP,P,VOL,ROG,IMAX,JMAX,KMAX,PLIM)

      USE NS3CO, ONLY : IN, JN, KN

      IMPLICIT NONE

      REAL, DIMENSION(*) :: P, VOL, ROG
      REAL :: SUMP, PLIM

      INTEGER :: IMAX, JMAX, KMAX, ISTRID, JSTRID, IL
      INTEGER :: I, J, K, KA, II
C
C ... CALCULATE THE AVERAGE PROPERTY INSIDE THE BLOCK
C
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID

      SUMP = 0.0

      DO K = 1,KMAX
         KA = (KN+K-1)*IL + IN
         DO J = 1,JMAX
            II = (JN+J-1)*ISTRID + KA
            DO I = 1,IMAX
               SUMP = SUMP + (P(I+II)-PLIM)*ROG(I+II)*VOL(I+II)
            ENDDO
         ENDDO
      ENDDO

      RETURN
      END SUBROUTINE SUMFA
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SUMDRO(SUMP,P,VOL,IMAX,JMAX,KMAX)

      USE NS3CO, ONLY : IN, JN, KN

      IMPLICIT NONE

      REAL, DIMENSION(*) :: P, VOL
      REAL :: SUMP

      INTEGER :: IMAX, JMAX, KMAX, ISTRID, JSTRID, IL
      INTEGER :: I, J, K, KA, II
C
C ... CALCULATE THE AVERAGE PROPERTY INSIDE THE BLOCK
C
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID

      DO K = 1,KMAX
         KA = (KN+K-1)*IL + IN
         DO J = 1,JMAX
            II = (JN+J-1)*ISTRID + KA
            DO I = 1,IMAX
               SUMP = SUMP + P(I+II)
            ENDDO
         ENDDO
      ENDDO 

      RETURN
      END SUBROUTINE SUMDRO
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SUUFU(SUMP,RM,RN,RW,RO,VOL,IMAX,JMAX,KMAX,RKILIM)

      USE NS3CO, ONLY : IN, JN, KN

      IMPLICIT NONE

      REAL, DIMENSION(*) :: RM, RN, RW, RO, VOL
      REAL :: SUMP, RKILIM, XKIN

      INTEGER :: IMAX, JMAX, KMAX, ISTRID, JSTRID, IL
      INTEGER :: I, J, K, KA, II, IA
C
C ... CALCULATE THE TOTAL KINETIC ENERGY INSIDE THE BLOCK
C
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID

      SUMP = 0.

      DO K = 1,KMAX
         KA = (KN+K-1)*IL + IN
         DO J = 1,JMAX
            II = (JN+J-1)*ISTRID + KA
            DO I = 1,IMAX
               IA = I + II
               XKIN = .5*(RM(IA)**2 + RN(IA)**2 + RW(IA)**2)/RO(IA)
               SUMP = SUMP + (XKIN-RKILIM)*VOL(IA)
            ENDDO
         ENDDO
      ENDDO 

      RETURN
      END SUBROUTINE SUUFU
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SUEFU(SUME,REPS,RK,RO,VOL,IMAX,JMAX,KMAX,EPSLIM)

      USE NS3CO, ONLY : IN, JN, KN

      IMPLICIT NONE

      REAL, DIMENSION(*) :: VOL, REPS, RK, RO
      REAL :: SUME, EPSLIM

      INTEGER :: IMAX, JMAX, KMAX, ISTRID, JSTRID, IL
      INTEGER :: I, J, K, KA, II, IA
C
C ... CALCULATE THE AVERAGE PROPERTY INSIDE THE BLOCK
C
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID

      SUME = 0.0

      DO K = 1,KMAX
         KA = (KN+K-1)*IL + IN
         DO J = 1,JMAX
            II = (JN+J-1)*ISTRID + KA
            DO I = 1,IMAX
               IA = I + II
               SUME = SUME + 0.09*(REPS(IA)-EPSLIM)*RK(IA)/
     &                RO(IA)*VOL(IA)
            ENDDO
         ENDDO
      ENDDO 

      RETURN
      END SUBROUTINE SUEFU
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE DROMXX(DRO,NTOT1,N,IXERR,INERR,DROMAX,
     +     IMAX,JMAX,KMAX)

      REAL :: DRO(*)

C ... THIS PROGRAM CALCULATES MAXIMUM CHANGE PER ITERATION CYCLE

      DO 1000 L = 1,NTOT1
         APU     = ABS(DRO(L))
         IF(APU > ABS(DROMAX)*1.000001) THEN
            CALL IJKPAI(L,IMAX,JMAX,KMAX,II,JJ,KK)
            IF(II <= 0 .OR. II > IMAX) APU = APU*.99999 ! unweight ghost 
            IF(JJ <= 0 .OR. JJ > JMAX) APU = APU*.99999 ! unweight ghost 
            IF(KK <= 0 .OR. KK > KMAX) APU = APU*.99999 ! unweight ghost 
            IF(APU > ABS(DROMAX)) THEN
               IXERR  = L
               INERR  = N
               DROMAX = APU
            ENDIF
         ENDIF
 1000 CONTINUE
       
      IF (N == INERR) THEN
         DROMAX  = DRO(IXERR)
         CALL IJKPAI(IXERR,IMAX,JMAX,KMAX,II,JJ,KK)
         IF(II <= 0 .OR. II > IMAX) DROMAX = DROMAX*.99999 ! unweight ghost 
         IF(JJ <= 0 .OR. JJ > JMAX) DROMAX = DROMAX*.99999 ! unweight ghost 
         IF(KK <= 0 .OR. KK > KMAX) DROMAX = DROMAX*.99999 ! unweight ghost 
      ENDIF

      RETURN
      END SUBROUTINE DROMXX
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE ZEROZZ(TAUL,NTOT)

      REAL :: TAUL(NTOT)
C
C ... INITIALIZATION TO ZERO
C
      TAUL = 0.

      RETURN
      END SUBROUTINE ZEROZZ
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SETVAL(TAUL,VAL,NTOT)

      REAL :: TAUL(*)
C
C ... SET THE CONSTANT VALUE 'VAL' TO AN ARRAY
C ... taitaa olla sama kuin adjust
C
      DO 1 L = 1,NTOT
1     TAUL(L)= VAL

      RETURN
      END SUBROUTINE SETVAL
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SETV12(TAU1,TAU2,NTOT)

      REAL :: TAU1(*), TAU2(*)
C
C ... ADJUST THE ARRAY 2 TO ARRAY 1
C
      DO 1 L = 1,NTOT
         TAU1(L)= TAU2(L)
 1    CONTINUE

      RETURN
      END SUBROUTINE SETV12
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SETVDD(TAU1,TAU2,NTOT)

      REAL :: TAU1(*), TAU2(*)
C
C ... ADJUST ARRAY 2 TO ARRAY 1
C
      DO L = 1,NTOT
         TAU1(L)= TAU2(L)
      ENDDO

      RETURN
      END SUBROUTINE SETVDD
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE ADDV12(TAU1,TAU2,NTOT)

      REAL :: TAU1(*), TAU2(*)
C
C ... ADD VECTOR 2 TO VECTOR 1 AND STORE IN VECTOR 1
C
      DO 1 L = 1,NTOT
         TAU1(L) = TAU1(L) + TAU2(L)
 1    CONTINUE

      RETURN
      END SUBROUTINE ADDV12
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE MULV12(TAU1,TAU2,NTOT)

      REAL :: TAU1(*),TAU2(*)
C
C ... INNER PRODUCT OF TWO VECTORS
C
      DO 1 L = 1,NTOT
         TAU1(L) = TAU1(L) * TAU2(L)
 1    CONTINUE

      RETURN
      END SUBROUTINE MULV12
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE DIVV12(TAU1,TAU2,TAU3,NTOT)

      REAL :: TAU1(*), TAU2(*), TAU3(*)
C
C ... DIVIDE VECTORS
C
      DO 1 L = 1,NTOT
         TAU1(L) = TAU2(L)/TAU3(L)
 1    CONTINUE

      RETURN
      END SUBROUTINE DIVV12
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE ADJUIN(TAUL,VALUE,IMAX,JMAX,KMAX,IN,JN,KN)

      REAL :: TAUL(*)
C
C ... ADJUST THE VALUE OF AN ARRAY FOR INTERNAL CELLS
C
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID
      KK     = (KN-1)*IL + (JN-1)*ISTRID + IN

      DO 1 K = 1,KMAX
      JJ     = KK + K*IL
      DO 1 J = 1,JMAX
      II     = JJ + J*ISTRID
      DO 1 I = 1,IMAX
      L      = II + I
1     TAUL(L)= VALUE

      RETURN
      END SUBROUTINE ADJUIN
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE ADJUPRO(PRO,VALUE,IMAX,JMAX,KMAX,IN,JN,KN)

      USE TYPE_ARRAYS
      TYPE(PROPERTIES) PRO(*)
C
C ... ADJUST THE VALUE OF AN ARRAY FOR INTERNAL CELLS
C
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID
      KK     = (KN-1)*IL + (JN-1)*ISTRID + IN

      DO K = 1,KMAX
      JJ     = KK + K*IL
      DO J = 1,JMAX
      II     = JJ + J*ISTRID
      DO I = 1,IMAX
      L      = II + I
      PRO(L)%FD(1)   = VALUE
      PRO(L)%FD(2)   = VALUE
      PRO(L)%FD(3)   = VALUE
      PRO(L)%FL(1)   = VALUE
      PRO(L)%FL(2)   = VALUE
      PRO(L)%FL(3)   = VALUE
      PRO(L)%FTD(1)  = VALUE
      PRO(L)%FTD(2)  = VALUE
      PRO(L)%FTD(3)  = VALUE
      PRO(L)%FVM(1)  = VALUE
      PRO(L)%FVM(2)  = VALUE
      PRO(L)%FVM(3)  = VALUE
      PRO(L)%FITOT(1)= VALUE
      PRO(L)%FITOT(2)= VALUE
      PRO(L)%FITOT(3)= VALUE

      ENDDO; ENDDO; ENDDO
      RETURN
      END SUBROUTINE ADJUPRO
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE ADJUVAR(PRC,VALUE,IMAX,JMAX,KMAX,IN,JN,KN)

      USE TYPE_ARRAYS
      TYPE(PRE_COR) PRC(*)
C
C ... ADJUST THE VALUE OF AN ARRAY FOR INTERNAL CELLS
C
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID
      KK     = (KN-1)*IL + (JN-1)*ISTRID + IN

      DO K = 1,KMAX
      JJ     = KK + K*IL
      DO J = 1,JMAX
      II     = JJ + J*ISTRID
      DO I = 1,IMAX
      L      = II + I
      PRC(L)%DPDX    = VALUE
      PRC(L)%DPDY    = VALUE
      PRC(L)%DPDZ    = VALUE

      ENDDO; ENDDO; ENDDO
      RETURN
      END SUBROUTINE ADJUVAR
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE ADJVIN(TAUL,VALUE,IMAX,JMAX,KMAX,IN,JN,KN)

      REAL :: TAUL(*), VALUE(*)
C
C ... ADJUST THE VALUE OF AN ARRAY FOR INTERNAL CELLS
C
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID
      KK     = (KN-1)*IL + (JN-1)*ISTRID + IN

      DO 1 K = 1,KMAX
      JJ     = KK + K*IL
      DO 1 J = 1,JMAX
      II     = JJ + J*ISTRID
      DO 1 I = 1,IMAX
      L      = II + I
1     TAUL(L)= TAUL(L) + VALUE(L)

      RETURN
      END SUBROUTINE ADJVIN
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SETVIN(TAUL,VALUE,IMAX,JMAX,KMAX,IN,JN,KN)

      REAL :: TAUL(*), VALUE(*)
C
C ... ADJUST THE VALUE OF AN ARRAY FOR INTERNAL CELLS
C
      ISTRID = IMAX + 2*IN
      JSTRID = JMAX + 2*JN
      IL     = ISTRID*JSTRID
      KK     = (KN-1)*IL + (JN-1)*ISTRID + IN

      DO 1 K = 1,KMAX
      JJ     = KK + K*IL
      DO 1 J = 1,JMAX
      II     = JJ + J*ISTRID
      DO 1 I = 1,IMAX
      L      = II + I
1     TAUL(L)= VALUE(L)

      RETURN
      END SUBROUTINE SETVIN
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SURVEL(XCO,YCO,ZCO,OMEGA,IMAX,JMAX,KMAX,IBOT,ITOP,JBOT,
     +     JTOP,KBOT,KTOP,IDI1,IDI2,IDI3,INRE,JNRE,KNRE,
     +     UBI,HFLUX,F1R,F1RM,F1RN,NBL,M,NPATCH,ICON,RCON,IHF,
     +     VOL,A1,A1X,ISTATE,IB,MAXB,OMEX,OMEY,OMEZ,CENX,CENY,CENZ)

      USE NS3CO, ONLY : IC9
      
      INTEGER :: IMAX, JMAX, KMAX, IN, JN, KN, INRE, JNRE, KNRE

      REAL :: YCO(*),ZCO(*),XCO(*)
      DIMENSION :: ICON(IC9,*),RCON(IC9,*),VOL(*),A1(MAXB,*),UBI(IB,*),
     +     A1X(MAXB,*),IHF(*),HFLUX(*),F1R(*),F1RM(*),F1RN(*)
      CHARACTER(LEN=3) :: FILEE
      CHARACTER(LEN=4) :: FILE4

      IN = INRE
      JN = JNRE
      KN = KNRE

      KSTRID  = KMAX + 2*KN
      JSTRID  = JMAX + 2*JN
      ISTRID  = IMAX + 2*IN
      IL      = ISTRID*JSTRID

C ... LOOP OVER THE PATCHES OF THE BLOCK 

      DO 7000 IP = 1,NPATCH
      IBC     = ICON(1,IP)
      IF(IBC == 9 .OR. IBC == 10) THEN
      IFACE   = ICON(3,IP)
      IXLO    = ICON(4,IP)
      IXUP    = ICON(5,IP)
      IYLO    = ICON(6,IP)
      IYUP    = ICON(7,IP)
      IDIR    = 1
      IMOV    = ICON(9,IP)
      XVEL    = RCON(1,IP)
      YVEL    = RCON(2,IP)
      ZVEL    = RCON(3,IP)
      VEL     = RCON(4,IP)
      IF(IFACE >= 4) IDIR = -1
C ... XI-DIRECTION
      IF(IFACE == 1 .OR. IFACE == 4) THEN
         IN   = JNRE
         JN   = KNRE
         KN   = INRE
         ISTR = ISTRID
         JSTR = IL
         KSTR = 1
         K    = IBOT
         I1   = IXLO
         I2   = IXUP
         J1   = IYLO
         J2   = IYUP
         ID   = IDI1
         JST2 = JSTRID
         IUP  = 1
         IAP  = 1
         IF(IFACE == 4) THEN
            K   = ITOP + 1
            IUP  = 10
         ENDIF
C ... ETA-DIRECTION
      ELSEIF(IFACE == 2 .OR. IFACE == 5) THEN
         IN   = KNRE
         JN   = INRE
         KN   = JNRE
         ISTR = IL
         JSTR = 1
         KSTR = ISTRID
         K    = JBOT
         I1   = IYLO
         I2   = IYUP
         J1   = IXLO
         J2   = IXUP
         ID   = IDI2
         JST2 = KSTRID
         IUP  = 4
         IAP  = 2
         IF(IFACE == 5) THEN
            K   = JTOP + 1
            IUP  = 13
         ENDIF
C ... ZETA DIRECTION
      ELSEIF(IFACE == 3 .OR. IFACE == 6) THEN
         IN   = INRE
         JN   = JNRE
         KN   = KNRE
         ISTR = 1
         JSTR = ISTRID
         KSTR = IL
         K = KBOT
         I1   = IXLO
         I2   = IXUP
         J1   = IYLO
         J2   = IYUP
         ID   = IDI3
         JST2 = ISTRID
         IUP  = 7
         IAP  = 3
         IF(IFACE == 6) THEN
            K   = KTOP + 1
            IUP  = 16
         ENDIF
      ENDIF
      
C ... ROTATING SOLID

      IF(IBC == 9) THEN
      VELAVE = 0.
      DO 1000 J = J1,J2
         KK      = (JN+J-1)*JSTR + (KN+K-1)*KSTR
         N1      = (JN+J-1)*JST2 + IN
         DO 1000 I = I1,I2
            IC      = I  + N1          ! PATCH VELOCITY INDEX
            L       = 1 + (IN+I-1)*ISTR + KK
            L2      = 1 + (IN+I  )*ISTR + KK
            L3      = 1 + (IN+I-1)*ISTR + KK + JSTR
            L4      = 1 + (IN+I  )*ISTR + KK + JSTR
            LB      = L - IDIR*KSTR
            LT      = L + IDIR*KSTR
            ZAVE = .25*(ZCO(L) + ZCO(L2) + ZCO(L3) + ZCO(L4))-CENZ 
            YAVE = .25*(YCO(L) + YCO(L2) + YCO(L3) + YCO(L4))-CENY
            XAVE = .25*(XCO(L) + XCO(L2) + XCO(L3) + XCO(L4))-CENX
            UBI(IC,IUP)    = OMEGA*(OMEY*ZAVE - OMEZ*YAVE)
            UBI(IC,IUP+1)  = OMEGA*(OMEZ*XAVE - OMEX*ZAVE)
            UBI(IC,IUP+2)  = OMEGA*(OMEX*YAVE - OMEY*XAVE)
            VELAVE = VELAVE + SQRT(UBI(IC,IUP)**2+UBI(IC,IUP+1)**2+
     +           UBI(IC,IUP+2)**2)
 1000 CONTINUE
      VELAVE = VELAVE/REAL((J2-J1+1)*(I2-I1+1))
      WRITE(45,*) 'Block =',NBL,' MG=',M
      WRITE(45,*)'Average velocity of the rotating patch'
     +     ,IP,' is',VELAVE
      WRITE(45,*)
C ... MOVING SOLID
      ELSEIF(IBC == 10 .AND. IMOV == 1) THEN
      WRITE(45,*) 'Block =',NBL,' MG=',M
      WRITE(45,101) IP,XVEL,YVEL,ZVEL,SQRT(XVEL**2+YVEL**2+ZVEL**2)
 101  FORMAT(/'Patch' ,I4,' is moving solid with velocity:',3F10.5,'.'/
     +     'Total velocity is ',F10.5/)
      DO 1100 J = J1,J2
         KK      = (JN+J-1)*JSTR + (KN+K-1)*KSTR
         N1      = (JN+J-1)*JST2 + IN
         DO 1100 I = I1,I2
            IC      = I  + N1          ! PATCH VELOCITY INDEX
            L       = 1 + (IN+I-1)*ISTR + KK
            L2      = 1 + (IN+I  )*ISTR + KK
            L3      = 1 + (IN+I-1)*ISTR + KK + JSTR
            L4      = 1 + (IN+I  )*ISTR + KK + JSTR
            LB      = L - IDIR*KSTR
            LT      = L + IDIR*KSTR
            UBI(IC,IUP)    = XVEL
            UBI(IC,IUP+1)  = YVEL
            UBI(IC,IUP+2)  = ZVEL
 1100 CONTINUE
C ... MOVING SOLID2
      ELSEIF(IBC == 10 .AND. IMOV == 2) THEN
      WRITE(45,*) 'Block =',NBL,' MG=',M
      XNOR = SQRT(XVEL**2+YVEL**2+ZVEL**2)
      R1   = XVEL/XNOR
      R2   = YVEL/XNOR
      R3   = ZVEL/XNOR
      WRITE(45,111) IP,R1,R2,R3,VEL
 111  FORMAT(/'Patch' ,I4,' is tangentially moving solid.',
     +     ' Direction of solid is:',3F10.5,'.'/
     +     'Total velocity is ',F10.5/)
C ... DIRECTION IS CALCULATED AS: 
C ... VEC{V} = NORM{VEC{N}x(VEC{R}xVEC{N})}*VEL

      DO 1200 J = J1,J2
         KK      = (JN+J-1)*JSTR + (KN+K-1)*KSTR
         N1      = (JN+J-1)*JST2 + IN
         DO 1200 I = I1,I2
            IC      = I  + N1          ! PATCH VELOCITY INDEX
            L       = 1 + (IN+I-1)*ISTR + KK
            L2      = 1 + (IN+I  )*ISTR + KK
            L3      = 1 + (IN+I-1)*ISTR + KK + JSTR
            L4      = 1 + (IN+I  )*ISTR + KK + JSTR
            LB      = L - IDIR*KSTR
            LT      = L + IDIR*KSTR
C ... VEC{N} =
            XN1     = A1X(L,1+(IAP-1)*3)
            XN2     = A1X(L,2+(IAP-1)*3)
            XN3     = A1X(L,3+(IAP-1)*3)
C ... VEC{R}xVEC{N}=
            XA1      = R2*XN3 - R3*XN2
            XA2      = R3*XN1 - R1*XN3
            XA3      = R1*XN2 - R2*XN1
            XNORM = SQRT(XA1**2 + XA2**2 + XA3**2)
            IF(XNORM <= 1.E-6) THEN
               WRITE(*,*) 'Unknown direction for moving solid in patch',
     +              IP
               WRITE(*,*) 'A1,A2,A3:',XA1,XA2,XA3
               WRITE(*,*) 'R1,R2,R3:',R1,R2,R3
               WRITE(*,*) 'in place (i,j,k)',I,J,K
               WRITE(*,*) 'Exiting ...'
               STOP
            ENDIF
            XA1 = XA1/XNORM
            XA2 = XA2/XNORM
            XA3 = XA3/XNORM
C ... VEC{V} = NORM{VEC{N}x(VEC{R}xVEC{N})}*
            B1      = XN2*XA3 - XN3*XA2
            B2      = XN3*XA1 - XN1*XA3
            B3      = XN1*XA2 - XN2*XA1
            XNORM = SQRT(B1**2 + B2**2 + B3**2)
            IF(ABS(XNORM-1.) >= 1.E-5) THEN
               WRITE(*,*) 'Somethin wrong in moving solid',
     +              ' in place (i,j,k)',I,J,K
               WRITE(*,*) 'Exiting ...'
               STOP
            ENDIF
            UBI(IC,IUP)    = B1*VEL
            UBI(IC,IUP+1)  = B1*VEL
            UBI(IC,IUP+2)  = B1*VEL
c            DIST    = .5*(A1(L,IAP)+A1(LT,IAP))/VOL(L)
 1200 CONTINUE
C ... MOVING SOLID3
      ELSEIF(IBC == 10 .AND. IMOV == 3) THEN
      WRITE(45,*) 'Block =',NBL,' MG=',M
      XNOR = SQRT(XVEL**2+YVEL**2+ZVEL**2)
      R1   = XVEL/XNOR
      R2   = YVEL/XNOR
      R3   = ZVEL/XNOR
      WRITE(45,113) IP,R1,R2,R3,VEL
 113  FORMAT(/'Patch' ,I4,' is rotationally moving solid.'/
     +     ' Rotational axis is:',3F8.3,'.'/
     +     'Angularvelocity is ',F10.5,' 1/rad')
C ... DIRECTION IS CALCULATED AS: 
C ... VEC{V} = NORM{(VEC{R}xVEC{X}}*VEL
      VELAVE = 0.
      DO 1300 J = J1,J2
         KK      = (JN+J-1)*JSTR + (KN+K-1)*KSTR
         N1      = (JN+J-1)*JST2 + IN
         DO 1300 I = I1,I2
            IC      = I  + N1          ! PATCH VELOCITY INDEX
            L       = 1 + (IN+I-1)*ISTR + KK
            L2      = 1 + (IN+I  )*ISTR + KK
            L3      = 1 + (IN+I-1)*ISTR + KK + JSTR
            L4      = 1 + (IN+I  )*ISTR + KK + JSTR
            LB      = L - IDIR*KSTR
            LT      = L + IDIR*KSTR
            XAVE    = .25*(XCO(L) + XCO(L2) + XCO(L3) + XCO(L4)) 
            YAVE    = .25*(YCO(L) + YCO(L2) + YCO(L3) + YCO(L4))
            ZAVE    = .25*(ZCO(L) + ZCO(L2) + ZCO(L3) + ZCO(L4)) 

            UBI(IC,IUP+2)  = VEL*(R1*YAVE - R2*XAVE)
            UBI(IC,IUP)    = VEL*(R2*ZAVE - R3*YAVE)
            UBI(IC,IUP+1)  = VEL*(R3*XAVE - R1*ZAVE)
            VELAVE = VELAVE + SQRT(UBI(IC,IUP)**2+UBI(IC,IUP+1)**2+
     +           UBI(IC,IUP+2)**2)
 1300 CONTINUE
      VELAVE = VELAVE/REAL((J2-J1+1)*(I2-I1+1))
      WRITE(45,*)'Average velocity of the moving patch',IP,' is',VELAVE
      WRITE(45,*)
      ELSE
         WRITE(*,*) 'Error in patch',IP
         WRITE(*,*) 'Non existing moving solid type:',IMOV
         WRITE(*,*) 'Exiting ...'
         STOP
      ENDIF
         
      ENDIF                     ! IBC == 9 .OR. IBC == 10
7000  CONTINUE ! LOOP OVER THE PATCHES

C ... heat flux calculations
      DO 8000 IP = 1,NPATCH
         IBC     = ICON(1,IP)
         IPL     = ICON(2,IP) ! proces local patch number
         IHEAT   = ICON(20,IP)
         IDIR    = 1
         IF(IBC >= 8 .AND. IBC <= 10 .AND. IHEAT /= 0) THEN
            IFACE   = ICON(3,IP)
      IF(IFACE >= 4) IDIR = -1
C ... XI-DIRECTION
      IF(IFACE == 1 .OR. IFACE == 4) THEN
         IN   = JNRE
         JN   = KNRE
         KN   = INRE
         ISTR = ISTRID
         JSTR = IL
         KSTR = 1
         K    = IBOT
         ID   = IDI1
         JST2 = JSTRID
         IF(IFACE == 4) K   = ITOP + 1
C ... ETA-DIRECTION
      ELSEIF(IFACE == 2 .OR. IFACE == 5) THEN
         IN   = KNRE
         JN   = INRE
         KN   = JNRE
         ISTR = IL
         JSTR = 1
         KSTR = ISTRID
         K    = JBOT
         ID   = IDI2
         JST2 = KSTRID
         IF(IFACE == 5) K   = JTOP + 1
C ... ZETA DIRECTION
      ELSEIF(IFACE == 3 .OR. IFACE == 6) THEN
         IN   = INRE
         JN   = JNRE
         KN   = KNRE
         ISTR = 1
         JSTR = ISTRID
         KSTR = IL
         K = KBOT
         ID   = IDI3
         JST2 = ISTRID
         IF(IFACE == 6) K   = KTOP + 1
      ENDIF

      KX1 = ICON(4,IP)
      KX2 = ICON(5,IP)
      KY1 = ICON(6,IP)
      KY2 = ICON(7,IP)

      IF(ICON(3,IP) ==  2 .OR. ICON(3,IP) == 5) THEN
         KY1 = ICON(4,IP)
         KY2 = ICON(5,IP)
         KX1 = ICON(6,IP)
         KX2 = ICON(7,IP)
      ENDIF

      LSTRID  = KSTR*IDIR
      IF(IDIR ==  1) NFL = 0
      IF(IDIR == -1) NFL = -LSTRID
      KA      = (KN+KBOT-1)*KSTR

      IF(IHEAT == 1) THEN
       DO J = KY1,KY2
          IJ      = (JN+J-1)*JSTR + KA
          NN      = (J-KY1)*(KX2-KX1+1)
          N1      = (JN+J-1)*ISTRID + IN
          DO I = KX1,KX2
             II      = (IN+I-1)*ISTR  + IJ + 1 ! CELL INDEX (STRIDE=ISTR)
             II1     = II + LSTRID             ! THE SECOND CELL
             IF      = II + NFL                ! FLUX INDEX
             NI      = I  + N1                 ! PATCH VELOCITY INDEX
             NH      = NN + I-KX1 + IHF(IPL)   ! Patch temperature index
             HFLUX(NH) = RCON(5,IP)
          ENDDO
       ENDDO
      ELSEIF(IHEAT == 2) THEN
       DO J = KY1,KY2
          IJ      = (JN+J-1)*JSTR + KA
          NN      = (J-KY1)*(KX2-KX1+1)
          N1      = (JN+J-1)*ISTRID + IN
          DO I = KX1,KX2
             II      = (IN+I-1)*ISTR  + IJ + 1 ! CELL INDEX (STRIDE=ISTR)
             II1     = II + LSTRID             ! THE SECOND CELL
             IF      = II + NFL                ! FLUX INDEX
             NI      = I  + N1                 ! PATCH VELOCITY INDEX
             NH      = NN + I-KX1  + IHF(IPL)  ! Patch temperature index
             HFLUX(NH) = RCON(6,IP)
          ENDDO
       ENDDO

      ELSEIF(IHEAT == 13) THEN ! viritys

       DO J = KY1,KY2
          KK      = (JN+J-1)*JSTR + (KN+K-1)*KSTR
          IJ      = (JN+J-1)*JSTR + KA
          NN      = (J-KY1)*(KX2-KX1+1)
          N1      = (JN+J-1)*ISTRID + IN
          DO I = KX1,KX2
            L       = 1 + (IN+I-1)*ISTR + KK
            L2      = 1 + (IN+I  )*ISTR + KK
            L3      = 1 + (IN+I-1)*ISTR + KK + JSTR
            L4      = 1 + (IN+I  )*ISTR + KK + JSTR

             II      = (IN+I-1)*ISTR  + IJ + 1 ! CELL INDEX (STRIDE=ISTR)
             II1     = II + LSTRID             ! THE SECOND CELL
             IF      = II + NFL                ! FLUX INDEX
             NI      = I  + N1                 ! PATCH VELOCITY INDEX
             NH      = NN + I-KX1  + IHF(IPL)  ! Patch temperature index
             XAVE    = .25*(XCO(L) + XCO(L2) + XCO(L3) + XCO(L4))
             
             HFLUX(NH) =(50.+290.*SIN(XAVE/2.44*3.14159))/(3.14159*0.91)
     +            *10000.
c             WRITE(78,*) XAVE,HFLUX(NH),NH
          ENDDO
       ENDDO
      ELSEIF(IHEAT == 14) THEN ! toinen viritys
       IPGLO = ICON(25,IP)    ! global patch number
       INAM  = INT(RCON(6,IP))
       CALL NUMCH3(FILEE,INAM)
       OPEN(51,FILE='THERMO'//FILEE,STATUS='OLD',FORM='FORMATTED')
       I = 1
 11    READ(51,*,END=4) F1R(I),F1RM(I)
       I = I + 1
       GOTO 11
 4     CONTINUE
       CLOSE(51)
       NNIMAX = I -1

       DO J = KY1,KY2
          KK      = (JN+J-1)*JSTR + (KN+K-1)*KSTR
          IJ      = (JN+J-1)*JSTR + KA
          NN      = (J-KY1)*(KX2-KX1+1)
          N1      = (JN+J-1)*ISTRID + IN
          DO I = KX1,KX2
            L       = 1 + (IN+I-1)*ISTR + KK
            L2      = 1 + (IN+I  )*ISTR + KK
            L3      = 1 + (IN+I-1)*ISTR + KK + JSTR
            L4      = 1 + (IN+I  )*ISTR + KK + JSTR

             II      = (IN+I-1)*ISTR  + IJ + 1 ! CELL INDEX (STRIDE=ISTR)
             II1     = II + LSTRID             ! THE SECOND CELL
             IF      = II + NFL                ! FLUX INDEX
             NI      = I  + N1                 ! PATCH VELOCITY INDEX
             NH      = NN + I-KX1  + IHF(IPL)  ! Patch temperature index
             XAVE    = .25*(XCO(L) + XCO(L2) + XCO(L3) + XCO(L4))
 333         format(2I4,4F10.5)

             DO KK3 = 1,NNIMAX-1
                IF(F1R(KK3) <= XAVE .AND. F1R(KK3+1) > XAVE) THEN
                   XRES2 = (XAVE - F1R(KK3))/(F1R(KK3+1)-F1R(KK3))
                   XRES1 = 1. - XRES2 
                   HFLUX(NH) = XRES1*F1RM(KK3) + XRES2*F1RM(KK3+1)
                   GOTO 313
                ENDIF
             ENDDO
             WRITE(*,*) 'no hit',IPGLO,I,J,XAVE
             STOP
 313         CONTINUE
           
c             WRITE(78,*) XAVE,HFLUX(NH),NH
          ENDDO
       ENDDO
      ELSEIF(IHEAT == 11 .OR. IHEAT == 12) THEN
       IPGLO = ICON(25,IP)    ! global patch number
       IMAX1 = KX2-KX1+1
       JMAX1 = KY2-KY1+1
       CALL NUMCH3(FILEE,IPGLO)
       OPEN(51,FILE='THERMO'//FILEE,STATUS='OLD',FORM='FORMATTED')
       READ(51,*) IMAX0,JMAX0
      IF ((MOD(IMAX0,IMAX1) /= 0) .OR. (MOD(JMAX0,JMAX1) /= 0)) THEN
         WRITE(*,*) 'In inlet file:',imax0,jmax0
         WRITE(*,*) 'In INPUT file:',imax ,jmax
         WRITE(*,*) 'DIMENSIONS AND LEVEL DO NOT FIT IN FILE ',
     +        'THERMO'//FILEE
         WRITE(*,*) 'EXITING...'
*         CALL EXIT
         STOP
      ENDIF
      IF (IMAX0/IMAX1 /= JMAX0/JMAX1 .AND. IMAX0 /= 1 .AND.
     +      JMAX0 /= 1) THEN
         WRITE(*,*) 'In inlet file:',imax0,jmax0
         WRITE(*,*) 'In INPUT file:',imax ,jmax
         WRITE(*,*) 'DIMENSIONS AND LEVEL DO NOT FIT IN FILE ',
     +        'THERMO'//FILEE
         WRITE(*,*) 'EXITING...'
*         CALL EXIT
         STOP
      ENDIF
      NDIVI = INT(IMAX0/IMAX1)
      NDIVJ = INT(JMAX0/JMAX1)
      NTWO    = NDIVI*NDIVJ
      NONE1I  = NDIVI-1
      NONE1J  = NDIVJ-1

      DO N = 1,IMAX1*JMAX1  ! initialized
         HFLUX(N + IHF(IPL) - 1)  = 0.
      ENDDO
      
      DO J = 1,JMAX1
         IG = (J-1)*IMAX1
         DO J2= 0,NONE1J
            DO I = 1,IMAX1
               IA = IG + I
               DO I2= 0,NONE1I
                  READ(51,*) APU1
                  HFLUX(IA + IHF(IPL) - 1)  = HFLUX(IA+IHF(IPL)-1)+APU1
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      
      DO N  = 1,IMAX1*JMAX1
         HFLUX(N + IHF(IPL) - 1)  = HFLUX(N + IHF(IPL) - 1)/NTWO
      ENDDO
      
      CLOSE(51)
      
      ELSEIF(IHEAT == 15) THEN
         WRITE(45,*) 'IHEAT = 15'
      ELSE                      !(IHEAT == 1)
         WRITE(*,*) 'no such solid tempperature boundary condition'
         WRITE(*,*) 'Exiting ...'
         STOP
      ENDIF                     !(IHEAT == 1)
      ENDIF                     ! (IBC >= 8 ....)

 8000 CONTINUE

      RETURN
      END SUBROUTINE SURVEL
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SURVAR(XCO,YCO,ZCO,OMEGA,IMAX,JMAX,KMAX,IBOT,ITOP,JBOT,
     +     JTOP,KBOT,KTOP,IDI1,IDI2,IDI3,INRE,JNRE,KNRE,
     +     UBI,HFLUX,F1R,F1RM,F1RN,NBL,M,NPATCH,ICON,RCON,IHF,
     +     VOL,A1,A1X,ISTATE,IB,MAXB,OMEX,OMEY,OMEZ,CENX,CENY,CENZ)

      USE NS3CO, ONLY : IC9
      
      INTEGER :: IMAX, JMAX, KMAX, IN, JN, KN, INRE, JNRE, KNRE
      REAL :: YCO(*),ZCO(*),XCO(*)
      DIMENSION :: ICON(IC9,*),RCON(IC9,*),VOL(*),A1(MAXB,*),UBI(IB,*),
     +     A1X(MAXB,*),IHF(*),HFLUX(*),F1R(*),F1RM(*),F1RN(*)
      CHARACTER(LEN=3) :: FILEE
      CHARACTER(LEN=4) :: FILE4

      IN = INRE
      JN = JNRE
      KN = KNRE

      KSTRID  = KMAX + 2*KN
      JSTRID  = JMAX + 2*JN
      ISTRID  = IMAX + 2*IN
      IL      = ISTRID*JSTRID

C ... LOOP OVER THE PATCHES OF THE BLOCK 


C ... heat flux calculations

      DO 8000 IP = 1,NPATCH
         IBC     = ICON(1,IP)
         IPL     = ICON(2,IP) ! proces local patch number
         IHEAT   = ICON(20,IP)
         IDIR    = 1
         IF(IBC >= 8 .AND. IBC <= 10 .AND. IHEAT /= 0) THEN
            IFACE   = ICON(3,IP)
      IF(IFACE >= 4) IDIR = -1
C ... XI-DIRECTION
      IF(IFACE == 1 .OR. IFACE == 4) THEN
         IN   = JNRE
         JN   = KNRE
         KN   = INRE
         ISTR = ISTRID
         JSTR = IL
         KSTR = 1
         K    = IBOT
         ID   = IDI1
         JST2 = JSTRID
         IF(IFACE == 4) K   = ITOP + 1
C ... ETA-DIRECTION
      ELSEIF(IFACE == 2 .OR. IFACE == 5) THEN
         IN   = KNRE
         JN   = INRE
         KN   = JNRE
         ISTR = IL
         JSTR = 1
         KSTR = ISTRID
         K    = JBOT
         ID   = IDI2
         JST2 = KSTRID
         IF(IFACE == 5) K   = JTOP + 1
C ... ZETA DIRECTION
      ELSEIF(IFACE == 3 .OR. IFACE == 6) THEN
         IN   = INRE
         JN   = JNRE
         KN   = KNRE
         ISTR = 1
         JSTR = ISTRID
         KSTR = IL
         K = KBOT
         ID   = IDI3
         JST2 = ISTRID
         IF(IFACE == 6) K   = KTOP + 1
      ENDIF

      KX1 = ICON(4,IP)
      KX2 = ICON(5,IP)
      KY1 = ICON(6,IP)
      KY2 = ICON(7,IP)

      IF(ICON(3,IP) ==  2 .OR. ICON(3,IP) == 5) THEN
         KY1 = ICON(4,IP)
         KY2 = ICON(5,IP)
         KX1 = ICON(6,IP)
         KX2 = ICON(7,IP)
      ENDIF

      LSTRID  = KSTR*IDIR
      IF(IDIR ==  1) NFL = 0
      IF(IDIR == -1) NFL = -LSTRID
      KA      = (KN+KBOT-1)*KSTR

      IF(IHEAT == 1) THEN

       DO J = KY1,KY2
          IJ      = (JN+J-1)*JSTR + KA
          NN      = (J-KY1)*(KX2-KX1+1)
          N1      = (JN+J-1)*ISTRID + IN
          DO I = KX1,KX2
             II      = (IN+I-1)*ISTR  + IJ + 1 ! CELL INDEX (STRIDE=ISTR)
             II1     = II + LSTRID             ! THE SECOND CELL
             IF      = II + NFL                ! FLUX INDEX
             NI      = I  + N1                 ! PATCH VELOCITY INDEX
             NH      = NN + I-KX1 + IHF(IPL)   ! Patch temperature index
             HFLUX(NH) = RCON(5,IP)
          ENDDO
       ENDDO
      ELSEIF(IHEAT == 2) THEN
       DO J = KY1,KY2
          IJ      = (JN+J-1)*JSTR + KA
          NN      = (J-KY1)*(KX2-KX1+1)
          N1      = (JN+J-1)*ISTRID + IN
          DO I = KX1,KX2
             II      = (IN+I-1)*ISTR  + IJ + 1 ! CELL INDEX (STRIDE=ISTR)
             II1     = II + LSTRID             ! THE SECOND CELL
             IF      = II + NFL                ! FLUX INDEX
             NI      = I  + N1                 ! PATCH VELOCITY INDEX
             NH      = NN + I-KX1  + IHF(IPL)  ! Patch temperature index
             HFLUX(NH) = RCON(6,IP)
          ENDDO
       ENDDO
      
      ELSE                      !(IHEAT == 1)
         WRITE(*,*) 'no such solid tempperature boundary condition'
         WRITE(*,*) 'Exiting ...'
         STOP
      ENDIF                     !(IHEAT == 1)
      ENDIF                     ! (IBC >= 8 ....)

 8000 CONTINUE

      RETURN
      END SUBROUTINE SURVAR
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SURHEI(XCO,YCO,ZCO,IMAX,JMAX,KMAX,INRE,JNRE,KNRE,
     +     HFLUX,NBL,M,NPATCH,ICON,IHF,VOL,IB,MAXB)

      USE NS3CO, ONLY : IC9, GX, GY, GZ

      INTEGER :: IMAX, JMAX, KMAX, IN, JN, KN, INRE, JNRE, KNRE
      REAL :: YCO(*), ZCO(*), XCO(*)
      DIMENSION :: ICON(IC9,*), VOL(*), IHF(*),
     +     HFLUX(*)  !,A1(MAXB,*),A1X(MAXB,*), unused
      CHARACTER(LEN=3) :: FILEE
      CHARACTER(LEN=4) :: FILE4

      IN = INRE
      JN = JNRE
      KN = KNRE

      KSTRID  = KMAX + 2*KN
      JSTRID  = JMAX + 2*JN
      ISTRID  = IMAX + 2*IN
      IL      = ISTRID*JSTRID

C ... Surface height calculation from the grid data only z-direction
      DO 8000 IP = 1,NPATCH
         IBC     = ICON(1,IP)
         IPL     = ICON(2,IP) ! proces local patch number
         IDIR    = 1
         IF(IBC == 13) THEN
            IFACE   = ICON(3,IP)
      IF(IFACE >= 4) IDIR = -1
C ... XI-DIRECTION
      K    = 1
      IF(IFACE == 1 .OR. IFACE == 4) THEN
         IN   = JNRE
         JN   = KNRE
         KN   = INRE
         ISTR = ISTRID
         JSTR = IL
         KSTR = 1
         JST2 = JSTRID
         IF(IFACE == 4) K   = IMAX + 1
C ... ETA-DIRECTION
      ELSEIF(IFACE == 2 .OR. IFACE == 5) THEN
         IN   = KNRE
         JN   = INRE
         KN   = JNRE
         ISTR = IL
         JSTR = 1
         KSTR = ISTRID
         JST2 = KSTRID
         IF(IFACE == 5) K   = JMAX + 1
C ... ZETA DIRECTION
      ELSEIF(IFACE == 3 .OR. IFACE == 6) THEN
         IN   = INRE
         JN   = JNRE
         KN   = KNRE
         ISTR = 1
         JSTR = ISTRID
         KSTR = IL
         K = 1
         JST2 = ISTRID
         IF(IFACE == 6) K   = KMAX + 1
      ENDIF

      KX1 = ICON(4,IP)
      KX2 = ICON(5,IP)
      KY1 = ICON(6,IP)
      KY2 = ICON(7,IP)
      IF(ICON(3,IP) ==  2 .OR. ICON(3,IP) == 5) THEN
         KY1 = ICON(4,IP)
         KY2 = ICON(5,IP)
         KX1 = ICON(6,IP)
         KX2 = ICON(7,IP)
      ENDIF
      LSTRID  = KSTR*IDIR
      IF(IDIR ==  1) NFL = 0
      IF(IDIR == -1) NFL = -LSTRID

       DO J = KY1,KY2+1
          KK      = (JN+J-1)*JSTR + (KN+K-1)*KSTR
          NN      = (J-KY1)*(KX2-KX1+2)
          N1      = (JN+J-1)*ISTRID + IN
          DO I = KX1,KX2+1
            L       = 1 + (IN+I-1)*ISTR + KK

             NI      = I  + N1                 ! PATCH VELOCITY INDEX
             NH      = NN + I-KX1  + IHF(IPL)   ! Patch tempperature index
             XAVE    = (GX*XCO(L) + GY*YCO(L) + 
     +            GZ*ZCO(L))/(GX+GY+GZ)
             hold = HFLUX(NH)

             HFLUX(NH) = XAVE
          ENDDO
             write(6,*) 'Käytiin SURHEIssä'
             write(45,*) 'Käytiin SURHEIssä'
        
       ENDDO
      ENDIF                     ! (IBC == 13....)

 8000 CONTINUE

      RETURN
      END SUBROUTINE SURHEI
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SLICOR(XC,YC,ZC,IMAX,JMAX,KMAX,INRE,JNRE,KNRE,
     + NBL,NPATCH,ICON,ROTANG,NPROCE,IPRO,MBPRO)

      USE NS3CO, ONLY : IC9
      
      INTEGER :: IMAX, JMAX, KMAX, IN, JN, KN, INRE, JNRE, KNRE
      DIMENSION :: ICON(IC9,*),ROTANG(*)
      DIMENSION :: NPROCE(MBPRO+1,*)
      REAL :: YC(*), ZC(*), XC(*)
C
C ... EXTRAPOLATE CENTER POINTS FOR SLIDING PATCHES
C ... tama aliohjelma taytyy testata varsinkin alemmille hilatasoille.
C ... yleensa ottaen en kasita ohjelman tarpeellisuutta juuri nyt.
C ... ppr 18.10.96

      IN = INRE
      JN = JNRE
      KN = KNRE

      KSTRID  = KMAX + 2*KN
      JSTRID  = JMAX + 2*JN
      ISTRID  = IMAX + 2*IN
      IL      = ISTRID*JSTRID

C ... LOOP OVER THE PATCHES OF THE BLOCK 

      DO 7000 IP = 1,NPATCH
      IBC     = ICON(1,IP)
      IF(IBC == 11 .OR. IBC == 14) THEN
      IFACE   = ICON(3,IP)
      IXLO    = ICON(4,IP)
      IXUP    = ICON(5,IP)
      IYLO    = ICON(6,IP)
      IYUP    = ICON(7,IP)
      IDIR    = 1
      IVOL    = ICON(8,IP) ! NUMBER OF THE CONNECTIVE BLOCK 
      NBG     = NPROCE(1+NBL,IPRO)               ! global block number
      NBGCON  = NPROCE(1+ICON(8,IP),ICON(17,IP)) ! g. connectivy block n.
C      ROTA1     = ROTANG(NBL)   ! ANGLE OF THIS BLOCK
C      ROTA2     = ROTANG(IVOL)  ! ANGLE OF CON. BLOCK. NOW IN THIS WAY,
      ROTA1     = ROTANG(NBG)    ! ANGLE OF THIS BLOCK
      ROTA2     = ROTANG(NBGCON) ! ANGLE OF CON. BLOCK. NOW IN RIGHT WAY.
      SLIDE     = ROTA1 - ROTA2 ! SLIDE ANGLE
C ... A,  B,  C   Rotation axis vector
C ... XC, YC, ZC  Center of rotation


      DROTAN = SLIDE
      A  = 1.0
      B  = 0.0
      C  = 0.0
      XC0 = 0.0
      YC0 = 0.0
      ZC0 = 0.0

*     Seuraava varmistus on nyt turha, mutta jos vektori tuodaan
*     parametrina, niin varmistus on aiheellinen - varsinkin jos 
*     kayttaja voi antaa vektorin INPUTissa

C ... Make sure the rotation axis vector is a unit vector
      
      D = SQRT(A*A+B*B+C*C)
      IF(D < 1.E-10) STOP 'SLICOR: Illegal rotation axis vector'
      A = A/D
      B = B/D
      C = C/D

      COSTHE = COS(DROTAN)
      SINTHE = SIN(DROTAN)

C ... Rotation matrix

      A11 = A*A*(1.E+00-COSTHE) +   COSTHE
      A12 = B*A*(1.E+00-COSTHE) + C*SINTHE
      A13 = C*A*(1.E+00-COSTHE) - B*SINTHE
      A21 = A*B*(1.E+00-COSTHE) - C*SINTHE
      A22 = B*B*(1.E+00-COSTHE) +   COSTHE
      A23 = C*B*(1.E+00-COSTHE) + A*SINTHE
      A31 = A*C*(1.E+00-COSTHE) + B*SINTHE
      A32 = B*C*(1.E+00-COSTHE) - A*SINTHE
      A33 = C*C*(1.E+00-COSTHE) +   COSTHE


      IF(IFACE >= 4) IDIR = -1
      K    = 1
C ... XI-DIRECTION
      IF(IFACE == 1 .OR. IFACE == 4) THEN
         IN   = JNRE
         JN   = KNRE
         KN   = INRE
         ISTR = ISTRID
         JSTR = IL
         KSTR = 1
         I1   = IXLO
         I2   = IXUP
         J1   = IYLO
         J2   = IYUP
         IF(IFACE == 4) K   = IMAX
C ... ETA-DIRECTION
      ELSEIF(IFACE == 2 .OR. IFACE == 5) THEN
         IN   = KNRE
         JN   = INRE
         KN   = JNRE
         ISTR = IL
         JSTR = 1
         KSTR = ISTRID
         I1   = IYLO
         I2   = IYUP
         J1   = IXLO
         J2   = IXUP
         IF(IFACE == 5) K   = JMAX
C ... ZETA DIRECTION
      ELSEIF(IFACE == 3 .OR. IFACE == 6) THEN
         IN   = INRE
         JN   = JNRE
         KN   = KNRE
         ISTR = 1
         JSTR = ISTRID
         KSTR = IL
         I1   = IXLO
         I2   = IXUP
         J1   = IYLO
         J2   = IYUP
         IF(IFACE == 6) K   = KMAX
      ENDIF
      
      DO 1000 J = J1,J2
         KK      = (JN+J-1)*JSTR + (KN+K-1)*KSTR
         DO 1000 I = I1,I2
            L       = 1 + (IN+I-1)*ISTR + KK
            LB      = L - IDIR*KSTR
            LB2     = L - 2*IDIR*KSTR
            XGRIG   = XC(LB)
            YGRIG   = YC(LB)
            ZGRIG   = ZC(LB)
            XGRIG2  = XC(LB2)
            YGRIG2  = YC(LB2)
            ZGRIG2  = ZC(LB2)
            XC(LB)  = A11*(XGRIG-XC0) 
     &              + A12*(YGRIG-YC0) 
     &              + A13*(ZGRIG-ZC0) + XC0
            YC(LB)  = A21*(XGRIG-XC0) 
     &              + A22*(YGRIG-YC0) 
     &              + A23*(ZGRIG-ZC0) + YC0
            ZC(LB)  = A31*(XGRIG-XC0) 
     &              + A32*(YGRIG-YC0) 
     &              + A33*(ZGRIG-ZC0) + ZC0
            XC(LB2) = A11*(XGRIG2-XC0) 
     &              + A12*(YGRIG2-YC0) 
     &              + A13*(ZGRIG2-ZC0) + XC0
            YC(LB2) = A21*(XGRIG2-XC0) 
     &              + A22*(YGRIG2-YC0) 
     &              + A23*(ZGRIG2-ZC0) + YC0
            ZC(LB2) = A31*(XGRIG2-XC0) 
     &              + A32*(YGRIG2-YC0) 
     &              + A33*(ZGRIG2-ZC0) + ZC0
 1000 CONTINUE
      ENDIF                     ! IBC == 11 .OR. IBC == 14
7000  CONTINUE ! LOOP OVER THE PATCHES

      RETURN
      END SUBROUTINE SLICOR
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE SURSET(XCO,YCO,ZCO,XC,YC,ZC,U,V,W,
     +     TEMP,PDIFF,FRSDEN,FRSVEL,CHLREF,ICYCLE,
     +     IMAX,JMAX,KMAX,INRE,JNRE,KNRE,
     +     HFLUX,NBL,M,NPATCH,ICON,IHF,
     +     VOL,A1,A2,A3,A1X,A1Y,A1Z,A2X,A2Y,A2Z,A3X,A3Y,A3Z,
     +     IB,MAXB,IGRID,CFL)

      USE NS3CO, ONLY : IC9, GX, GY, GZ, GROUND
      
      INTEGER :: IMAX, JMAX, KMAX, IN, JN, KN, INRE, JNRE, KNRE

      REAL :: YCO(*),ZCO(*),XCO(*),YL,XC(*),YC(*),ZC(*)
      REAL :: U(*),V(*),W(*),TEMP(*)

      DIMENSION :: ICON(IC9,*),VOL(*),IHF(*),HFLUX(*),PDIFF(*)

      REAL :: DGX,DGY,DGZ

      INTEGER, PARAMETER :: MAXI=300

      REAL :: DS(MAXI,MAXI),AI1(MAXI,MAXI),AI2(MAXI,MAXI),
     +        AJ1(MAXI,MAXI),AJ2(MAXI,MAXI),
     +        AP(MAXI,MAXI),DU(MAXI,MAXI),
     +        A1(*),A2(*),A3(*),A1X(*),A1Y(*),A1Z(*),
     +        A2X(*),A2Y(*),A2Z(*),
     +        A3X(*),A3Y(*),A3Z(*)

      REAL, ALLOCATABLE :: AA(:,:),AAX(:,:)

      CHARACTER(LEN=3) :: FILEE
      CHARACTER(LEN=4) :: FILE4

      IN = INRE
      JN = JNRE
      KN = KNRE

      KSTRID  = KMAX + 2*KN
      JSTRID  = JMAX + 2*JN
      ISTRID  = IMAX + 2*IN
      NTOT    = ISTRID*JSTRID*KSTRID
      IL      = ISTRID*JSTRID
      GTOT    = SQRT(GX**2 + GY**2 + GZ**2)

C ... Antakee mersu

      ALLOCATE(AA(NTOT,3),AAX(NTOT,9))

      DO L = 1,NTOT
         AA(L,1)   = A1(L)
         AA(L,2)   = A2(L)
         AA(L,3)   = A3(L)
         AAX(L,1) = A1X(L)
         AAX(L,2) = A1Y(L)
         AAX(L,3) = A1Z(L)
         AAX(L,4) = A2X(L)
         AAX(L,5) = A2Y(L)
         AAX(L,6) = A2Z(L)
         AAX(L,7) = A3X(L)
         AAX(L,8) = A3Y(L)
         AAX(L,9) = A3Z(L)
      ENDDO

C ... Obsolate block above, AAX could be replaced by a patch-sized array

      IF(MAXI-4 <=  MAX0(IMAX,JMAX,KMAX)) THEN
         WRITE(*,*) 'Too small max in SURSET: MAXI, IMAX,JMAX,KMAX',
     +       MAXI, IMAX,JMAX,KMAX
         WRITE(*,*) 'Exiting...'
         STOP
      ENDIF



C ... Surface height calculation from the grid data only z-direction
      DO 8000 IP = 1,NPATCH
         IBC     = ICON(1,IP)
         IPL     = ICON(2,IP) ! proces local patch number

         IF(IBC == 13) THEN
            IF(IGRID /= 5) THEN ! move surface

            IFACE   = ICON(3,IP)

      IDIR    = 1
            IF(IFACE >= 4) IDIR = -1

C ... XI-DIRECTION
      K    = 1
      IF(IFACE == 1 .OR. IFACE == 4) THEN
         IN   = JNRE
         JN   = KNRE
         KN   = INRE
         ISTR = ISTRID
         JSTR = IL
         KSTR = 1
         JST2 = JSTRID
         IAP  = 1
         IF(IFACE == 4) K   = IMAX + 1

C ... ETA-DIRECTION
      ELSEIF(IFACE == 2 .OR. IFACE == 5) THEN
         IN   = KNRE
         JN   = INRE
         KN   = JNRE
         ISTR = IL
         JSTR = 1
         KSTR = ISTRID
         JST2 = KSTRID
         IAP  = 2
         IF(IFACE == 5) K   = JMAX + 1

C ... ZETA DIRECTION
      ELSEIF(IFACE == 3 .OR. IFACE == 6) THEN
         IN   = INRE
         JN   = JNRE
         KN   = KNRE
         ISTR = 1
         JSTR = ISTRID
         KSTR = IL
         K = 1
         JST2 = ISTRID
         IAP  = 3
         IF(IFACE == 6) K   = KMAX + 1
      ENDIF

      K2 = K
      IF(IFACE >= 4) K2 = K - 1

      KX1 = ICON(4,IP)
      KX2 = ICON(5,IP)
      KY1 = ICON(6,IP)
      KY2 = ICON(7,IP)

      IF(ICON(3,IP) == 2 .OR. ICON(3,IP) == 5) THEN
         KY1 = ICON(4,IP)
         KY2 = ICON(5,IP)
         KX1 = ICON(6,IP)
         KX2 = ICON(7,IP)
      ENDIF
      LSTRID  = KSTR*IDIR

      IF(IDIR ==  1) NFL = 0
      IF(IDIR == -1) NFL = -LSTRID

C ... update surface
C ... update surface height implicitely using iterative solver

          JJM = KY2-KY1
          IIM = KX2-KX1

       DO J = KY1+1,KY2
          KK      = (JN+J-1)*JSTR + (KN+K-1)*KSTR
          II      = KX2-KX1+2
          JJ      = KY2-KY1+2
          NN      = (J-KY1)*II
          N1      = (JN+J-1)*ISTRID + IN
          DO I = KX1+1,KX2

             IR = I - (KX1+1) + 3
             JR = J - (KY1+1) + 3

            L       = 1 + (IN+I-1)*ISTR + (JN+J-1)*JSTR + (KN+K-1)*KSTR
            L1      = 1 + (IN+I-1)*ISTR + (JN+J-1)*JSTR + (KN+K2-1)*KSTR
            L2      = 1 + (IN+I-2)*ISTR + (JN+J-1)*JSTR + (KN+K2-1)*KSTR
            L3      = 1 + (IN+I-1)*ISTR + (JN+J-2)*JSTR + (KN+K2-1)*KSTR
            L4      = 1 + (IN+I-2)*ISTR + (JN+J-2)*JSTR + (KN+K2-1)*KSTR
            NH = NN + I-KX1  + IHF(IPL)

            P1 = .25*(PDIFF(L1) + PDIFF(L2) + PDIFF(L3) + PDIFF(L4))  
            P2 = .25*(PDIFF(L1+LSTRID) + PDIFF(L2+LSTRID) + 
     +           PDIFF(L3+LSTRID) + PDIFF(L4+LSTRID))  
            DPSUF  = 1.5*P1 - .5*P2
            DPSUF1 = 1.5*PDIFF(L1) - .5*PDIFF(L1+LSTRID)
            DPSUF2 = 1.5*PDIFF(L2) - .5*PDIFF(L2+LSTRID)
            DPSUF3 = 1.5*PDIFF(L3) - .5*PDIFF(L3+LSTRID)
            DPSUF4 = 1.5*PDIFF(L4) - .5*PDIFF(L4+LSTRID)
 
C ... remeber to change values in BOTSF too
            R1  = 1.125 ! zero gradient at surface 2.order
            R1  = 1.    ! 1.order (stabiilimpi eika eroa tuloksissa)
            UL1 = R1*U(L1) + (1.-R1)*U(L1+LSTRID)
            VL1 = R1*V(L1) + (1.-R1)*V(L1+LSTRID)
            WL1 = R1*W(L1) + (1.-R1)*W(L1+LSTRID)
            UL2 = R1*U(L2) + (1.-R1)*U(L2+LSTRID)
            VL2 = R1*V(L2) + (1.-R1)*V(L2+LSTRID)
            WL2 = R1*W(L2) + (1.-R1)*W(L2+LSTRID)
            UL3 = R1*U(L3) + (1.-R1)*U(L3+LSTRID)
            VL3 = R1*V(L3) + (1.-R1)*V(L3+LSTRID)
            WL3 = R1*W(L3) + (1.-R1)*W(L3+LSTRID)
            UL4 = R1*U(L4) + (1.-R1)*U(L4+LSTRID)
            VL4 = R1*V(L4) + (1.-R1)*V(L4+LSTRID)
            WL4 = R1*W(L4) + (1.-R1)*W(L4+LSTRID)


            RX14 = XC(L1)-XC(L4) ! L4-L1 valinen vektori
            RY14 = YC(L1)-YC(L4)
            RZ14 = ZC(L1)-ZC(L4)
            XLEN = 1./SQRT(RX14**2 + RY14**2+RZ14**2)
            U14 = XLEN*(RX14*(UL1+UL4) + RY14*(VL1+VL4) +RZ14*(WL1+WL4))

            RX23 = XC(L2)-XC(L3) ! L3-L2 valinen vektori
            RY23 = YC(L2)-YC(L3)
            RZ23 = ZC(L2)-ZC(L3)
            XLEN = 1./SQRT(RX23**2 + RY23**2+RZ23**2)
            U23 = XLEN*(RX23*(UL2+UL3) + RY23*(VL2+VL3) +RZ23*(WL2+WL3))

            AX = (AAX(L1+NFL,1+(IAP-1)*3) + AAX(L2+NFL,1+(IAP-1)*3) +
     +            AAX(L3+NFL,1+(IAP-1)*3) + AAX(L4+NFL,1+(IAP-1)*3))*.25
            AY = (AAX(L1+NFL,2+(IAP-1)*3) + AAX(L2+NFL,2+(IAP-1)*3) +
     +            AAX(L3+NFL,2+(IAP-1)*3) + AAX(L4+NFL,2+(IAP-1)*3))*.25
            AZ = (AAX(L1+NFL,3+(IAP-1)*3) + AAX(L2+NFL,3+(IAP-1)*3) +
     +            AAX(L3+NFL,3+(IAP-1)*3) + AAX(L4+NFL,3+(IAP-1)*3))*.25

            UNOR1 = AAX(L1+NFL,1+(IAP-1)*3)*UL1 + ! lokaali keskipisteen 
     +              AAX(L1+NFL,2+(IAP-1)*3)*VL1 + ! suuntaan normaalit
     +              AAX(L1+NFL,3+(IAP-1)*3)*WL1
            UNOR2 = AAX(L2+NFL,1+(IAP-1)*3)*UL2 + 
     +              AAX(L2+NFL,2+(IAP-1)*3)*VL2 + 
     +              AAX(L2+NFL,3+(IAP-1)*3)*WL2
            UNOR3 = AAX(L3+NFL,1+(IAP-1)*3)*UL3 + 
     +              AAX(L3+NFL,2+(IAP-1)*3)*VL3 + 
     +              AAX(L3+NFL,3+(IAP-1)*3)*WL3
            UNOR4 = AAX(L4+NFL,1+(IAP-1)*3)*UL4 + 
     +              AAX(L4+NFL,2+(IAP-1)*3)*VL4 + 
     +              AAX(L4+NFL,3+(IAP-1)*3)*WL4

c           UNOR1 = AX*UL1 + AY*VL1 + AZ*WL1 ! hilaviivan suuntaan normaalit?
c           UNOR2 = AX*UL2 + AY*VL2 + AZ*WL2 ! ei toiminut  alkoi tulos
c           UNOR3 = AX*UL3 + AY*VL3 + AZ*WL3 ! heilua. Nahtavasti ylla oleva
c           UNOR4 = AX*UL4 + AY*VL4 + AZ*WL4 ! tuo vaimennusta pinnan liik.

            UNORold = .25*(UNOR1+UNOR2+UNOR3+UNOR4)

            RUPW = .75 ! RUPW =1. full upwing, wigley stabiilimpi?
C ... .75 toimii paremmin myos destroijelilla??? muitakin arvoja
C ... voisi kokoeilla 16.3.00
c            RUPW = 1. ! parempia tuloksia wigey... ei tullut
            UN14 = RUPW*UNOR1 + (1.-RUPW)*UNOR4
            UN23 = RUPW*UNOR2 + (1.-RUPW)*UNOR3
            IF(U14 > 0.) UN14 = RUPW*UNOR4 + (1.-RUPW)*UNOR1
            IF(U23 >= 0.) UN23 = RUPW*UNOR3 + (1.-RUPW)*UNOR2


            DP14 = DPSUF1 
            DP23 = DPSUF2 
            IF(U14 >= 0.) DP14 = DPSUF4
            IF(U23 >= 0.) DP23 = DPSUF3


            U14 = ABS(U14)  ! todellinen ylavirtapaino..... toimiiko?
            U23 = ABS(U23)
            U14 = U14/(U14+U23)
            UNOR = (U14*UN14+(1.-U14)*UN23)


            DPSUFY = (U14*DP14+(1.-U14)*DP23) ! paine ylavirtaan mita helv...
            DPSUF = .5*DPSUF + .5*DPSUFY
            DPSUF = DPSUFY

C ... distances only in perpendicular direction of gravitation
C ... tekematon:  sama juttu BOUNDF:n
            DGX = 1.-ABS(GX)/ABS(GX+GY+GZ)
            DGY = 1.-ABS(GY)/ABS(GX+GY+GZ)
            DGZ = 1.-ABS(GZ)/ABS(GX+GY+GZ)

            DX1 = SQRT(DGX*(XCO(L-ISTR)-XCO(L))**2 + 
     +                      DGY*(YCO(L-ISTR)-YCO(L))**2 + 
     +                 DGZ*(ZCO(L-ISTR)-ZCO(L))**2)
            DX2 = SQRT(DGX*(XCO(L+ISTR)-XCO(L))**2 + 
     +                      DGY*(YCO(L+ISTR)-YCO(L))**2 + 
     +                 DGZ*(ZCO(L+ISTR)-ZCO(L))**2)
            DY1 = SQRT(DGX*(XCO(L-JSTR)-XCO(L))**2 + 
     +                      DGY*(YCO(L-JSTR)-YCO(L))**2 + 
     +                 DGZ*(ZCO(L-JSTR)-ZCO(L))**2)
            DY2 = SQRT(DGX*(XCO(L+JSTR)-XCO(L))**2 + 
     +                      DGY*(YCO(L+JSTR)-YCO(L))**2 + 
     +                 DGZ*(ZCO(L+JSTR)-ZCO(L))**2)

C ... works only if gravitation is x, y or z direction
            XDEN = .0727        ! surface tension for water T= 20 C
            XDEN = .2        ! testi
c            XDEN = .5
c            XDEN = .0
            XDEN2 = .0001
            XDEN2 = .00001
c            XDEN2 = -.0018736/(FRSDEN*(GX+GY+GZ)) ! arvon pitaisi olla sama
            XDEN2 = .1/(FRSDEN*(GX+GY+GZ)) ! arvon pitaisi olla sama

            X = HFLUX(NH)
            Y = HFLUX(NH)
            Z = HFLUX(NH) ! works only in principal directions
            DELTAP  = FRSDEN*(GX*X + GY*Y
     +        +               GZ*Z-GTOT*GROUND)

            AI1(IR,JR) = -2.*XDEN2/((DX1+DX2)*DX1)
            AI2(IR,JR) = -2.*XDEN2/((DX1+DX2)*DX2)
            AJ1(IR,JR) = -2.*XDEN2/((DY1+DY2)*DY1)
            AJ2(IR,JR) = -2.*XDEN2/((DY1+DY2)*DY2)



c            AI1(IR,JR) = MAX(AI1(IR,JR),.003)
c            AI2(IR,JR) = MAX(AI2(IR,JR),.003)
c            AJ1(IR,JR) = MAX(AJ1(IR,JR),.003)
c            AJ2(IR,JR) = MAX(AJ2(IR,JR),.003)

C ... distance from origo and ship is assumed to locate in there
            R = SQRT(XCO(L)**2 + YCO(L)**2 + ZCO(L)**2)/CHLREF
C ... wave is damped after 10 ships lenght
            DAMP = MAX(0.,(R-4.)*.001) 
            DAMP = 0.003
            AI1(IR,JR) = MAX(AI1(IR,JR),DAMP)
            AI2(IR,JR) = MAX(AI2(IR,JR),DAMP)
            AJ1(IR,JR) = MAX(AJ1(IR,JR),DAMP)
            AJ2(IR,JR) = MAX(AJ2(IR,JR),DAMP)

            write(83,'(2I4,10G12.4)') i,j,XCO(L),YCO(L),
     +           AI1(IR,JR),AI2(IR,JR),AJ1(IR,JR),AJ2(IR,JR)



            AP (IR,JR) = -AI1(IR,JR)-AI2(IR,JR)-AJ1(IR,JR)-AJ2(IR,JR)
     +           - 1.

c            HFLUX(NH) = HFLUX(NH) + .1*(UNOR)

            DXEP = SQRT((XCO(L)-XCO(L+LSTRID))**2 + ! ekan kopin
     +                        (YCO(L)-YCO(L+LSTRID))**2 + ! syvyys
     +                  (ZCO(L)-ZCO(L+LSTRID))**2) 

            DHTEN = AI1(IR,JR)*HFLUX(NH-1 ) + AI2(IR,JR)*HFLUX(NH-1 ) +
     +              AJ1(IR,JR)*HFLUX(NH-II) + AJ2(IR,JR)*HFLUX(NH-II) +
     +              (AP(IR,JR) + 1.)*HFLUX(NH)

            DXXX = MIN(DX1+DX2,DY1+DY2)/2.

            WVEL = SQRT(ABS(2.*(GX+GY+GZ)*HFLUX(NH))) ! wave energy speed
            DTIME = .01*CHLREF/FRSVEL ! .1 on teennainen
C ... Jossain tapauksessa toimi
            DTIME = CFL*MIN(.5*DXXX,.01*CHLREF)/(FRSVEL+WVEL) 

c            DSWIFT = MIN(DTIME*(UNOR), .125*DXEP) ! max hila 1/8 korkeus
c            DSWIFT = MAX(DTIME*(UNOR),-.125*DXEP)
            DSWIFT = DTIME*UNOR*.125*DXEP/(ABS(DTIME*UNOR)+.125*DXEP)
            DAMP = MAX(0.,(R-4.)*.1)
            DAMP = MIN(1.,DAMP)
c            DSWIFT = (1.-DAMP)*DSWIFT - DAMP*HFLUX(NH)



            DS(IR,JR)  =  HFLUX(NH)+ DSWIFT
c            DS(IR,JR)  =  -.1*(DPSUF/(FRSDEN*(GX+GY+GZ))+ HFLUX(NH))
c     +           + HFLUX(NH)

c            if(jr <= 14) ds(ir,jr) = HFLUX(NH)
c            if(jr == 15) ds(ir,jr) = .5*DS(IR,JR)+.5*HFLUX(NH)

            DU(IR,JR)  = DS(IR,JR) ! alkuarvaus
            DU(IR,JR)  = HFLUX(NH) ! alkuarvaus vaihtoehto
            
c            R = SQRT(REAL((XCO(L)-.5D00)**2 + YCO(L)**2))
c            XAUX = MAX(0.,(R-5.)/30.)
c            XAUX = MIN(1.,XAUX)
c            HFLUX(NH) = (1.-XAUX)*HFLUX(NH) + XAUX*0.
c ... ei tartte jos pdiffia ei extrapoloida haamuihin....    
             if(m == 1) write(81,'(2I4,10G12.4)') i,j,HFLUX(NH),DPSUF,
     +           XCO(L),YCO(L),UNOR,W(L1),DXXX,
     +           DTIME,DXEP,DSWIFT

          if(j == 1 .and. m == 1) 
     +           write(75,'(I4,12F12.6)') i,XCO(L)/5.72-.5,
     +           UNOR,W(L1)+W(L3),HFLUX(NH),DPSUF,DELTAP


          ENDDO
             if(m == 1 .and. kx2 >= 10) write(81,*)
             write(83,*)
          ENDDO
       if(m == 1) CLOSE(81)
       CLOSE(83)
         if(m == 1) close(75)
C ... boundary conditions
       JB = KY1
       JT = KY2+1
       II      = KX2-KX1+2
       NNB      = (JB-KY1)*II
       NNT      = (JT-KY1)*II
       DO I = KX1,KX2+1
          NHB      = NNB + I-KX1  + IHF(IPL) ! Patch tempperature index
          NHT      = NNT + I-KX1  + IHF(IPL) ! Patch tempperature index
c          HFLUX(NHB+II) = 2.*HFLUX(NHB+2*II) - HFLUX(NHB+3*II) ! eka korkeus
c          HFLUX(NHT-II) = HFLUX(NHT-2*II)
          HFLUX(NHB) = HFLUX(NHB+II)
          HFLUX(NHT) = HFLUX(NHT-II)
             IR = I - (KX1+1) + 3
             JRMAX = JJM + 3

            AI1(IR,    2) = 0.
            AI2(IR,    2) = 0.
            AJ1(IR,    2) = 0.
            AJ2(IR,    2) = -1.
            AP (IR,2)     = 1.
            DS (IR,2)     = 0.
            
c            IF(I >= 89) THEN
c               AJ2(IR,    2) = 1.   ! zero lift in transom
c            ENDIF
               
            
            AI1(IR,JRMAX) = 0.
            AI2(IR,JRMAX) = 0.
            AJ1(IR,JRMAX) = -1.
            AJ2(IR,JRMAX) = 0.
            AP (IR,JRMAX) = 1.
            DS (IR,JRMAX) = 0.
            DU(IR,    2) = HFLUX(NHB)
            DU(IR,JRMAX) = HFLUX(NHT)
            DU(IR,    1) = HFLUX(NHB)
            DU(IR,JRMAX+1) = HFLUX(NHT)
            
       ENDDO
       DO J = KY1,KY2+1
          II      = KX2-KX1+2
          NN      = (J-KY1)*II
          IB = KX1
          IT = KX2+1
          NHB      = NN + IB-KX1  + IHF(IPL) ! Patch tempperature index
          NHT      = NN + IT-KX1  + IHF(IPL) ! Patch tempperature index
c          HFLUX(NHB+1) = HFLUX(NHB+2)
c          HFLUX(NHT-1) = HFLUX(NHT-2)
          HFLUX(NHB) = HFLUX(NHB+1)
          HFLUX(NHT) = HFLUX(NHT-1)
             IRMAX = IIM + 3
             JR = J - (KY1+1) + 3
            AI1(2,    JR) = 0.
            AI2(2,    JR) = -1.
            AJ1(2,    JR) = 0.
            AJ2(2,    JR) = 0.
            AP (2,    JR) = 1.
            DS (2,    JR) = 0.
            AI1(IRMAX,JR) = -1.
            AI2(IRMAX,JR) = 0.
            AJ1(IRMAX,JR) = 0.
            AJ2(IRMAX,JR) = 0.
            AP (IRMAX,JR) = 1.
            DS (IRMAX,JR) = 0.
            DU (2,    JR) = HFLUX(NHB)
            DU (IRMAX,JR) = HFLUX(NHT)
            DU (1,    JR) = HFLUX(NHB)
            DU (IRMAX+1,JR) = HFLUX(NHT)

         ENDDO

       CALL LGS(DU,AP,AI2,AI1,AJ1,AJ2,DS,IIM,JJM,MAXI,1)
       res = 0.
       AREA = 0.
       AHEI = 0.
C ... update HFLUX
       DO J = KY1+1,KY2
          II      = KX2-KX1+2
          JJ      = KY2-KY1+2
          NN      = (J-KY1)*II
          DO I = KX1+1,KX2
             IR = I - (KX1+1) + 3
             JR = J - (KY1+1) + 3
             NH = NN + I-KX1  + IHF(IPL) ! Patch tempperature index
            L1      = 1 + (IN+I-1)*ISTR + (JN+J-1)*JSTR + (KN+K2-1)*KSTR
            L2      = 1 + (IN+I-2)*ISTR + (JN+J-1)*JSTR + (KN+K2-1)*KSTR
            L3      = 1 + (IN+I-1)*ISTR + (JN+J-2)*JSTR + (KN+K2-1)*KSTR
            L4      = 1 + (IN+I-2)*ISTR + (JN+J-2)*JSTR + (KN+K2-1)*KSTR

             apu = hflux(nh)
             HFLUX(NH) = .5*HFLUX(NH) + .5*du(ir,jr)
c             HFLUX(NH) = du(ir,jr)
             AAA = (AA(L1+NFL,IAP) + AA(L2+NFL,IAP) +
     +              AA(L3+NFL,IAP) + AA(L4+NFL,IAP))*.25
             AREA = AREA + AAA
             AHEI = AHEI + AAA*HFLUX(NH)
             res = res + (apu-hflux(nh))**2
             if(m == 1) write(82,'(2I4,8G15.7)') i,j,HFLUX(NH),
     +            HFLUX(NH)-apu
          ENDDO
             if(m == 1) write(82,*)
       ENDDO

C ... boundary conditions uudestaan
       JB = KY1
       JT = KY2+1
       II      = KX2-KX1+2
       NNB      = (JB-KY1)*II
       NNT      = (JT-KY1)*II
       DO I = KX1,KX2+1
          NHB      = NNB + I-KX1  + IHF(IPL) ! Patch tempperature index
          NHT      = NNT + I-KX1  + IHF(IPL) ! Patch tempperature index
c          HFLUX(NHB+II) = HFLUX(NHB+2*II)
c          HFLUX(NHT-II) = HFLUX(NHT-2*II)
c          HFLUX(NHB+II) = 2.*HFLUX(NHB+2*II) - HFLUX(NHB+3*II) ! eka kork
          HFLUX(NHB) = HFLUX(NHB+II)
          HFLUX(NHT) = HFLUX(NHT-II)
       ENDDO
       DO J = KY1,KY2+1
          II      = KX2-KX1+2
          NN      = (J-KY1)*II
          IB = KX1
          IT = KX2+1
          NHB      = NN + IB-KX1  + IHF(IPL) ! Patch tempperature index
          NHT      = NN + IT-KX1  + IHF(IPL) ! Patch tempperature index
c          HFLUX(NHB+1) = HFLUX(NHB+2)
c          HFLUX(NHT-1) = HFLUX(NHT-2)
          HFLUX(NHB) = HFLUX(NHB+1)
          HFLUX(NHT) = HFLUX(NHT-1)
       ENDDO



C ... etsitaan wave cutti y/L=0.172
       YL = CHLREF*.172
       DO I = KX1+1,KX2-1
       DO J = KY1+1,KY2-1
          II      = KX2-KX1+2
          JJ      = KY2-KY1+2
          NN      = (J-KY1)*II
          L       = 1 + (IN+I-1)*ISTR + (JN+J-1)*JSTR + (KN+K-1)*KSTR
          IR = I - (KX1+1) + 3
          JR = J - (KY1+1) + 3
          NH = NN + I-KX1  + IHF(IPL) ! Patch tempperature index
          IF(YCO(L) <= YL .AND. YCO(L+JSTR) >=  YL) THEN
             XAUX = (YL - YCO(L))/(YCO(L+JSTR)-YCO(L))
             DHHH = XAUX*HFLUX(NH+II) + (1.-XAUX)*HFLUX(NH)
             DXXX = XAUX*XCO(L+JSTR) + (1.-XAUX)*XCO(L)
             write(84,'(3G15.7)') DXXX,DHHH
          ENDIF
          IF(YCO(L) <= YL .AND. YCO(L+ISTR) >=  YL) THEN
             XAUX = (YL - YCO(L))/(YCO(L+ISTR)-YCO(L))
             DHHH = XAUX*HFLUX(NH+1) + (1.-XAUX)*HFLUX(NH)
             DXXX = XAUX*XCO(L+ISTR) + (1.-XAUX)*XCO(L)
             write(84,'(3G15.7)') DXXX,DHHH
          ENDIF
          IF(YCO(L) >= YL .AND. YCO(L+ISTR) <=  YL) THEN
             XAUX = (YL - YCO(L))/(YCO(L+ISTR)-YCO(L))
             DHHH = XAUX*HFLUX(NH+1) + (1.-XAUX)*HFLUX(NH)
             DXXX = XAUX*XCO(L+ISTR) + (1.-XAUX)*XCO(L)
             write(84,'(3G15.7)') DXXX,DHHH
          ENDIF
       ENDDO
       ENDDO
       close(84)

       if(m == 1) write(82,'("# CYkkeli",I6)') ICYCLE 
       if(m == 1) CLOSE(82)

      ENDIF ! (IGRID /= 5) surface movement end.
C ... update pressure

       DO J = KY1,KY2
          KK      = (JN+J-1)*JSTR + (KN+K2-1)*KSTR
          NN      = (J-KY1)*(KX2-KX1+2)
          N1      = (JN+J-1)*ISTRID + IN
          DO I = KX1,KX2
            L       = 1 + (IN+I-1)*ISTR + KK
            L1      = 1 + (IN+I-1)*ISTR + (JN+J-1)*JSTR + (KN+K-1)*KSTR
            L2      = 1 + (IN+I  )*ISTR + (JN+J-1)*JSTR + (KN+K-1)*KSTR
            L3      = 1 + (IN+I-1)*ISTR + (JN+J  )*JSTR + (KN+K-1)*KSTR
            L4      = 1 + (IN+I  )*ISTR + (JN+J  )*JSTR + (KN+K-1)*KSTR
            NH      = NN + I-KX1  + IHF(IPL) ! Patch tempperature index

            DHEIGH = .25*(HFLUX(NH) + HFLUX(NH+1) + 
     +           HFLUX(NH+(KX2-KX1+2)) + HFLUX(NH+(KX2-KX1+2) + 1))

            UL = .125*(9.*U(L) - U(L+LSTRID))
            VL = .125*(9.*V(L) - V(L+LSTRID))
            WL = .125*(9.*W(L) - W(L+LSTRID))
            UNOR = AAX(L+NFL,1+(IAP-1)*3)*UL + 
     +             AAX(L+NFL,2+(IAP-1)*3)*VL + 
     +             AAX(L+NFL,3+(IAP-1)*3)*WL

            UREL = .1
            UGOL =UREL*AAX(L+NFL,1+(IAP-1)*3)*UNOR+.5*(U(L)+U(L-LSTRID))
            VGOL =UREL*AAX(L+NFL,2+(IAP-1)*3)*UNOR+.5*(V(L)+V(L-LSTRID))
            WGOL =UREL*AAX(L+NFL,3+(IAP-1)*3)*UNOR+.5*(W(L)+W(L-LSTRID))

            U(L-  LSTRID) = 2.*UGOL - U(L)
            V(L-  LSTRID) = 2.*VGOL - V(L)
            W(L-  LSTRID) = 2.*WGOL - W(L)
            U(L-2*LSTRID) = 2.*U(L-LSTRID) + U(L) 
            V(L-2*LSTRID) = 2.*V(L-LSTRID) + V(L) 
            W(L-2*LSTRID) = 2.*W(L-LSTRID) + W(L) 
c            U(L-  LSTRID) = 2.*U(L)- U(L+LSTRID) ! central difference
c            V(L-  LSTRID) = 2.*V(L)- V(L+LSTRID) ! next to free surface
c            W(L-  LSTRID) = 2.*W(L)- W(L+LSTRID)
            U(L-  LSTRID) =  U(L)
            V(L-  LSTRID) =  V(L)
            W(L-  LSTRID) =  W(L)
            U(L-2*LSTRID) = U(L+LSTRID) 
            V(L-2*LSTRID) = V(L+LSTRID) 
            W(L-2*LSTRID) = W(L+LSTRID) 



            X = DHEIGH
            Y = DHEIGH
            Z = DHEIGH

            DELTAP  = FRSDEN*(GX*X + GY*Y
     +        +               GZ*Z-GTOT*GROUND)
            PDIFF(L-LSTRID)   = -2.*DELTAP - PDIFF(L) ! taysi oli liikaa??
c            PDIFF(L-2*LSTRID) = -2.*DELTAP - PDIFF(L)
c            PDIFF(L-LSTRID)   = -DELTAP
c            PDIFF(L-2*LSTRID) = -DELTAP
            
         ENDDO
      ENDDO
         

C ... add surface tension. Artificial. Assumed that at the first
C ... cell there is no surface tension???
C ... and now the tension is next to the surfaces also....

       DO J = KY1+1,KY2-1
c       DO J = KY1+2,KY2-2  ! first cell, no surface tension
          KK      = (JN+J-1)*JSTR + (KN+K2-1)*KSTR
          II      = KX2-KX1+2
          NN      = (J-KY1)*II
          N1      = (JN+J-1)*ISTRID + IN
          DO I = KX1+1,KX2-1
c          DO I = KX1+2,KX2-2
            L       = 1 + (IN+I-1)*ISTR + KK
            L1      = 1 + (IN+I-1)*ISTR + (JN+J-1)*JSTR + (KN+K-1)*KSTR
            L2      = 1 + (IN+I  )*ISTR + (JN+J-1)*JSTR + (KN+K-1)*KSTR
            L3      = 1 + (IN+I-1)*ISTR + (JN+J  )*JSTR + (KN+K-1)*KSTR
            L4      = 1 + (IN+I  )*ISTR + (JN+J  )*JSTR + (KN+K-1)*KSTR
            NH      = NN + I-KX1  + IHF(IPL) ! Patch tempperature index

            X1 = .25*XCO(L1) + XCO(L2) + XCO(L3) + XCO(L4)
            Y1 = .25*YCO(L1) + YCO(L2) + YCO(L3) + YCO(L4)
            Z1 = .25*ZCO(L1) + ZCO(L2) + ZCO(L3) + ZCO(L4)


C ... musclekaavasta keskiarvoksi tulee juurikin oikea

c            TEMP (L-LSTRID)   = 2.*TEMP (L)  - TEMP (L+LSTRID)
            PDIFF(L-LSTRID)   = 2.*PDIFF(L)  - PDIFF(L+LSTRID)
            U    (L-LSTRID)   = 2.*U    (L)  - U    (L+LSTRID)
            V    (L-LSTRID)   = 2.*V    (L)  - V    (L+LSTRID)
            W    (L-LSTRID)   = 2.*W    (L)  - W    (L+LSTRID)
C ... periaatteessa turhaa?
c            TEMP (L-2*LSTRID)   = 2.*TEMP (L-LSTRID)  - TEMP (L)
            PDIFF(L-2*LSTRID)   = 2.*PDIFF(L-LSTRID)  - PDIFF(L)
            U    (L-2*LSTRID)   = 2.*U    (L-LSTRID)  - U    (L)
            V    (L-2*LSTRID)   = 2.*V    (L-LSTRID)  - V    (L)
            W    (L-2*LSTRID)   = 2.*W    (L-LSTRID)  - W    (L)


c          if(m == 1) 
c     +           write(74,'(2I4,10G14.6)') i,J,
c     +           PDIFF(L-LSTRID)
            
c          if(m == 1 .and. j == 1) write(*,*) i, HFLUX(NH),HFLUX(NH-JJ)

          ENDDO
c         if(m == 1) write(74,*)
       ENDDO
c         close(74)
      ENDIF                     ! (IBC == 13....)

 8000 CONTINUE

      DEALLOCATE (AA,AAX)

      RETURN
      END SUBROUTINE SURSET
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      SUBROUTINE BOTSF(F3R,F3RM,F3RN,F3RW,F3E,P,U,V,W,C,E,VOL,A3,A3X,
     2  A3Y,A3Z,OHMI,VIS,EPS2,VIST,ISTRID,JSTRID,KSTRID,IDIM,KBOT,PDI,
     3  KX1,KX2,KY1,KY2,PR,PRT,RO,TOM,IFLUX,
     4  CX,CY,CZ,CMX,CMY,CMZ,M,IN,JN,KN,XC,YC,ZC,XMOM,YMOM,ZMOM,IDIR,
     5  DX,DY,DZ,UROT,TEMP,CH,QX,QY,QZ,FRSDEN,FRSPRE,FRSVEL,FRSVIS,T0,
     6  DIFPRE,ISTR,JSTR,KSTR,IHEAT,RCON,HFLUX,XCO,YCO,ZCO,ICYCLE)

      USE NS3CO, ONLY : GX, GY, GZ, GROUND

      IMPLICIT NONE

      INTEGER :: ISTRID,JSTRID,KSTRID,LSTRID,KSTR,IDIR,NFL,M,IFLUX,IHFL,
     2     IHT,IHEAT,KA,KN,KBOT,J,KY1,KY2,IJ,JN,JSTR,NN,KX1,KX2,N1,
     3     IN,I,II,ISTR,II1,II2,IF1,NI,NH,L1,L2,L3,L4,II7,NT,I1M2,
     4     I1M1,I1P1,I1P2,ICYCLE,IDIM

      REAL :: WTEMP,WFLUX,EPS3,RC1,RC2,RM1,RM2,PRS,PR,PRT,YMR,DIFPRE,
     2     YP1,YP4,RSUM,FRSPRE,EPS,TSURF,T0,VISLIM,YPG,FRSVIS,CHLIM,
     3     ROLIM,FRSDEN,XMASS,AREA,EPS2B,VISTB,VISB,CHSB,OHMIB,ROB,DIST,
     4     SURG,SURFE,PB1,PB4,PB,X1,Y1,Z1,DI11,DI12,DI13,DI21,DI22,DI23,
     5     DJ11,DJ12,DJ13,DJ21,DJ22,DJ23,SURF,GTOT,H1M2,H1M1,H1P1,H1P2,
     6     H2M2,H2M1,H2P1,H2P2,H3M2,H3M1,H3P1,H3P2,H4M2,H4M1,H4P1,H4P2,
     7     DHDI1,DHDI2,DHDJ1,DHDJ2,DHDI,DHDJ,XDEN,DP,X,Y,Z,DELTAP,PB0,
     8     UCONV2,UCONV1,UCONV,RUCONV,TOM,CX,CY,CZ,CMX,CMY,CMZ,DX,DY,
     9     DZ,QX,QY,QZ,FRSVEL
      
      REAL :: F3R(*),F3RW(*),F3E(*),P(*),V(*),U(*),C(*),RO(*),A3(*),
     2 A3Y(*),A3Z(*),A3X(*),OHMI(*),VIS(*),EPS2(*),VIST(*),PDI(*),
     3 F3RN(*),W(*),VOL(*),F3RM(*),
     4 UROT(*),TEMP(*),CH(*),  !UBK(*),VBK(*),WBK(*),
     5 HFLUX(*),RCON(*),E(*)

      REAL :: XC(*),YC(*),ZC(*),XCO(*),YCO(*),ZCO(*)
      REAL :: GXX,GYY,GZZ,XMOM,YMOM,ZMOM
C
C ... free surface fluxes
C
      WTEMP   = RCON(5)
      WFLUX   = RCON(6)

      EPS3    = 1.E-20
      RC1     = 1.500
      RC2     = RC1 - 1.
C ... FOR TURBULENCE
      RM1     = 1.000
      RM2     = RM1 - 1.
      PRS     = PR/PRT

      LSTRID  = KSTR*IDIR
      IF(IDIR ==  1) NFL = 0
      IF(IDIR == -1) NFL = -LSTRID

      YMR     = .166666667
      YPG     = DIFPRE
      YP1     = 1.
      YP4     = 0.
      RSUM    = 0.
      IF(M == 1) RSUM = 1.
      IF(IFLUX == 3 .OR. IFLUX == 4 .OR. IFLUX == 7) THEN ! PRESSURE DIFFERENCE
c      IF(IFLUX == 4) THEN ! PRESSURE DIFFERENCE
         YPG  = DIFPRE - FRSPRE
         YP1  = 0.
         YP4  = 1.
      ENDIF
      EPS     = 1.E-3                                    ! 10

      TSURF   = T0
      IHFL    = 0
      IHT     = 1
      IF(IHEAT == 2 .OR. IHEAT >= 12) IHFL  = 1
      IF(IHEAT == 0) IHT = 0

C ... IHEAT = 0 ADIABATIC
C ...         1,11 WALL TEMPERATURE IS GIVEN (WTEMP)
C ...         2,12,13,14 HEAT FLUX IS GIVEN        (WFLUX)

      VISLIM  = 0.01*FRSVIS
      CHLIM   = 100.*FRSVIS
      ROLIM   = .001*FRSDEN

      KA      = (KN+KBOT-1)*KSTR

C ... VISCOUS SURFACE FLUXES

      XMASS = 0.
      AREA  = 0.
      DO J = KY1,KY2
      IJ      = (JN+J-1)*JSTR + KA
      NN      = (J-KY1)*(KX2-KX1+1)
      N1      = (JN+J-1)*ISTRID + IN
      DO I = KX1,KX2
      II      = (IN+I-1)*ISTR  + IJ + 1  ! CELL INDEX (STRIDE=ISTR)
      II1     = II + LSTRID              ! THE SECOND CELL
      II2     = II + LSTRID     ! 2. comp cell
      IF1     = II + NFL                 ! FLUX INDEX
      NI      = I  + N1                  ! PATCH VELOCITY INDEX
         NH      = NN + I-KX1 + 1 ! Patch tempperature index
         EPS2B   = MAX(1.    ,RC1*EPS2(II) - RC2*EPS2(II1))
         VISTB   = MAX(0.    ,RC1*VIST(II) - RC2*VIST(II1))
         VISB    = MAX(VISLIM,RC1*VIS(II)  - RC2*VIS(II1))
         CHSB    = MAX(CHLIM ,RC1* CH(II)  - RC2* CH(II1))
         OHMIB   = MAX(EPS   ,RC1*OHMI(II) - RC2*OHMI(II1))
         ROB     = MAX(ROLIM ,RC1*RO(II)   - RC2*RO(II1))
         DIST    = (A3(IF1)+A3(IF1+LSTRID))/VOL(II)
         SURG    =-DIST*YMR
         SURF    = SURG*EPS2B*VISB
         SURFE   = SURG*(PRS*VISTB/VISB+1.)*CHSB

c         USURF   = UBK(NI)
c         VSURF   = VBK(NI)
c         WSURF   = WBK(NI) ! Laitoin kommentit,  koska eivät käytössä
c         CVII    = IDIR*(9.000*TEMP1 - 1.000*TEMP2  - 8.*TSURF)
c
c         DUC     = .33333*(A3Y(II)*VVII + A3Z(II)*WVII+ A3X(II)*UVII)
c         F2V     = SURF*(UVII + A3X(II)*DUC)
c         F3V     = SURF*(VVII + A3Y(II)*DUC)
c         F4V     = SURF*(WVII + A3Z(II)*DUC)
c         F5VF    = USURF*F2V  + VSURF*F3V + WSURF*F4V
c         F5VQ    = (1-IHFL)*SURFE*CVII + IHFL*HFLUX(NH)
c         F5V     = F5VF + F5VQ

C ... CONVECTIVE FLUXES: EXTRAPOLATION OF PRESSURE OR PRESSURE DIFFERENCE

         PB1       = MAX(0.01*FRSPRE, RC1*P(II)   - RC2*P(II1))
C        PB4       = RC1*PDI(II) - RC2*PDI(II1)
C ...  kaatuu. Eika kaadu
         PB4       = MAX(-.99*FRSPRE, RC1*PDI(II) - RC2*PDI(II1))
         PB        = YP1*PB1 + YP4*PB4
c         F3R(IF1)      = 0.
c         F3RM(IF1)     = A3(IF1)*(A3X(IF1) *PB + F2V)
c         F3RN(IF1)     = A3(IF1)*(A3Y(IF1) *PB + F3V)
c         F3RW(IF1)     = A3(IF1)*(A3Z(IF1) *PB + F4V)
c         F3E(IF1)      = A3(IF1)*(UROT(IF1)*PB + F5V)

            L1 = IF1
            L2 = IF1+ISTR 
            L3 = IF1+JSTR
            L4 = IF1+ISTR+JSTR

            X1 = .25*XCO(L1) + XCO(L2) + XCO(L3) + XCO(L4)
            Y1 = .25*YCO(L1) + YCO(L2) + YCO(L3) + YCO(L4)
            Z1 = .25*ZCO(L1) + ZCO(L2) + ZCO(L3) + ZCO(L4)

            DI11 =                   SQRT((XCO(L1)-XCO(L1-ISTR))**2 + 
     +       (YCO(L1)-YCO(L1-ISTR))**2  + (ZCO(L1)-ZCO(L1-ISTR))**2)
            DI12 =                   SQRT((XCO(L1)-XCO(L1+ISTR))**2 + 
     +       (YCO(L1)-YCO(L1+ISTR))**2  + (ZCO(L1)-ZCO(L1+ISTR))**2)
            DI13 =                   SQRT((XCO(L2)-XCO(L2+ISTR))**2 + 
     +       (YCO(L2)-YCO(L2+ISTR))**2  + (ZCO(L2)-ZCO(L2+ISTR))**2)

            DI21 =                   SQRT((XCO(L3)-XCO(L3-ISTR))**2 + 
     +       (YCO(L3)-YCO(L3-ISTR))**2  + (ZCO(L3)-ZCO(L3-ISTR))**2)
            DI22 =                   SQRT((XCO(L3)-XCO(L3+ISTR))**2 + 
     +       (YCO(L3)-YCO(L3+ISTR))**2  + (ZCO(L3)-ZCO(L3+ISTR))**2)
            DI23 =                   SQRT((XCO(L4)-XCO(L4+ISTR))**2 + 
     +       (YCO(L4)-YCO(L4+ISTR))**2  + (ZCO(L4)-ZCO(L4+ISTR))**2)


            DJ11 =                   SQRT((XCO(L1)-XCO(L1-JSTR))**2 + 
     +       (YCO(L1)-YCO(L1-JSTR))**2  + (ZCO(L1)-ZCO(L1-JSTR))**2)
            DJ12 =                   SQRT((XCO(L1)-XCO(L1+JSTR))**2 + 
     +       (YCO(L1)-YCO(L1+JSTR))**2  + (ZCO(L1)-ZCO(L1+JSTR))**2)
            DJ13 =                   SQRT((XCO(L3)-XCO(L3+JSTR))**2 + 
     +       (YCO(L3)-YCO(L3+JSTR))**2  + (ZCO(L3)-ZCO(L3+JSTR))**2)

            DJ21 =                   SQRT((XCO(L2)-XCO(L2-JSTR))**2 + 
     +       (YCO(L2)-YCO(L2-JSTR))**2  + (ZCO(L2)-ZCO(L2-JSTR))**2)
            DJ22 =                   SQRT((XCO(L2)-XCO(L2+JSTR))**2 + 
     +       (YCO(L2)-YCO(L2+JSTR))**2  + (ZCO(L2)-ZCO(L2+JSTR))**2)
            DJ23 =                   SQRT((XCO(L4)-XCO(L4+JSTR))**2 + 
     +       (YCO(L4)-YCO(L4+JSTR))**2  + (ZCO(L4)-ZCO(L4+JSTR))**2)


            II7      = KX2-KX1+2
            NT = NH + II7

            GTOT = GX+GY+GZ+1.E-10
            GXX  = GX/GTOT
            GYY  = GY/GTOT
            GZZ  = GZ/GTOT

            I1M2 = IF1 - ISTR
            I1M1 = IF1
            I1P1 = IF1 + ISTR
            I1P2 = IF1 + 2*ISTR
            H1M2 = GXX*XCO(I1M2)+GYY*YCO(I1M2)+GZZ*ZCO(I1M2)
            H1M1 = GXX*XCO(I1M1)+GYY*YCO(I1M1)+GZZ*ZCO(I1M1)
            H1P1 = GXX*XCO(I1P1)+GYY*YCO(I1P1)+GZZ*ZCO(I1P1)
            H1P2 = GXX*XCO(I1P2)+GYY*YCO(I1P2)+GZZ*ZCO(I1P2)
            I1M2 = IF1 - ISTR   + JSTR
            I1M1 = IF1          + JSTR
            I1P1 = IF1 + ISTR   + JSTR
            I1P2 = IF1 + 2*ISTR + JSTR
            H2M2 = GXX*XCO(I1M2)+GYY*YCO(I1M2)+GZZ*ZCO(I1M2)
            H2M1 = GXX*XCO(I1M1)+GYY*YCO(I1M1)+GZZ*ZCO(I1M1)
            H2P1 = GXX*XCO(I1P1)+GYY*YCO(I1P1)+GZZ*ZCO(I1P1)
            H2P2 = GXX*XCO(I1P2)+GYY*YCO(I1P2)+GZZ*ZCO(I1P2)

            I1M2 = IF1 - JSTR
            I1M1 = IF1
            I1P1 = IF1 + JSTR
            I1P2 = IF1 + 2*JSTR
            H3M2 = GXX*XCO(I1M2)+GYY*YCO(I1M2)+GZZ*ZCO(I1M2)
            H3M1 = GXX*XCO(I1M1)+GYY*YCO(I1M1)+GZZ*ZCO(I1M1)
            H3P1 = GXX*XCO(I1P1)+GYY*YCO(I1P1)+GZZ*ZCO(I1P1)
            H3P2 = GXX*XCO(I1P2)+GYY*YCO(I1P2)+GZZ*ZCO(I1P2)

            I1M2 = IF1 - JSTR   + ISTR
            I1M1 = IF1          + ISTR
            I1P1 = IF1 + JSTR   + ISTR
            I1P2 = IF1 + 2*JSTR + ISTR
            H4M2 = GXX*XCO(I1M2)+GYY*YCO(I1M2)+GZZ*ZCO(I1M2)
            H4M1 = GXX*XCO(I1M1)+GYY*YCO(I1M1)+GZZ*ZCO(I1M1)
            H4P1 = GXX*XCO(I1P1)+GYY*YCO(I1P1)+GZZ*ZCO(I1P1)
            H4P2 = GXX*XCO(I1P2)+GYY*YCO(I1P2)+GZZ*ZCO(I1P2)


            DHDI1 = ((H1P2 - H1P1)/DI13 - (H1M1 - H1M2)/DI11)/(2.*DI12)
            DHDI2 = ((H2P2 - H2P1)/DI23 - (H2M1 - H2M2)/DI21)/(2.*DI22)
            DHDJ1 = ((H3P2 - H3P1)/DJ13 - (H3M1 - H3M2)/DJ11)/(2.*DJ12)
            DHDJ2 = ((H4P2 - H4P1)/DJ23 - (H4M1 - H4M2)/DJ21)/(2.*DJ22)

            DHDI = .5*(DHDI1+DHDI2)
            DHDJ = .5*(DHDJ1+DHDJ2)
            

            XDEN = .0727        ! surface tension for water T= 20 C
            DP   = XDEN*(DHDI + DHDJ)



         X = .25*XCO(IF1)+XCO(IF1+ISTR)+XCO(IF1+JSTR)
     &                   +XCO(IF1+ISTR+JSTR)
         Y = .25*YCO(IF1)+YCO(IF1+ISTR)+YCO(IF1+JSTR)
     &                   +YCO(IF1+ISTR+JSTR)
         Z = .25*ZCO(IF1)+ZCO(IF1+ISTR)+ZCO(IF1+JSTR)
     &                   +ZCO(IF1+ISTR+JSTR)
         DELTAP  = FRSDEN*(GX*X + GY*Y + GZ*Z - GTOT*GROUND)

C         PB = .3*PB -.7*DELTAP
         PB0 = - DELTAP -DP
c         if(i <=  kx2/6) then ! maailman yksinkertaisin ylavirtapainotus
c            UCONV2 = A3X(IF+JSTR)*U(II+JSTR) + A3Y(IF+JSTR)*V(II+JSTR) + 
c     +           A3Z(IF+JSTR)*W(II+JSTR)! ja ehka huonoin....
c         elseif(i <=  3*kx2/4) then
c            UCONV2 = A3X(IF+ISTR)*U(II+ISTR) + A3Y(IF+ISTR)*V(II+ISTR) + 
c     +           A3Z(IF+ISTR)*W(II+ISTR)
c         else
c            UCONV2 = A3X(IF-JSTR)*U(II-JSTR) + A3Y(IF-JSTR)*V(II-JSTR) + 
c     +           A3Z(IF-JSTR)*W(II-JSTR)
c         endif
c         UCONV = .5*UCONV + .5*UCONV2 ! puolesta valista koppia.

         UCONV2 = A3X(IF1)*U(II1) + A3Y(IF1)*V(II1) + A3Z(IF1)*W(II1)
         UCONV1 = A3X(IF1)*U(II) + A3Y(IF1)*V(II) + A3Z(IF1)*W(II)

C ... remeber to change the UNOR too in SURSET.
         UCONV = UCONV1  ! first order
c         UCONV = .125*(9.*UCONV1 - UCONV2) ! second order zero gradient
         

c         UCOR = (PB-PB0)/(.5*ROB*(ABS(UCONV)+FRSVEL)*30.) ! ei toimi
c         UCONV = UCONV + UCOR

c         uconv = 0.


         F3R(IF1)  = A3(IF1)*(ROB*UCONV)
         F3RM(IF1) = A3(IF1)*(A3X(IF1) * PB0 + ROB*UCONV*U(II))
         F3RN(IF1) = A3(IF1)*(A3Y(IF1) * PB0 + ROB*UCONV*V(II))
         F3RW(IF1) = A3(IF1)*(A3Z(IF1) * PB0 + ROB*UCONV*W(II))
         F3E(IF1)  = A3(IF1)*((UROT(IF1)+UCONV)*(PB0+E(II) )) 
c         F3E(IF1)  = A3(IF1)*((UROT(IF1)+UCONV)*(PB0 )) 


         AREA = AREA + A3(IF1)
         XMASS = XMASS + F3R(IF1)
         IF(M == 1 .AND. I >= 1 .AND. J >= 1) THEN
            WRITE(86,'(2I5,10G14.4)') I,J,F3R(IF1),F3RW(IF1),
     +           F3R(IF1)/A3(IF1)/ROB,PB0,-dp,-deltap
         ENDIF

      ENDDO
      if(m == 1) write(86,*)
      enddo
 1000 CONTINUE
      if(m == 1) close(86)
      if(m == 1) write(91,*) icycle,xmass,XMASS/AREA/FRSDEN,AREA
      DO J = KY1,KY2 ! correct so that total mass flow is zero
         IJ      = (JN+J-1)*JSTR + KA
         NN      = (J-KY1)*(KX2-KX1+1)
         N1      = (JN+J-1)*ISTRID + IN
         DO I = KX1,KX2
            II      = (IN+I-1)*ISTR  + IJ + 1 ! CELL INDEX (STRIDE=ISTR)
            II1     = II + LSTRID ! THE SECOND CELL
            II2     = II + LSTRID ! 2. comp cell
            IF1    = II + NFL  ! FLUX INDEX
            NI      = I  + N1   ! PATCH VELOCITY INDEX
            NH      = NN + I-KX1 + 1 ! Patch tempperature index
        X = .25*XCO(IF1)+XCO(IF1+ISTR)+XCO(IF1+JSTR)
     &                  +XCO(IF1+ISTR+JSTR)
        Y = .25*YCO(IF1)+YCO(IF1+ISTR)+YCO(IF1+JSTR)
     &                  +YCO(IF1+ISTR+JSTR)
        Z = .25*ZCO(IF1)+ZCO(IF1+ISTR)+ZCO(IF1+JSTR)
     &                  +ZCO(IF1+ISTR+JSTR)
            DELTAP  = FRSDEN*(GX*X + GY*Y
     +           +            GZ*Z-GTOT*GROUND)

            PB0 = - DELTAP      ! -DP
            RUCONV = -XMASS/AREA
            F3R(IF1)  = F3R(IF1) + A3(IF1)*RUCONV
            F3RM(IF1) = F3RM(IF1)+ A3(IF1)*RUCONV*U(II)
            F3RN(IF1) = F3RN(IF1)+ A3(IF1)*RUCONV*V(II)
            F3RW(IF1) = F3RW(IF1)+ A3(IF1)*RUCONV*W(II)
            F3E(IF1)  = F3E(IF1) + A3(IF1)*RUCONV*(E(II)+PB0)/FRSDEN
c            F3E(IF1)      = 0.
         ENDDO
      ENDDO

      RETURN
      END SUBROUTINE BOTSF
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C

