c Please do not edit this file - this is just a concatenation of the source files - edit them instead !
c ti 27.2.2007 15:08:11 +0200
C
C***********************************************************************
C grid3.f
C
      subroutine grid3(x,y,z,l,m,n,xi,eta,zeta,wh,xhull,yhull,zhull,
     $ lhull,mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop,
     $ pdiff,zztop,iglobl,nglobl,CX,CY,CZ,CM,XMOM,YMOM,ZMOM,FRSVEL,GZ,
     $ AKG,LVLSTP,xvel,yvel,zvel,ICYCLE,ICMAX,AREF,CHLREF,REFPRE,INDXFS,
     $ IBLOCK)
c x,y,z - the grid (vertices)
c l,m,n - number of grid cells in i,j,k directions without phantom cells
c xi,eta,zeta - work space
c wh - free surface data
c nout - maximum number of outer iterations 
c        (ended automatically when the grid becomes regular)
c nin - number of inner iterations (no regularity check in between)
c relax - relaxation parameter (relax should probably be about 1.0)

c please note that there really are two phantom cells below 
c and one phantom cell above - don't ask why
      USE XYZK
      USE TZANSC
      USE SKIP
      USE STRIM
      USE TRSINK
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xvel(-2:l+1,-2:m+1,-2:n+1)
      real yvel(-2:l+1,-2:m+1,-2:n+1)
      real zvel(-2:l+1,-2:m+1,-2:n+1)
c      real zztop(-2:l+1,-2:m+1,-2:n+1)
      real zztop(0:l,0:m,0:n)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)

c wh is at the center of the cell
c cells go like 0...l-1, 0...m-1
      real wh(*),pdiff(*)
      character*10 stre
      character*8 mytime
      logical ex
c	call swh(wh,l,m)

c experiment on how to make convergence faster for sinkage and trim:
c different froude numbers seem to possess different convergence behavior:
c      froude=FRSVEL/sqrt(9.81*2.5) ! Wigley L=2.5
      froude=1.0 ! neutral value

c calculate sink'n'trim
c      if (isinkt == 4.and.INDXFS /= 0)
      if (isinkt == 4) 
     $ call Mstdd(x,y,z,l,m,n,icode,ibot,itop,0,n,
     $ XMOM,YMOM,ZMOM,CX,CY,CZ,CM,FRSVEL,GZ,AKG,froude,ICYCLE,IBLOCK,
     $ AREF,CHLREF)

      if (INDXFS == 0) then
c update the grid according to sink'n'trim and do nothin' else
        dsink=sink-osink
        dtrim=trimm-otrim
        if (isinkt /= 0) call dostg(x,y,z,l,m,n,
     $   dsink,dtrim,xtrim,ztrim,0.0,0.0,oxtrim,oztrim)
        return
      end if
      
c calculate grid velocity ... (store previous coordinates to *vel)
        do k=0,n
        do j=0,m
        do i=0,l
        xvel(i,j,k)=x(i,j,k)
        yvel(i,j,k)=y(i,j,k)
        zvel(i,j,k)=z(i,j,k)
        end do
        end do
        end do

c see if there are NaNs in the WH-data
      call whchk(x,y,z,wh,l,m,n,ibot,itop,jbot,jtop,kbot,ktop)

      
c maroon-check
      if (lhull < 0 .or. mhull < 0 .or. 
     $ (lhull <= 0 .and. mhull <= 0)) then
        write(6,*)'What are you trying to do, man !'
        write(6,*)'Hull''s grid dimensions look like this, man:'
        write(6,*)lhull,mhull,nhull
        if (lhull < 0 .or. mhull < 0)
     $   write(6,*)'What is this crap, man !'
      end if

      icode=6 ! Water surface is at k=ktop
      
      if (ibasic == 3) then
c use so-called 3D-HULL.BIN
        call grid3d(x,y,z,l,m,n,xi,eta,zeta,wh,xhull,yhull,zhull,
     $   lhull,mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop,
     $   pdiff,zztop,iglobl,nglobl,CX,CY,CZ,CM,XMOM,YMOM,ZMOM,FRSVEL,GZ,
     $   AKG,LVLSTP,xvel,yvel,zvel,ICYCLE,ICMAX,REFPRE,
     $   INDXFS,IBLOCK,icode)
      else
c use so-called 2D-HULL.BIN
        call grid2d(x,y,z,l,m,n,xi,eta,zeta,wh,xhull,yhull,zhull,
     $   lhull,mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop,
     $   pdiff,zztop,iglobl,nglobl,CX,CY,CZ,CM,XMOM,YMOM,ZMOM,FRSVEL,GZ,
     $   AKG,LVLSTP,xvel,yvel,zvel,ICYCLE,ICMAX,REFPRE,
     $   INDXFS,IBLOCK,icode)
      end if

c for possible RSTART we must store the sinked and trimmed HULL.BIN
      if (ICYCLE == ICMAX) 
     $ call whull(xhull,yhull,zhull,lhull,mhull,nhull,LVLSTP,
     $ 'HULLST.BIN')
c      if (ICYCLE == ICMAX) 
c     $ call wgridi(x,y,z,l,m,n,'GRIDST.BIN')

c ... calculate grid velocity (subtract from present coordinates and store to *vel)
      do k=0,n
      do j=0,m
      do i=0,l
      xvel(i,j,k)=x(i,j,k)-xvel(i,j,k)
      yvel(i,j,k)=y(i,j,k)-yvel(i,j,k)
      zvel(i,j,k)=z(i,j,k)-zvel(i,j,k)
      end do
      end do
      end do

      return
      end
C
C***********************************************************************
      subroutine grid3d(x,y,z,l,m,n,xi,eta,zeta,wh,xhull,yhull,zhull,
     $ lhull,mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop,
     $ pdiff,zztop,iglobl,nglobl,CX,CY,CZ,CM,XMOM,YMOM,ZMOM,FRSVEL,GZ,
     $ AKG,LVLSTP,xvel,yvel,zvel,ICYCLE,ICMAX,REFPRE,INDXFS,
     $ IBLOCK,icode)
c Handle grid deformation for 3D HULL.BIN

c x,y,z - the grid (vertices)
c l,m,n - number of grid cells in i,j,k directions without phantom cells
c xi,eta,zeta - work space
c wh - free surface data
c nout - maximum number of outer iterations 
c        (ended automatically when the grid becomes regular)
c nin - number of inner iterations (no regularity check in between)
c relax - relaxation parameter (relax should probably be about 1.0)

c please note that there really are two phantom cells below 
c and one phantom cell above - don't ask why
      USE XYZK
      USE TZANSC
      USE SKIP
      USE STRIM
      USE TRSINK
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xvel(-2:l+1,-2:m+1,-2:n+1)
      real yvel(-2:l+1,-2:m+1,-2:n+1)
      real zvel(-2:l+1,-2:m+1,-2:n+1)
c      real zztop(-2:l+1,-2:m+1,-2:n+1)
      real zztop(0:l,0:m,0:n)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)

c wh is at the center of the cell
c cells go like 0...l-1, 0...m-1
      real wh(*),pdiff(*)
      character*10 stre
      character*8 mytime
      logical ex

c      if (icode == 1 .or. icode == 4) call manipi(x,y,z,wh,l,m,n,
c     $ xi,eta,zeta,icode,xhull,yhull,zhull,lhull,
c     $ mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop)
c      if (icode == 2 .or. icode == 5) call manipj(x,y,z,wh,l,m,n,
c     $ xi,eta,zeta,icode,xhull,yhull,zhull,lhull,
c     $ mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop)
      if (icode == 3 .or. icode == 6) call manip(x,y,z,wh,l,m,n,
     $ xi,eta,zeta,icode,xhull,yhull,zhull,lhull,
     $ mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop,
     $ XMOM,YMOM,ZMOM,CX,CY,CZ,CM,FRSVEL,GZ,AKG,zztop)


c check for negative volumes
      call gskew3(x,y,z,l,m,n,0,l,0,m,0,n,rhomin,mini,minj,mink,nleft,
     $ ibneg,itneg,jbneg,jtneg,kbneg,ktneg,iglobl)
c      write(6,'(2i8,1e16.6,3i4/)') 0,nleft,rhomin,mini,minj,mink
      if (nleft /= 0) write(6,*) nleft,' negative cells found !'

      if (nleft == 0) goto 9999
      
c Oh shit ! There are negative volumes there !
      write(6,*) 'Negative cell volumes found e.g. at',
     $ mini,minj,mink
      write(6,*) 'Unfortunately, no grid resolving method is available.'
      write(6,*) 'With 3D HULL.BIN the grid points are restricted on'
      write(6,*) 'verticals and any resolving seems hopeless. Sorry !'

c write gridi ...
        call wgridi(x,y,z,l,m,n,'gridi.3d')
        call wwhi(wh,l,m,'wh.dat')
c ... gridi written

9999  continue
      return
      end
C
C***********************************************************************
      subroutine manip(x,y,z,wh,l,m,n,xi,eta,zeta,icode,
     $ xhull,yhull,zhull,lhull,mhull,nhull,
     $ ibot,itop,jbot,jtop,kbot,ktop,XMOM,YMOM,ZMOM,CX,CY,CZ,CM,
     $ FRSVEL,GZ,AKG,zztop)

      USE STRIM
      USE TRSINK
      USE TZANSC
      USE XYZK
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
c      real zztop(-2:l+1,-2:m+1,-2:n+1)
      real zztop(0:l,0:m,0:n)
      real wh(-1:l,-1:m)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)
      logical doj
C***********************************************************************
      data err/1.0e-6/
c      anomin(a)=sign(amax1(abs(a),1.0e-6),a)

c icode = 6 -> freesurface = ktop

      if (icode == 6) then
call smowh(wh,l,m,3*l/4,l,0,m/4) ! Combatant aft


c update the grid according to sink'n'trim
        if (isinkt /= 0) call sinktr(x,y,z,l,m,n,xi,eta,zeta,icode,
     $   xhull,yhull,zhull,lhull,mhull,nhull,
     $   ibot,itop,jbot,jtop,kbot,ktop)
c relative version:
c        if (isinkt /= 0) call rsinkt(x,y,z,l,m,n,xi,eta,zeta,icode,
c     $   xhull,yhull,zhull,lhull,mhull,nhull,
c     $   ibot,itop,jbot,jtop,kbot,ktop)
         if (isinkt < 0) then
           osink=sink
           otrim=trimm
         end if

        limit=0

        do i=0,l
        doj=.true.
        do j=0,m
c        if (.not.doj) goto 9000  
        i1=i
        j1=j
        i2=i-1
        j2=j
        i3=i
        j3=j-1
        i4=i-1
        j4=j-1
c restrictions no longer needed since ghost cells contain something
c        i1=max(min(i1,l-1),0)
c        j1=max(min(j1,m-1),0)
c        i2=max(min(i2,l-1),0)
c        j2=max(min(j2,m-1),0)
c        i3=max(min(i3,l-1),0)
c        j3=max(min(j3,m-1),0)
c        i4=max(min(i4,l-1),0)
c        j4=max(min(j4,m-1),0)

        z0=0.0
        diff=0.25*(wh(i1,j1)+wh(i2,j2)+wh(i3,j3)+wh(i4,j4))+z0-z(i,j,n)

c limitter patches
call limz(i,j,z(i,j,n),diff,limit,jlimf,xi,eta,l,m,n,igo)
        call limzxy(i,j,z(i,j,n),diff,limit,jlimf,xi,eta,l,m,n,igo,x,y)
	if (igo == 1) goto 9000

        do k=kbot,n
        
c scale to local cell height
c history: 
c once the grid was concentrated close to bulb but not close to water surface
c i.e. the cells got smaller going downwards, which led to trouble
        if (diff < 0.0) then
          cf=(zeta(i,j,k)-zeta(i,j,max(k-1,kbot)))/
     $     (zeta(i,j,n)-zeta(i,j,n-1))
        else if (k == n) then
          cf=1.0
        else
          cf=(zeta(i,j,k+1)-zeta(i,j,k))/
     $     (zeta(i,j,n)-zeta(i,j,n-1))
        end if
c for Heaven's sake do not amplify
        cf=amin1(cf,1.0)

        xd=0.0
        yd=0.0
        zd=diff*echok(x,y,z,l,m,n,xi,eta,zeta,i,j,k,kbot,ktop)*cf
c        zd=diff*echok(x,y,z,l,m,n,xi,eta,zeta,i,j,k,kbot,kfirst)*cf

        
c sort of assume that n=ktop
          ihull1=i-ibot
          jhull1=j-jbot

c developed for 3D HULL.BIN
c maintain the stretching
          zwh=z(i,j,n)+diff
          call sloczi(ihull1,jhull1,xhull,yhull,zhull,
     $     lhull,mhull,nhull,i-ibot,j-jbot,k-kbot,xi,eta,zeta,l,m,n,
     $     x(i,j,k),y(i,j,k),z(i,j,k),zwh,kbot,ktop,zztop,z,0,0,0)

        end do ! k

9000    continue  
        end do ! j
        end do ! i

        virgin=.false.

        return
      end if

      return
      end
C
C***********************************************************************
C grid2d.f
C
      subroutine grid2d(x,y,z,l,m,n,xi,eta,zeta,wh,xhull,yhull,zhull,
     $ lhull,mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop,
     $ pdiff,zztop,iglobl,nglobl,CX,CY,CZ,CM,XMOM,YMOM,ZMOM,FRSVEL,GZ,
     $ AKG,LVLSTP,xvel,yvel,zvel,ICYCLE,ICMAX,REFPRE,INDXFS,
     $ IBLOCK,icode)
c x,y,z - the grid (vertices)
c l,m,n - number of grid cells in i,j,k directions without phantom cells
c xi,eta,zeta - work space
c wh - free surface data
c nout - maximum number of outer iterations 
c        (ended automatically when the grid becomes regular)
c nin - number of inner iterations (no regularity check in between)
c relax - relaxation parameter (relax should probably be about 1.0)

c please note that there really are two phantom cells below 
c and one phantom cell above - don't ask why
      USE XYZK
      USE TZANSC
      USE SKIP
      USE STRIM
      USE TRSINK
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xvel(-2:l+1,-2:m+1,-2:n+1)
      real yvel(-2:l+1,-2:m+1,-2:n+1)
      real zvel(-2:l+1,-2:m+1,-2:n+1)
c      real zztop(-2:l+1,-2:m+1,-2:n+1)
      real zztop(0:l,0:m,0:n)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)

c wh is at the center of the cell
c cells go like 0...l-1, 0...m-1
      real wh(*),pdiff(*)
      character*10 stre
      character*8 mytime
      logical ex

      iskip=1
      ifix=0
      lime=0

      nout=iabs(nglobl)
      nin=1
      relax=1.0


c      if (icode == 1 .or. icode == 4) call manipi(x,y,z,wh,l,m,n,
c     $ xi,eta,zeta,icode,xhull,yhull,zhull,lhull,
c     $ mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop)
c      if (icode == 2 .or. icode == 5) call manipj(x,y,z,wh,l,m,n,
c     $ xi,eta,zeta,icode,xhull,yhull,zhull,lhull,
c     $ mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop)
      if (icode == 3 .or. icode == 6) call manipk(x,y,z,wh,l,m,n,
     $ xi,eta,zeta,icode,xhull,yhull,zhull,lhull,
     $ mhull,nhull,ibot,itop,jbot,jtop,kbot,ktop,
     $ XMOM,YMOM,ZMOM,CX,CY,CZ,CM,FRSVEL,GZ,AKG,zztop)

c ibasic=2 basically regenerates the whole grid
      if (ibasic == 2) call dodaj(x,y,z,l,m,n,xi,eta,zeta,iabs(nglobl),
     $ 0,0,l,0,m,0,n)

c check for negative volumes
      call gskew3(x,y,z,l,m,n,0,l,0,m,0,n,rhomin,mini,minj,mink,nleft,
     $ ibneg,itneg,jbneg,jtneg,kbneg,ktneg,iglobl)
c      write(6,'(2i8,1e16.6,3i4/)') 0,nleft,rhomin,mini,minj,mink
      if (nleft /= 0) write(6,*) nleft,' negative cells found !'

      if (nleft == 0) goto 9999
      
c Oh shit ! There are negative volumes there !
      write(6,*) 'Negative cell volumes found e.g. at',
     $ mini,minj,mink
      write(6,*) 'Switching to iterative mode.'
      write(6,*) 'May the Force be with You !'

      goto 1098 ! skip the transom thing for now
      iretur=0
      if (minj == 0.and.mini+1 >= ibtrns.and.mini <= ittrns
     $ .and.mink+1 >= ktrnsm.and.mink <= ktrnsm) then
1099    continue
        iretur=-1
        nleft1=nleft
        write(6,*)
        write(6,*) 'Supposedly transom, man !'
        write(6,*)'Transom special treatment section taking over, man !'
        write(6,*) 'Whaddaya think of that, man !'
        call tr3(x,y,z,l,m,n,xi,eta,zeta,max(min(8,m),m/1000),
     $   0.01,1.0,mini,mini+1,mink+1,mink+1)
        call gskew3(x,y,z,l,m,n,0,l,0,m,0,n,rhomin,mini,minj,mink,nleft,
     $   ibneg,itneg,jbneg,jtneg,kbneg,ktneg,iglobl)
        write(6,'(2i8/)') 0,nleft
        if (nleft < nleft1.and.nleft > 0) goto 1099
        if (nleft == 0) iretur=1
      end if
1098     continue
c write gridi ...
        call wgridi(x,y,z,l,m,n,'gridi.3d')
        call wwhi(wh,l,m,'wh.dat')
call whulli(xhull,yhull,zhull,lhull,mhull,nhull,'h.3d')
call time(mytime)
call wgridi(x,y,z,l,m,n,mytime)
c ... gridi written
        if (iretur == 1) goto 9999
        if (iretur == -1) stop 'Remove me !'
ccccccccccccccccccccccccccccccccccc
        if (nglobl < 0) then
          call dodaj(x,y,z,l,m,n,xi,eta,zeta,iabs(nglobl),2,
     $     ibneg,itneg,0,m,0,n)
          call dodaj(x,y,z,l,m,n,xi,eta,zeta,iabs(nglobl),2,
     $     l-3,l,0,m,0,n) ! JFF - in practise the last slice goes bad although not negative
          call wgridi(x,y,z,l,m,n,'gridio.3d')
	  goto 9999
	end if
ccccccccccccccccccccccccccccccccccc

      intstr=0
      if (iglobl == 0) then
c iterate the whole damn region
        ibdo=0
        jbdo=0
        kbdo=0
        itdo=l
        jtdo=m
        ktdo=n
      else
c iterate the surroundings only
        ibdo=max(ibneg-iglobl,0)
        jbdo=max(jbneg-iglobl,0)
        kbdo=max(kbneg-iglobl,0)
        itdo=min(itneg+1+iglobl,l)
        jtdo=min(jtneg+1+iglobl,m)
        ktdo=min(ktneg+1+iglobl,n)

c don't mess with the fixed grid
        kbdo=max(kbdo,kbot)
	intstr=1
      end if

c between jbot and jtop it is unnecessary even to try to resolve the grid
c only possible region would be from jtop to l
      jbdo=max(jbdo,jtop)
      if (jbdo == jtop.and.jtop > 0) then
        write(6,*) 'Quite unnecessary to try to resolve with 3DHULL'
        write(6,*) 'Should not be here !!!'
	goto 9999
      end if
      
      if (intstr == 1) then
c actually we would need additional memory for this
        call mkstr(x,y,z,l,m,n,ibdo,itdo,jbdo,jtdo,kbdo,ktdo,
     $   xi,eta,zeta)
        write(6,*) 'Stretching functions re-interpolated.'
      end if


      write(6,*)' I think I''ll do',
     $ ibdo,itdo,jbdo,jtdo,kbdo,ktdo,' for you !'
      do 201 icnt=1,nout
      do 200 icount=1,nin

c a transformed stretched Laplace equation
      call sweep3(x,y,z,l,m,n,ibdo,itdo,jbdo,jtdo,kbdo,ktdo,
     $ xi,eta,zeta,relax,err)
      call bswe3(x,y,z,l,m,n,ibdo,itdo,jbdo,jtdo,kbdo,ktdo,
     $ xi,eta,zeta,relax,err)
      write(6,'(2i8,2e16.6)')icnt,icount,err

200   continue
      call gskew3(x,y,z,l,m,n,0,l,0,m,0,n,rhomin,mini,minj,mink,nleft,
     $ ibneg,itneg,jbneg,jtneg,kbneg,ktneg,iglobl)
c      write(6,'(2i8,1e16.6,3i4/)') icnt,nleft,rhomin,mini,minj,mink

      write(6,'(2i8/)') 0,nleft
      if (nleft == 0) goto 9998
      if (icnt > nout/2) then
c play hardball
      call gskew3(x,y,z,l,m,n,0,l,0,m,n-1,n,rhomin,mini,minj,mink,nleft,
     $ ibneg,itneg,jbneg,jtneg,kbneg,ktneg,iglobl)
c negative cells at surface
        if (nleft > 0) call smj(z,l,m,n,ibdo,itdo,jbdo,jtdo,kbdo,ktdo)
      end if
201   continue

cc after the stretched Laplace there are still negative volumes
cc if it fails near the body it might be a similar to RoPax problem
c      if (jbneg == 0 .and. jtneg < m/5 .and. itneg-ibneg < l/5
c     $ .and. ktneg-kbneg < n/5) then
c      write(6,*) 'Xcuse mua, I''ll try a small interpolation thing here'
c      write(6,*) 'Don''t worry - be happy !'
cc clearance
c        iclear=16
c        call ipolj(x,y,z,l,m,n,xi,eta,zeta,
c     $ ibneg,itneg+1,jbneg,jtneg+iclear+1,kbneg,ktneg+1)
c        call gskew3(x,y,z,l,m,n,0,l,0,m,0,n,rhomin,mini,minj,mink,nleft,
c     $   ibneg,itneg,jbneg,jtneg,kbneg,ktneg,iglobl)
c        if (nleft == 0) goto 9998
c      end if

      call dodaj(x,y,z,l,m,n,xi,eta,zeta,5,2,
     $ ibdo,itdo,jbdo,jtdo,kbdo,ktdo)
c now we're in deep shit, man !
c try ordinary Laplace

c actually I think this does more harm than good if continuation is possible
c so skip it
      goto 302

      do 301 icnt=1,nout
      do 300 icount=1,nin

c a transformed Laplace equation
      call ssweep3(x,y,z,l,m,n,ibdo,itdo,jbdo,jtdo,kbdo,ktdo,
     $ relax,err)
      write(6,'(2i8,2e16.6)')icnt,icount,err

300   continue
      call gskew3(x,y,z,l,m,n,0,l,0,m,0,n,rhomin,mini,minj,mink,nleft,
     $ ibneg,itneg,jbneg,jtneg,kbneg,ktneg,iglobl)
c      write(6,'(2i8,1e16.6,3i4/)') icnt,nleft,rhomin,mini,minj,mink
      write(6,'(2i8/)') 0,nleft
      if (nleft == 0) goto 9998
301   continue
302   continue

      write(6,*)'I''ll raise my hands up !'

9998  continue
      if (iglobl /= 0) then
        open(191,file='shipstretch.3d',form='unformatted')
        read(191)idummy
        read(191)ldummy,mdummy,ndummy
        read(191)xi,eta,zeta
        close(191)
      end if
9999  continue
      return
      end
C
C***********************************************************************
      subroutine whchk(x,y,z,wh,l,m,n,ibot,itop,jbot,jtop,kbot,ktop)
c check the wh
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real wh(-1:l,-1:m)

      whmax=-99999.9
      whmin=99999.9

      do j=0,m-1
      do i=0,l-1
      if (wh(i,j) > -1.0.or.wh(i,j) < 1.0) then
      else
c nan
        write(6,*) 'Cannot do: WH contains NaN values, man !'
        call wgridi(x,y,z,l,m,n,'NaNExitGrid.3d')
        stop 'Abnormal exit due to NaN condition'
      end if

      whmax=max(wh(i,j),whmax)
      whmin=min(wh(i,j),whmin)
      end do
      end do

      i=(ibot+itop)/2.0
      j=jbot
      d2=(x(i,j,ktop)-x(i,j,kbot))**2 + (y(i,j,ktop)-y(i,j,kbot))**2 + 
     $ (z(i,j,ktop)-z(i,j,kbot))**2       

      if (whmax**2 > 0.2*d2 .or. whmin**2 > 0.2*d2) then
        write(6,*) 'Quite deep waves, man !'
        write(6,*) 'Maximum WH is', whmax
        write(6,*) 'Minimum WH is', whmin
c        open(703,file='WHIGOT')
c        do j=0,m-1
c        do i=0,l-1
c        write(703,*)wh(i,j)
c        end do
c        end do
c        close(703)
      end if

      return
      end
C
C***********************************************************************
      subroutine wgridi(x,y,z,l,m,n,fname)
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      character*(*) fname

      open(196,file=fname,form='unformatted')
      write(196) 1
      write(196) l+1,m+1,n+1
      write(196)
     $ (((x(i,j,k),i=0,l),j=0,m),k=0,n),
     $ (((y(i,j,k),i=0,l),j=0,m),k=0,n),
     $ (((z(i,j,k),i=0,l),j=0,m),k=0,n)
      close(196)
      write(6,*)'The grid is written to a file: ',fname

      return
      end
C
C***********************************************************************
      subroutine wwhi(wh,l,m,fname)
      real wh(-1:l,-1:m)
      character*(*) fname

      open(196,file=fname,form='formatted')
      do j=0,m-1
      do i=0,l-1
      write(196,*) wh(i,j)
      end do
      end do
      close(196)
      write(6,*)fname,' written !'

      return
      end
C
C***********************************************************************
      subroutine smj(z,l,m,n,ibdo,itdo,jbdo,jtdo,kbdo,ktdo)
c smooth water surface
      real z(-2:l+1,-2:m+1,-2:n+1)

      write(6,'(a$)')'Water surface'
      if (kbdo == ktdo) return
      
      do k=max(kbdo,0),min(ktdo,n)
      do j=max(jbdo,0),min(jtdo,m)
      do i=max(ibdo,0),min(itdo,l)
      cf=0.25*(k-kbdo)/(ktdo-kbdo)
      z(i,j,n)=cf*z(i,j-1,k) + (1.0-2.0*cf)*z(i,j,k) + cf*z(i,j+1,k)
      end do
      end do
      end do
      write(6,'(a)')' smoothed !'

      return
      end
C
C***********************************************************************
C sweep3.f
C
      subroutine sweep3(x,y,z,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,
     $ xi,eta,zeta,relax,err)
c one sweep for laplace3
      USE SKIP
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      data aerr,errb/-1.0e-30,1.0e-12/

      s1=0.0
      err=0.0

      do 102 k=kbot+iskip,ktop-iskip,iskip
      do 101 j=jbot+iskip,jtop-iskip,iskip
      do 100 i=ibot+iskip,itop-iskip,iskip

      hminu=xi(i,j,k) - xi(i-iskip,j,k)
      hplus=xi(i+iskip,j,k) - xi(i,j,k)
      akminu=eta(i,j,k) - eta(i,j-iskip,k)
      akplus=eta(i,j+iskip,k) - eta(i,j,k)
      sminu=zeta(i,j,k) - zeta(i,j,k-iskip)
      splus=zeta(i,j,k+iskip) - zeta(i,j,k)

      if (hminu < errb) hminu=errb
      if (akminu < errb) akminu=errb
      if (sminu < errb) sminu=errb
      if (hplus < errb) hplus=errb
      if (akplus < errb) akplus=errb
      if (splus < errb) splus=errb

      h= hminu*hminu*hplus + hplus*hplus*hminu
      ak= akminu*akminu*akplus + akplus*akplus*akminu       
      s= sminu*sminu*splus + splus*splus*sminu

      xd1=d1_f(x,i,j,k,l,m,n,hminu,hplus)/h
      yd1=d1_f(y,i,j,k,l,m,n,hminu,hplus)/h
      zd1=d1_f(z,i,j,k,l,m,n,hminu,hplus)/h

      xd2=d2_f(x,i,j,k,l,m,n,akminu,akplus)/ak
      yd2=d2_f(y,i,j,k,l,m,n,akminu,akplus)/ak
      zd2=d2_f(z,i,j,k,l,m,n,akminu,akplus)/ak

      xd3=d3_f(x,i,j,k,l,m,n,sminu,splus)/s
      yd3=d3_f(y,i,j,k,l,m,n,sminu,splus)/s
      zd3=d3_f(z,i,j,k,l,m,n,sminu,splus)/s

c covariant components of the metric tensor
      g11=xd1*xd1 + yd1*yd1 + zd1*zd1
      g22=xd2*xd2 + yd2*yd2 + zd2*zd2
      g33=xd3*xd3 + yd3*yd3 + zd3*zd3
      g12=xd1*xd2 + yd1*yd2 + zd1*zd2
      g13=xd1*xd3 + yd1*yd3 + zd1*zd3
      g23=xd2*xd3 + yd2*yd3 + zd2*zd3

c cofactors
      cf11=g22*g33 - g23*g23
      cf12=g13*g23 - g12*g33
      cf13=g12*g23 - g13*g22
      cf22=g11*g33 - g13*g13
      cf23=g12*g13 - g11*g23
      cf33=g11*g22 - g12*g12

c 2nd derivatives (without the (i,j,k) term)
      xd1d1=d1d1_f(x,i,j,k,l,m,n,hminu,hplus)/h                             
      yd1d1=d1d1_f(y,i,j,k,l,m,n,hminu,hplus)/h                             
      zd1d1=d1d1_f(z,i,j,k,l,m,n,hminu,hplus)/h                             

      xd2d2=d2d2_f(x,i,j,k,l,m,n,akminu,akplus)/ak                             
      yd2d2=d2d2_f(y,i,j,k,l,m,n,akminu,akplus)/ak                             
      zd2d2=d2d2_f(z,i,j,k,l,m,n,akminu,akplus)/ak                             

      xd3d3=d3d3_f(x,i,j,k,l,m,n,sminu,splus)/s                             
      yd3d3=d3d3_f(y,i,j,k,l,m,n,sminu,splus)/s                             
      zd3d3=d3d3_f(z,i,j,k,l,m,n,sminu,splus)/s                             

      xd1d2=d1d2_f(x,i,j,k,l,m,n,hminu,hplus,akminu,akplus)
     $ /h/ak
      yd1d2=d1d2_f(y,i,j,k,l,m,n,hminu,hplus,akminu,akplus)
     $ /h/ak
      zd1d2=d1d2_f(z,i,j,k,l,m,n,hminu,hplus,akminu,akplus)
     $ /h/ak

      xd1d3=d1d3_f(x,i,j,k,l,m,n,hminu,hplus,sminu,splus)
     $ /h/s
      yd1d3=d1d3_f(y,i,j,k,l,m,n,hminu,hplus,sminu,splus)
     $ /h/s
      zd1d3=d1d3_f(z,i,j,k,l,m,n,hminu,hplus,sminu,splus)
     $ /h/s

      xd2d3=d2d3_f(x,i,j,k,l,m,n,akminu,akplus,sminu,splus)
     $ /ak/s
      yd2d3=d2d3_f(y,i,j,k,l,m,n,akminu,akplus,sminu,splus)
     $ /ak/s
      zd2d3=d2d3_f(z,i,j,k,l,m,n,akminu,akplus,sminu,splus)
     $ /ak/s

      a=coeff(cf11,cf22,cf33,cf12,cf13,cf23,
     $ hminu,hplus,akminu,akplus,sminu,splus,h,ak,s)
      if (abs(a) < aerr) goto 9999

      w1=cf11*xd1d1 + cf22*xd2d2 + cf33*xd3d3 + 2.0*cf12*xd1d2 
     $ + 2.0*cf13*xd1d3 + 2.0*cf23*xd2d3
      w1=w1/a
      dx=w1-x(i,j,k)
      err=err+dx*dx
      s1=s1+x(i,j,k)*x(i,j,k)
      x(i,j,k)=relax*w1 + (1.0-relax)*x(i,j,k)

      w2=cf11*yd1d1 + cf22*yd2d2 + cf33*yd3d3 + 2.0*cf12*yd1d2 
     $ + 2.0*cf13*yd1d3 + 2.0*cf23*yd2d3
      w2=w2/a
      dy=w2-y(i,j,k)
      err=err+dy*dy
      s1=s1+y(i,j,k)*y(i,j,k)
      y(i,j,k)=relax*w2 + (1.0-relax)*y(i,j,k)

      w3=cf11*zd1d1 + cf22*zd2d2 + cf33*zd3d3 + 2.0*cf12*zd1d2 
     $ + 2.0*cf13*zd1d3 + 2.0*cf23*zd2d3
      w3=w3/a
      dz=w3-z(i,j,k)
      err=err+dz*dz
      s1=s1+z(i,j,k)*z(i,j,k)
      z(i,j,k)=relax*w3 + (1.0-relax)*z(i,j,k)
100   continue
101   continue
102   continue

      if (s1 < 1.0e-9) s1=1.0e-9
      err=sqrt(err/s1)

      return
9999  continue
      write(6,*)'sweep3: a =',a,' <',aerr
      write(6,*)' i,j,k =',i,j,k
      write(6,*)' x,y,z =',x(i,j,k),
     + y(i,j,k),z(i,j,k)
      stop 'sweep3: fatal error occured'
      end
C
C***********************************************************************
      subroutine ssweep3(x,y,z,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,
     $ relax,err)
c one sweep for laplace3
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      data aerr,errb/-1.0e-30,1.0e-12/

      s1=0.0
      err=0.0
      iskip=1
      ifix=0

      do 102 k=kbot+iskip,ktop-iskip,iskip
      do 101 j=jbot+iskip,jtop-iskip,iskip
      do 100 i=ibot+iskip,itop-iskip,iskip

      if (ifix == 1 .and.
     $ (k-kbot)/2/iskip*2*iskip == k-kbot .and.
     $ (j-jbot)/2/iskip*2*iskip == j-jbot .and.
     $ (i-ibot)/2/iskip*2*iskip == i-ibot) goto 100

      xd1=0.5*(x(i+iskip,j,k)-x(i-iskip,j,k))
      yd1=0.5*(y(i+iskip,j,k)-y(i-iskip,j,k))
      zd1=0.5*(z(i+iskip,j,k)-z(i-iskip,j,k))

      xd2=0.5*(x(i,j+iskip,k)-x(i,j-iskip,k))
      yd2=0.5*(y(i,j+iskip,k)-y(i,j-iskip,k))
      zd2=0.5*(z(i,j+iskip,k)-z(i,j-iskip,k))

      xd3=0.5*(x(i,j,k+iskip)-x(i,j,k-iskip))
      yd3=0.5*(y(i,j,k+iskip)-y(i,j,k-iskip))
      zd3=0.5*(z(i,j,k+iskip)-z(i,j,k-iskip))

c covariant components of the metric tensor
      g11=xd1*xd1 + yd1*yd1 + zd1*zd1
      g22=xd2*xd2 + yd2*yd2 + zd2*zd2
      g33=xd3*xd3 + yd3*yd3 + zd3*zd3
      g12=xd1*xd2 + yd1*yd2 + zd1*zd2
      g13=xd1*xd3 + yd1*yd3 + zd1*zd3
      g23=xd2*xd3 + yd2*yd3 + zd2*zd3

c cofactors
      cf11=g22*g33 - g23*g23
      cf12=g13*g23 - g12*g33
      cf13=g12*g23 - g13*g22
      cf22=g11*g33 - g13*g13
      cf23=g12*g13 - g11*g23
      cf33=g11*g22 - g12*g12

c 2nd derivatives (without the (i,j,k) term)
      xd1d1=x(i+iskip,j,k)+x(i-iskip,j,k)                             
      yd1d1=y(i+iskip,j,k)+y(i-iskip,j,k)                             
      zd1d1=z(i+iskip,j,k)+z(i-iskip,j,k)                             

      xd2d2=x(i,j+iskip,k)+x(i,j-iskip,k)                             
      yd2d2=y(i,j+iskip,k)+y(i,j-iskip,k)                             
      zd2d2=z(i,j+iskip,k)+z(i,j-iskip,k)                             

      xd3d3=x(i,j,k+iskip)+x(i,j,k-iskip)                             
      yd3d3=y(i,j,k+iskip)+y(i,j,k-iskip)                             
      zd3d3=z(i,j,k+iskip)+z(i,j,k-iskip)                           

c mixed derivatives
      xd1d2=0.25*(x(i+iskip,j+iskip,k)-x(i+iskip,j-iskip,k)-
     $ x(i-iskip,j+iskip,k)+x(i-iskip,j-iskip,k))
      yd1d2=0.25*(y(i+iskip,j+iskip,k)-y(i+iskip,j-iskip,k)-
     $ y(i-iskip,j+iskip,k)+y(i-iskip,j-iskip,k))
      zd1d2=0.25*(z(i+iskip,j+iskip,k)-z(i+iskip,j-iskip,k)-
     $ z(i-iskip,j+iskip,k)+z(i-iskip,j-iskip,k))

      xd1d3=0.25*(x(i+iskip,j,k+iskip)-x(i+iskip,j,k-iskip)-
     $ x(i-iskip,j,k+iskip)+x(i-iskip,j,k-iskip))
      yd1d3=0.25*(y(i+iskip,j,k+iskip)-y(i+iskip,j,k-iskip)-
     $ y(i-iskip,j,k+iskip)+y(i-iskip,j,k-iskip))
      zd1d3=0.25*(z(i+iskip,j,k+iskip)-z(i+iskip,j,k-iskip)-
     $ z(i-iskip,j,k+iskip)+z(i-iskip,j,k-iskip))

      xd2d3=0.25*(x(i,j+iskip,k+iskip)-x(i,j+iskip,k-iskip)-
     $ x(i,j-iskip,k+iskip)+x(i,j-iskip,k-iskip))
      yd2d3=0.25*(y(i,j+iskip,k+iskip)-y(i,j+iskip,k-iskip)-
     $ y(i,j-iskip,k+iskip)+y(i,j-iskip,k-iskip))
      zd2d3=0.25*(z(i,j+iskip,k+iskip)-z(i,j+iskip,k-iskip)-
     $ z(i,j-iskip,k+iskip)+z(i,j-iskip,k-iskip))

      a=2.0 * (cf11 + cf22 + cf33)

      if (abs(a) < aerr) goto 9999

      w1=cf11*xd1d1 + cf22*xd2d2 + cf33*xd3d3 + 2.0*cf12*xd1d2 
     $ + 2.0*cf13*xd1d3 + 2.0*cf23*xd2d3
      w1=w1/a
      dx=w1-x(i,j,k)
      err=err+dx*dx
      s1=s1+x(i,j,k)*x(i,j,k)
      x(i,j,k)=relax*w1 + (1.0-relax)*x(i,j,k)

      w2=cf11*yd1d1 + cf22*yd2d2 + cf33*yd3d3 + 2.0*cf12*yd1d2 
     $ + 2.0*cf13*yd1d3 + 2.0*cf23*yd2d3
      w2=w2/a
      dy=w2-y(i,j,k)
      err=err+dy*dy
      s1=s1+y(i,j,k)*y(i,j,k)
      y(i,j,k)=relax*w2 + (1.0-relax)*y(i,j,k)

      w3=cf11*zd1d1 + cf22*zd2d2 + cf33*zd3d3 + 2.0*cf12*zd1d2 
     $ + 2.0*cf13*zd1d3 + 2.0*cf23*zd2d3
      w3=w3/a
      dz=w3-z(i,j,k)
      err=err+dz*dz
      s1=s1+z(i,j,k)*z(i,j,k)
      z(i,j,k)=relax*w3 + (1.0-relax)*z(i,j,k)
100   continue
101   continue
102   continue

      if (s1 < 1.0e-9) s1=1.0e-9
      err=sqrt(err/s1)

      return
9999  continue
      write(iwrite,*)'sweep3: a =',a,' <',aerr
      write(iwrite,*)' i,j,k =',i,j,k
      write(iwrite,*)' x,y,z =',x(i,j,k),
     + y(i,j,k),z(i,j,k)
      stop 'sweep3: fatal error occured'
      end
C
C***********************************************************************
C sweep3.f
C
      subroutine bswe3(x,y,z,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,
     $ xi,eta,zeta,relax,err)
c one sweep for laplace3 - treat the boundaries
      USE SKIP
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      logical doi,doj,dok
      data aerr,errb/-1.0e-30,1.0e-12/

      s1=0.0
      err=0.0

      do 102 k=kbot,ktop
      do 101 j=jbot,jtop
      do 100 i=ibot,itop

      doi=(i > ibot.and.i < itop)
      doj=(j > jbot.and.j < jtop)
      dok=(k > kbot.and.k < ktop)
      if (doi.and.doj.and.dok) goto 100
      if (.not.doi.and..not.doj.and..not.dok) goto 100
      if (.not.doi.and..not.doj.and.dok) goto 100
      if (doi.and..not.doj.and..not.dok) goto 100
      if (.not.doi.and.doj.and..not.dok) goto 100
c now 2 of them is do and one is not
c the one which is not must be on boundary:
      if (.not.doi.and.doj.and.dok.and.i > 0.and.i < l) goto 100
      if (doi.and..not.doj.and.dok.and.j > 0.and.j < m) goto 100
      if (doi.and.doj.and..not.dok.and.k > 0.and.k < n) goto 100
c exception: do not free-surface:
      if (k == n) goto 100
c don't do on boundary of a do
      if (doi.and.(i == ibot.or.i == itop)) goto 100
      if (doj.and.(j == jbot.or.j == jtop)) goto 100
      if (dok.and.(k == kbot.or.k == ktop)) goto 100

      hminu=0.0
      hplus=0.0
      akminu=0.0
      akplus=0.0
      sminu=0.0
      splus=0.0
      if (doi) then
        hminu=xi(i,j,k) - xi(i-iskip,j,k)
        hplus=xi(i+iskip,j,k) - xi(i,j,k)
      end if
      if (doj) then
        akminu=eta(i,j,k) - eta(i,j-iskip,k)
        akplus=eta(i,j+iskip,k) - eta(i,j,k)
      end if
      if (dok) then
        sminu=zeta(i,j,k) - zeta(i,j,k-iskip)
        splus=zeta(i,j,k+iskip) - zeta(i,j,k)
      end if

      if (hminu < errb) hminu=errb
      if (akminu < errb) akminu=errb
      if (sminu < errb) sminu=errb
      if (hplus < errb) hplus=errb
      if (akplus < errb) akplus=errb
      if (splus < errb) splus=errb

      h= hminu*hminu*hplus + hplus*hplus*hminu
      ak= akminu*akminu*akplus + akplus*akplus*akminu       
      s= sminu*sminu*splus + splus*splus*sminu

      if (doi) then
        xd1=d1_f(x,i,j,k,l,m,n,hminu,hplus)/h
        yd1=d1_f(y,i,j,k,l,m,n,hminu,hplus)/h
        zd1=d1_f(z,i,j,k,l,m,n,hminu,hplus)/h
      else
        xd1=0.0
        yd1=0.0
        zd1=0.0
      end if

      if (doj) then
        xd2=d2_f(x,i,j,k,l,m,n,akminu,akplus)/ak
        yd2=d2_f(y,i,j,k,l,m,n,akminu,akplus)/ak
        zd2=d2_f(z,i,j,k,l,m,n,akminu,akplus)/ak
      else
        xd2=0.0
        yd2=0.0
        zd2=0.0
      end if

      if (dok) then
        xd3=d3_f(x,i,j,k,l,m,n,sminu,splus)/s
        yd3=d3_f(y,i,j,k,l,m,n,sminu,splus)/s
        zd3=d3_f(z,i,j,k,l,m,n,sminu,splus)/s
      else
        xd3=0.0
        yd3=0.0
        zd3=0.0
      end if

c covariant components of the metric tensor
      g11=xd1*xd1 + yd1*yd1 + zd1*zd1
      g22=xd2*xd2 + yd2*yd2 + zd2*zd2
      g33=xd3*xd3 + yd3*yd3 + zd3*zd3
      g12=xd1*xd2 + yd1*yd2 + zd1*zd2
      g13=xd1*xd3 + yd1*yd3 + zd1*zd3
      g23=xd2*xd3 + yd2*yd3 + zd2*zd3
      if (.not.doi) g11=1.0
      if (.not.doj) g22=1.0
      if (.not.dok) g33=1.0

c cofactors
      cf11=g22*g33 - g23*g23
      cf12=g13*g23 - g12*g33
      cf13=g12*g23 - g13*g22
      cf22=g11*g33 - g13*g13
      cf23=g12*g13 - g11*g23
      cf33=g11*g22 - g12*g12
      
c gather a
      a=0.0

c 2nd derivatives (without the (i,j,k) term)
      if (doi) then
        xd1d1=d1d1_f(x,i,j,k,l,m,n,hminu,hplus)/h                             
        yd1d1=d1d1_f(y,i,j,k,l,m,n,hminu,hplus)/h                             
        zd1d1=d1d1_f(z,i,j,k,l,m,n,hminu,hplus)/h                             
        a=a + cf11*(hplus + hminu)/h   
      else
        xd1d1=0.0
        yd1d1=0.0
        zd1d1=0.0
      end if

      if (doj) then
        xd2d2=d2d2_f(x,i,j,k,l,m,n,akminu,akplus)/ak                             
        yd2d2=d2d2_f(y,i,j,k,l,m,n,akminu,akplus)/ak                             
        zd2d2=d2d2_f(z,i,j,k,l,m,n,akminu,akplus)/ak                             
        a=a + cf22*(akplus + akminu)/ak   
      else
        xd2d2=0.0
        yd2d2=0.0
        zd2d2=0.0
      end if

      if (dok) then
        xd3d3=d3d3_f(x,i,j,k,l,m,n,sminu,splus)/s                             
        yd3d3=d3d3_f(y,i,j,k,l,m,n,sminu,splus)/s                             
        zd3d3=d3d3_f(z,i,j,k,l,m,n,sminu,splus)/s                             
        a=a + cf33*(splus + sminu)/s   
      else
        xd3d3=0.0
        yd3d3=0.0
        zd3d3=0.0
      end if

      if (doi.and.doj) then
        xd1d2=d1d2_f(x,i,j,k,l,m,n,hminu,hplus,akminu,akplus)
     $   /h/ak
        yd1d2=d1d2_f(y,i,j,k,l,m,n,hminu,hplus,akminu,akplus)
     $   /h/ak
        zd1d2=d1d2_f(z,i,j,k,l,m,n,hminu,hplus,akminu,akplus)
     $   /h/ak
        a=a - cf12*(hplus*hplus - hminu*hminu)
     $   *(akplus*akplus - akminu*akminu)/h/ak  
      else
        xd1d2=0.0
        yd1d2=0.0
        zd1d2=0.0
      end if

      if (doi.and.dok) then
        xd1d3=d1d3_f(x,i,j,k,l,m,n,hminu,hplus,sminu,splus)
     $   /h/s
        yd1d3=d1d3_f(y,i,j,k,l,m,n,hminu,hplus,sminu,splus)
     $   /h/s
        zd1d3=d1d3_f(z,i,j,k,l,m,n,hminu,hplus,sminu,splus)
     $   /h/s
        a=a - cf13*(hplus*hplus - hminu*hminu)
     $   *(splus*splus - sminu*sminu)/h/s 
      else
        xd1d3=0.0
        yd1d3=0.0
        zd1d3=0.0
      end if

      if (dok.and.doj) then
        xd2d3=d2d3_f(x,i,j,k,l,m,n,akminu,akplus,sminu,splus)
     $   /ak/s
        yd2d3=d2d3_f(y,i,j,k,l,m,n,akminu,akplus,sminu,splus)
     $   /ak/s
        zd2d3=d2d3_f(z,i,j,k,l,m,n,akminu,akplus,sminu,splus)
     $   /ak/s
        a=a - cf23*(akplus*akplus - akminu*akminu)
     $   *(splus*splus - sminu*sminu)/ak/s  
      else
        xd2d3=0.0
        yd2d3=0.0
        zd2d3=0.0
      end if

      a = 2.0 * a
      if (abs(a) < aerr) goto 9999

      w1=cf11*xd1d1 + cf22*xd2d2 + cf33*xd3d3 + 2.0*cf12*xd1d2 
     $ + 2.0*cf13*xd1d3 + 2.0*cf23*xd2d3
      w1=w1/a
      dx=w1-x(i,j,k)
      err=err+dx*dx
      s1=s1+x(i,j,k)*x(i,j,k)
      x(i,j,k)=relax*w1 + (1.0-relax)*x(i,j,k)

      w2=cf11*yd1d1 + cf22*yd2d2 + cf33*yd3d3 + 2.0*cf12*yd1d2 
     $ + 2.0*cf13*yd1d3 + 2.0*cf23*yd2d3
      w2=w2/a
      dy=w2-y(i,j,k)
      err=err+dy*dy
      s1=s1+y(i,j,k)*y(i,j,k)
      y(i,j,k)=relax*w2 + (1.0-relax)*y(i,j,k)

      w3=cf11*zd1d1 + cf22*zd2d2 + cf33*zd3d3 + 2.0*cf12*zd1d2 
     $ + 2.0*cf13*zd1d3 + 2.0*cf23*zd2d3
      w3=w3/a
      dz=w3-z(i,j,k)
      err=err+dz*dz
      s1=s1+z(i,j,k)*z(i,j,k)
      z(i,j,k)=relax*w3 + (1.0-relax)*z(i,j,k)
100   continue
101   continue
102   continue

      if (s1 < 1.0e-9) s1=1.0e-9
      err=sqrt(err/s1)
      return
9999  continue
      write(6,*)'bswe3: a =',a,' <',aerr
      write(6,*)' i,j,k =',i,j,k
      write(6,*)' x,y,z =',x(i,j,k),
     + y(i,j,k),z(i,j,k)
      stop 'sweep3: fatal error occured'
      end
C
C***********************************************************************
C deriv3.f
C
      function d1_f(f,i,j,k,l,m,n,hminu,hplus)
c calculate the almost derivative d1 of f(i,j,k) (divide the result with h
c to get the derivative)
      USE SKIP
      real f(-2:l+1,-2:m+1,-2:n+1)
      d1_f = hminu*hminu*f(i+iskip,j,k) 
     $ + (hplus*hplus-hminu*hminu)*f(i,j,k)
     $ - hplus*hplus*f(i-iskip,j,k)
      return
      end
      
      function d2_f(f,i,j,k,l,m,n,akminu,akplus)
c calculate the almost derivative d2 of f(i,j,k) (divide the result with ak
c to get the derivative)
      USE SKIP
      real f(-2:l+1,-2:m+1,-2:n+1)
      d2_f = akminu*akminu*f(i,j+iskip,k) 
     $ + (akplus*akplus-akminu*akminu)*f(i,j,k)
     $ - akplus*akplus*f(i,j-iskip,k)
      return
      end
      
      function d3_f(f,i,j,k,l,m,n,sminu,splus)
c calculate the almost derivative d3 of f(i,j,k) (divide the result with s
c to get the derivative)
      USE SKIP
      real f(-2:l+1,-2:m+1,-2:n+1)
      d3_f = sminu*sminu*f(i,j,k+iskip) 
     $ + (splus*splus-sminu*sminu)*f(i,j,k)
     $ - splus*splus*f(i,j,k-iskip)
      return
      end

      function d1d1_f(f,i,j,k,l,m,n,hminu,hplus)
c calculate the almost derivative d1d1 of f(i,j,k) (divide the result with h
c to almost get the derivative)
      USE SKIP
      real f(-2:l+1,-2:m+1,-2:n+1)
      d1d1_f = 2.0*(hminu*f(i+iskip,j,k) + hplus*f(i-iskip,j,k))
      return
      end

      function d2d2_f(f,i,j,k,l,m,n,akminu,akplus)
c calculate the almost derivative d2d2 of f(i,j,k) (divide the result with ak
c to almost get the derivative)
      USE SKIP
      real f(-2:l+1,-2:m+1,-2:n+1)
      d2d2_f = 2.0*(akminu*f(i,j+iskip,k) + akplus*f(i,j-iskip,k))
      return
      end

      function d3d3_f(f,i,j,k,l,m,n,akminu,akplus)
c calculate the almost derivative d3d3 of f(i,j,k) (divide the result with ak
c to almost get the derivative)
      USE SKIP
      real f(-2:l+1,-2:m+1,-2:n+1)
      d3d3_f = 2.0*(akminu*f(i,j,k+iskip) + akplus*f(i,j,k-iskip))
      return
      end

      function d1d2_f(f,i,j,k,l,m,n,hminu,hplus,akminu,akplus)
c calculate the almost derivative d1d2 of f(i,j,k) (divide the result with 
c h and ak to almost get the derivative)
      USE SKIP
      real f(-2:l+1,-2:m+1,-2:n+1)
      d1d2_f = hminu*hminu * akminu*akminu * f(i+iskip,j+iskip,k)
     $ + (hplus*hplus - hminu*hminu) * akminu*akminu * f(i,j+iskip,k)
     $ - hplus*hplus * akminu*akminu * f(i-iskip,j+iskip,k)
     $ + hminu*hminu * (akplus*akplus - akminu*akminu) * f(i+iskip,j,k)
     $ - hplus*hplus * (akplus*akplus - akminu*akminu) * f(i-iskip,j,k)
     $ - hminu*hminu * akplus*akplus * f(i+iskip,j-iskip,k)
     $ - (hplus*hplus - hminu*hminu) * akplus*akplus * f(i,j-iskip,k)
     $ + hplus*hplus * akplus*akplus * f(i-iskip,j-iskip,k)

      return
      end

      function d2d3_f(f,i,j,k,l,m,n,akminu,akplus,sminu,splus)
c calculate the almost derivative d2d3 of f(i,j,k) (divide the result with 
c ak and s to almost get the derivative)
      USE SKIP
      real f(-2:l+1,-2:m+1,-2:n+1)
      d2d3_f = akminu*akminu * sminu*sminu * f(i,j+iskip,k+iskip)
     $ + (akplus*akplus - akminu*akminu) * sminu*sminu * f(i,j,k+iskip)
     $ - akplus*akplus * sminu*sminu * f(i,j-iskip,k+iskip)
     $ + akminu*akminu * (splus*splus - sminu*sminu) * f(i,j+iskip,k)
     $ - akplus*akplus * (splus*splus - sminu*sminu) * f(i,j-iskip,k)
     $ - akminu*akminu * splus*splus * f(i,j+iskip,k-iskip)
     $ - (akplus*akplus - akminu*akminu) * splus*splus * f(i,j,k-iskip)
     $ + akplus*akplus * splus*splus * f(i,j-iskip,k-iskip)

      return
      end

      function d1d3_f(f,i,j,k,l,m,n,hminu,hplus,sminu,splus)
c calculate the almost derivative d1d3 of f(i,j,k) (divide the result with 
c h and s to almost get the derivative)
      USE SKIP
      real f(-2:l+1,-2:m+1,-2:n+1)
      d1d3_f = hminu*hminu * sminu*sminu * f(i+iskip,j,k+iskip)
     $ + (hplus*hplus - hminu*hminu) * sminu*sminu * f(i,j,k+iskip)
     $ - hplus*hplus * sminu*sminu * f(i-iskip,j,k+iskip)
     $ + hminu*hminu * (splus*splus - sminu*sminu) * f(i+iskip,j,k)
     $ - hplus*hplus * (splus*splus - sminu*sminu) * f(i-iskip,j,k)
     $ - hminu*hminu * splus*splus * f(i+iskip,j,k-iskip)
     $ - (hplus*hplus - hminu*hminu) * splus*splus * f(i,j,k-iskip)
     $ + hplus*hplus * splus*splus * f(i-iskip,j,k-iskip)

      return
      end

      function coeff(c11,c22,c33,c12,c13,c23,
     $ hminu,hplus,akminu,akplus,sminu,splus,h,ak,s)
c calculate the coefficient of x(i,j)
      coeff = 2.0 * (c11*(hplus + hminu)/h 
     $ + c22*(akplus + akminu)/ak
     $ + c33*(splus + sminu)/s
     $ - c12*(hplus*hplus - hminu*hminu)
     $   *(akplus*akplus - akminu*akminu)/h/ak
     $ - c13*(hplus*hplus - hminu*hminu)
     $   *(splus*splus - sminu*sminu)/h/s
     $ - c23*(akplus*akplus - akminu*akminu)
     $   *(splus*splus - sminu*sminu)/ak/s)
      return
      end
c**********************************************************************
      subroutine dodaj(x,y,z,l,m,n,xi,eta,zeta,niter,icase,
     $ ibot,itop,jbot,jtop,kbot,ktop)
c do da j all over i.e. redo all j=const. surfaces
c icase=0 -> both
c icase=1 -> only interpolation
c icase=2 -> only Laplace
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      pointer(iptrr1,x1)
      real x1(1)
      pointer(iptrr2,x2)
      real x2(1)
      pointer(iptrr6,ordina)
      real ordina(1)
      pointer(iptr10,hlp)
      real hlp(1)


      if (icase == 2) goto 200
c ORDINA
        nbytes=4*(max(l,m,n)+1)
        iptrr6=malloc(nbytes)
c HLP
        nbytes=4*(max(m,n)+1)
        iptr10=malloc(nbytes)
c X1
        nbytes=4*(l+1)*(m+1)*(n+1)
        iptrr1=malloc(nbytes)
c X2
        nbytes=4*(l+1)*(m+1)*(n+1)
        iptrr2=malloc(nbytes)

      call T2RANSF(X,X1,X2,L,M,N,0,0,1,1,1,1,
     $ XI,ETA,ZETA,ORDINA,HLP,max(l,m,n),max(m,n),3,
     $ ibot,itop,jbot,jtop,kbot,ktop)

      call T2RANSF(Y,X1,X2,L,M,N,0,0,1,1,1,1,
     $ XI,ETA,ZETA,ORDINA,HLP,max(l,m,n),max(m,n),3,
     $ ibot,itop,jbot,jtop,kbot,ktop)

      call T2RANSF(Z,X1,X2,L,M,N,0,0,1,1,1,1,
     $ XI,ETA,ZETA,ORDINA,HLP,max(l,m,n),max(m,n),3,
     $ ibot,itop,jbot,jtop,kbot,ktop)

      call free(iptrr1)
      call free(iptrr2)
      call free(iptrr6)
      call free(iptr10)

200   continue
      if (icase == 1) goto 300

      do iter=1,niter     
        call swe3(x,y,z,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,
     $   xi,eta,zeta,1.0,1,err)
      end do
300   continue
      return
      end
c**********************************************************************
      subroutine t2ransf(x,x1,x2,l,m,n,
     $ igb,igt,jgb,jgt,kgb,kgt,xi,eta,zeta,ordina,hlp,lmn,mn,idim,
     $ ibot,itop,jbot,jtop,kbot,ktop)                          
c transfinite interpolation with lagrange polynomials                   
c x - input : contains the points through which interpolation           
c             is to be performed                                        
c   - output : contains the result of the interpolation                 
c all the other arguments are for input only                            
c idim - the dimension of the problem                                   
c  idim=1 => x1,l,igiven,xi must be specified                        
c            and contain the appropriate data (except x1)               
c  idim=2 => x1,x2,l,m,igiven,jgiven,xi,eta must be specified     
c            and contain the appropriate data (except x1,x2)            
c  idim=3 => x1,x2,l,m,n,igiven,jgiven,kgiven,xi,eta,zeta       
c            must be specified and contain the appropriate data         
c            (except x1,x2)                                             
c ordina,hlp should contain enough work space                        
c work space contents is irrelevant and changes during the process      
c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c WARNING:
c adding ibot,itop,jbot,jtop,kbot,ktop to subr. call is a generalisation
c I didn't generalise it fully - I left the unidirectional variable alone
c this means that when you interpolate in some direction this direction
c must be whole i.e. from 0 to l, m or n
c the generalisation allows, however, to shorten the domain if no interpolation
c is made in the direction, for example if igb,igt,jgb,jgt,kgb,kgt=0,0,1,1,1,1
c then there is no interpolation in i-direction thus it may be ibot>0 and itop<l
c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      real x(-2:l+1,-2:m+1,-2:n+1)
      real x1(0:l,0:m,0:n)
      real x2(0:l,0:m,0:n)
      real ordina(0:lmn)
      integer iabsci(0:1)
      real hlp(0:mn)                                               
      integer igiven(0:1),jgiven(0:1),kgiven(0:1)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)

      
      igiven(0)=igb                          
      igiven(1)=igt                          
      jgiven(0)=jgb                          
      jgiven(1)=jgt                          
      kgiven(0)=kgb                          
      kgiven(1)=kgt                          
                                                                        
      do 51 k=kbot,ktop                                                       
      do 50 j=jbot,jtop                                                       
c unidirectional interpolation over i (j,k=constant)                    
                                                                        
      ind=-1                                                            
                                                                        
      do 10 i=0,1                                                       
      if (igiven(i) /= 0) then                                          
        ind=ind+1                                                       
        iabsci(ind)=i
	ordina(i*l)=x(i*l,j,k)
      end if                                                            
10    continue                                                          
                                                      
      if (ind >= 0) then
        call l2agran(iabsci,ind,ordina,l,xi(0,j,k))                          
                                                                        
        do 20 i=0,l                                                     
20      x1(i,j,k)=ordina(i)                                             
      else                                                              
                                                                        
        do 21 i=0,l                                                     
21      x1(i,j,k)=0.0                                                   
      end if                                                            
50    continue                                                          
51    continue                                                          
                                                                        
c the input data must be available even in the end of this routine      
c so we couldn't write the output data directly to x                    
      if (idim == 1) then                                               
        do 72 k=kbot,ktop                                                     
        do 71 j=jbot,jtop                                                    
        do 70 i=0,l                                                     
        x(i,j,k)=x1(i,j,k)                                              
70      continue                                                        
71      continue                                                        
72      continue                                                        
        return                                                          
      end if                                                            
                                                                        
      do 151 k=kbot,ktop                                                     
      do 150 i=ibot,itop                                                    
c unidirectional interpolation over j (i,k=constant)                    
                                                                        
      ind=-1                                                            
                                                                        
      do 110 j=0,1                                                      
      if (jgiven(j) /= 0) then                                          
        ind=ind+1                                                       
        iabsci(ind)=j                                                   
        ordina(j*m)=x(i,j*m,k)-x1(i,j*m,k)                                    
      end if                                                            
110   continue                                                          
      if (ind >= 0) then                                                
        do 111 jhlp=0,m
        hlp(jhlp)=eta(i,jhlp,k)
111     continue
        call l2agran(iabsci,ind,ordina,m,hlp)                         
                                                                        
        do 120 j=0,m                                                    
120     x2(i,j,k)=ordina(j)                                             
      else                                                              
                                                                        
        do 121 j=0,m                                                    
121     x2(i,j,k)=0.0                                                   
      end if                                                            
150   continue                                                          
151   continue                                                          
                                                                        
      if (idim == 2) then                                               
        do 172 k=kbot,ktop                                                    
        do 171 j=0,m                                                    
        do 170 i=ibot,itop                                                    
        x(i,j,k)=x1(i,j,k)+x2(i,j,k)                                    
170     continue                                                        
171     continue                                                        
172     continue                                                        
        return                                                          
      end if                                                            
                                                                        
      do 251 j=jbot,jtop                                                      
      do 250 i=ibot,itop                                                      
c unidirectional interpolation over k (i,j=constant)                    
                                                                        
      ind=-1                                                            
                                                                        
      do 210 k=0,1                                                      
      if (kgiven(k) /= 0) then                                          
        ind=ind+1                                                       
        iabsci(ind)=k                                                   
        ordina(k*n)=x(i,j,k*n)-x1(i,j,k*n)-x2(i,j,k*n)                          
      end if                                                            
210   continue                                                          
      if (ind >= 0) then                                                
        do 211 khlp=0,n
        hlp(khlp)=zeta(i,j,khlp)
211     continue
        call l2agran(iabsci,ind,ordina,n,hlp)                         
                                                                        
        do 220 k=0,n                                                    
220     x(i,j,k)=ordina(k)                                              
      else                                                              
                                                                        
        do 221 k=0,n                                                    
221     x(i,j,k)=0.0                                                    
      end if                                                            
250   continue                                                          
251   continue                                                          
                                                                        
      do 272 k=0,n                                                      
      do 271 j=jbot,jtop                                                      
      do 270 i=ibot,itop                                                      
      x(i,j,k)=x(i,j,k)+x1(i,j,k)+x2(i,j,k)                             
270   continue                                                          
271   continue                                                          
272   continue                                                          
                                                                        
      return                                                            
      end                                                               
c**********************************************************************
      subroutine l2agran(iarg,niarg,x,nx,stretc)                         
c returns values of a lagrange polynomial of degree niarg-1             
c in the table x                                                        
c niarg values of x and iarg come as input                              
c that is x(iarg(i)), i=1..niarg are predefined                         
c nx is the dimension of the table x                                    
c stretc is a table with which some distortion is forced on the polyn.  
                                                                        
      integer iarg(0:niarg)                                             
      real x(-2:nx+1),stretc(0:nx)                                         
                                                                        
      do 100 iarg1=0,nx                                                 
c iarg1 is the abscissa where the value of the lagrange polynomial is t 
c be calculated                                                         
c don't calculate given points :                                        
      do 5 i1=0,niarg                                                   
5     if (iarg(i1) == iarg1) goto 99                                    
                                                                        
      sum=0.0                                                           
                                                                        
      do 50 i=0,niarg                                                   
      prod=x(iarg(i))                                                   
                                                                        
      do 10 j=0,niarg                                                   
      if (i /= j .and. iarg(i) == iarg(j)) goto 9999                    
      if (i /= j) prod=prod*(stretc(iarg1)-stretc(iarg(j)))/            
     +(stretc(iarg(i))-stretc(iarg(j)))                                 
10    continue                                                          
      sum=sum+prod                                                      
50    continue                                                          
      x(iarg1)=sum                                                      
99    continue                                                          
100   continue                                                          
                                                                        
      return                                                            
9999  continue                                                          
      write(6,*)'error in lagran (i,iarg(i)) =',i,iarg(i)          
      write(6,*)'                (j,iarg(j)) =',j,iarg(j)          
      stop 'fatal error occured'                                        
      end                                                               
C
C***********************************************************************
C sweep3.f
C
      subroutine swe3(x,y,z,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,
     $ xi,eta,zeta,relax,idir,err)
c one sweep for laplace3 as 2D - treat the grid as surfaces
c idir=1 -> i=const.
c idir=2 -> j=const.
c idir=3 -> k=const.
      USE SKIP
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      logical doi,doj,dok
      data aerr,errb/-1.0e-30,1.0e-12/

      s1=0.0
      err=0.0

      do 102 k=kbot,ktop
      do 101 j=jbot,jtop
      do 100 i=ibot,itop

      doi=(i > ibot.and.i < itop)
      doj=(j > jbot.and.j < jtop)
      dok=(k > kbot.and.k < ktop)
      if (idir == 1) doi=.false.
      if (idir == 2) doj=.false.
      if (idir == 3) dok=.false.
      if (.not.doi.and..not.doj.and..not.dok) goto 100
      if (.not.doi.and..not.doj.and.dok) goto 100
      if (doi.and..not.doj.and..not.dok) goto 100
      if (.not.doi.and.doj.and..not.dok) goto 100
c now 2 of them is do and one is not

c exception: do not free-surface:
      if (k == n) goto 100
c don't do on boundary of a do
      if (doi.and.(i == ibot.or.i == itop)) goto 100
      if (doj.and.(j == jbot.or.j == jtop)) goto 100
      if (dok.and.(k == kbot.or.k == ktop)) goto 100
      
      hminu=0.0
      hplus=0.0
      akminu=0.0
      akplus=0.0
      sminu=0.0
      splus=0.0
      if (doi) then
        hminu=xi(i,j,k) - xi(i-iskip,j,k)
        hplus=xi(i+iskip,j,k) - xi(i,j,k)
      end if
      if (doj) then
        akminu=eta(i,j,k) - eta(i,j-iskip,k)
        akplus=eta(i,j+iskip,k) - eta(i,j,k)
      end if
      if (dok) then
        sminu=zeta(i,j,k) - zeta(i,j,k-iskip)
        splus=zeta(i,j,k+iskip) - zeta(i,j,k)
      end if

      if (hminu < errb) hminu=errb
      if (akminu < errb) akminu=errb
      if (sminu < errb) sminu=errb
      if (hplus < errb) hplus=errb
      if (akplus < errb) akplus=errb
      if (splus < errb) splus=errb

      h= hminu*hminu*hplus + hplus*hplus*hminu
      ak= akminu*akminu*akplus + akplus*akplus*akminu       
      s= sminu*sminu*splus + splus*splus*sminu

      if (doi) then
        xd1=d1_f(x,i,j,k,l,m,n,hminu,hplus)/h
        yd1=d1_f(y,i,j,k,l,m,n,hminu,hplus)/h
        zd1=d1_f(z,i,j,k,l,m,n,hminu,hplus)/h
      else
        xd1=0.0
        yd1=0.0
        zd1=0.0
      end if

      if (doj) then
        xd2=d2_f(x,i,j,k,l,m,n,akminu,akplus)/ak
        yd2=d2_f(y,i,j,k,l,m,n,akminu,akplus)/ak
        zd2=d2_f(z,i,j,k,l,m,n,akminu,akplus)/ak
      else
        xd2=0.0
        yd2=0.0
        zd2=0.0
      end if

      if (dok) then
        xd3=d3_f(x,i,j,k,l,m,n,sminu,splus)/s
        yd3=d3_f(y,i,j,k,l,m,n,sminu,splus)/s
        zd3=d3_f(z,i,j,k,l,m,n,sminu,splus)/s
      else
        xd3=0.0
        yd3=0.0
        zd3=0.0
      end if

c covariant components of the metric tensor
      g11=xd1*xd1 + yd1*yd1 + zd1*zd1
      g22=xd2*xd2 + yd2*yd2 + zd2*zd2
      g33=xd3*xd3 + yd3*yd3 + zd3*zd3
      g12=xd1*xd2 + yd1*yd2 + zd1*zd2
      g13=xd1*xd3 + yd1*yd3 + zd1*zd3
      g23=xd2*xd3 + yd2*yd3 + zd2*zd3
      if (.not.doi) g11=1.0
      if (.not.doj) g22=1.0
      if (.not.dok) g33=1.0

c cofactors
      cf11=g22*g33 - g23*g23
      cf12=g13*g23 - g12*g33
      cf13=g12*g23 - g13*g22
      cf22=g11*g33 - g13*g13
      cf23=g12*g13 - g11*g23
      cf33=g11*g22 - g12*g12
      
c gather a
      a=0.0

c 2nd derivatives (without the (i,j,k) term)
      if (doi) then
        xd1d1=d1d1_f(x,i,j,k,l,m,n,hminu,hplus)/h                             
        yd1d1=d1d1_f(y,i,j,k,l,m,n,hminu,hplus)/h                             
        zd1d1=d1d1_f(z,i,j,k,l,m,n,hminu,hplus)/h                             
        a=a + cf11*(hplus + hminu)/h   
      else
        xd1d1=0.0
        yd1d1=0.0
        zd1d1=0.0
      end if

      if (doj) then
        xd2d2=d2d2_f(x,i,j,k,l,m,n,akminu,akplus)/ak                             
        yd2d2=d2d2_f(y,i,j,k,l,m,n,akminu,akplus)/ak                             
        zd2d2=d2d2_f(z,i,j,k,l,m,n,akminu,akplus)/ak                             
        a=a + cf22*(akplus + akminu)/ak   
      else
        xd2d2=0.0
        yd2d2=0.0
        zd2d2=0.0
      end if

      if (dok) then
        xd3d3=d3d3_f(x,i,j,k,l,m,n,sminu,splus)/s                             
        yd3d3=d3d3_f(y,i,j,k,l,m,n,sminu,splus)/s                             
        zd3d3=d3d3_f(z,i,j,k,l,m,n,sminu,splus)/s                             
        a=a + cf33*(splus + sminu)/s   
      else
        xd3d3=0.0
        yd3d3=0.0
        zd3d3=0.0
      end if

      if (doi.and.doj) then
        xd1d2=d1d2_f(x,i,j,k,l,m,n,hminu,hplus,akminu,akplus)
     $   /h/ak
        yd1d2=d1d2_f(y,i,j,k,l,m,n,hminu,hplus,akminu,akplus)
     $   /h/ak
        zd1d2=d1d2_f(z,i,j,k,l,m,n,hminu,hplus,akminu,akplus)
     $   /h/ak
        a=a - cf12*(hplus*hplus - hminu*hminu)
     $   *(akplus*akplus - akminu*akminu)/h/ak  
      else
        xd1d2=0.0
        yd1d2=0.0
        zd1d2=0.0
      end if

      if (doi.and.dok) then
        xd1d3=d1d3_f(x,i,j,k,l,m,n,hminu,hplus,sminu,splus)
     $   /h/s
        yd1d3=d1d3_f(y,i,j,k,l,m,n,hminu,hplus,sminu,splus)
     $   /h/s
        zd1d3=d1d3_f(z,i,j,k,l,m,n,hminu,hplus,sminu,splus)
     $   /h/s
        a=a - cf13*(hplus*hplus - hminu*hminu)
     $   *(splus*splus - sminu*sminu)/h/s 
      else
        xd1d3=0.0
        yd1d3=0.0
        zd1d3=0.0
      end if

      if (dok.and.doj) then
        xd2d3=d2d3_f(x,i,j,k,l,m,n,akminu,akplus,sminu,splus)
     $   /ak/s
        yd2d3=d2d3_f(y,i,j,k,l,m,n,akminu,akplus,sminu,splus)
     $   /ak/s
        zd2d3=d2d3_f(z,i,j,k,l,m,n,akminu,akplus,sminu,splus)
     $   /ak/s
        a=a - cf23*(akplus*akplus - akminu*akminu)
     $   *(splus*splus - sminu*sminu)/ak/s  
      else
        xd2d3=0.0
        yd2d3=0.0
        zd2d3=0.0
      end if

      a = 2.0 * a
      if (abs(a) < aerr) goto 9999

      w1=cf11*xd1d1 + cf22*xd2d2 + cf33*xd3d3 + 2.0*cf12*xd1d2 
     $ + 2.0*cf13*xd1d3 + 2.0*cf23*xd2d3
      w1=w1/a
      dx=w1-x(i,j,k)
      err=err+dx*dx
      s1=s1+x(i,j,k)*x(i,j,k)
      x(i,j,k)=relax*w1 + (1.0-relax)*x(i,j,k)

      w2=cf11*yd1d1 + cf22*yd2d2 + cf33*yd3d3 + 2.0*cf12*yd1d2 
     $ + 2.0*cf13*yd1d3 + 2.0*cf23*yd2d3
      w2=w2/a
      dy=w2-y(i,j,k)
      err=err+dy*dy
      s1=s1+y(i,j,k)*y(i,j,k)
      y(i,j,k)=relax*w2 + (1.0-relax)*y(i,j,k)

      w3=cf11*zd1d1 + cf22*zd2d2 + cf33*zd3d3 + 2.0*cf12*zd1d2 
     $ + 2.0*cf13*zd1d3 + 2.0*cf23*zd2d3
      w3=w3/a
      dz=w3-z(i,j,k)
      err=err+dz*dz
      s1=s1+z(i,j,k)*z(i,j,k)
      z(i,j,k)=relax*w3 + (1.0-relax)*z(i,j,k)
100   continue
101   continue
102   continue

      if (s1 < 1.0e-9) s1=1.0e-9
      err=sqrt(err/s1)
      return
9999  continue
      write(6,*)'swe3: a =',a,' <',aerr
      write(6,*)' i,j,k =',i,j,k
      write(6,*)' x,y,z =',x(i,j,k),
     + y(i,j,k),z(i,j,k)
      stop 'sweep3: fatal error occured'
      end
C
C***********************************************************************
C Manip.f
C
      subroutine manipk(x,y,z,wh,l,m,n,xi,eta,zeta,icode,
     $ xhull,yhull,zhull,lhull,mhull,nhull,
     $ ibot,itop,jbot,jtop,kbot,ktop,XMOM,YMOM,ZMOM,CX,CY,CZ,CM,
     $ FRSVEL,GZ,AKG,zztop)

      USE STRIM
      USE TRSINK
      USE TZANSC
      USE XYZK
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
c      real zztop(-2:l+1,-2:m+1,-2:n+1)
      real zztop(0:l,0:m,0:n)
      real wh(-1:l,-1:m)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)
      logical doj
C***********************************************************************
      data err/1.0e-6/
      anomin(a)=sign(amax1(abs(a),1.0e-6),a)

c icode = 6 -> freesurface = ktop

      if (icode == 6) then
call smowh(wh,l,m,3*l/4,l,0,m/4) ! Combatant aft

c take the transom back
        if (ktrnsm /= 0 .and. .not.virgin)
     $   call tsom(x,y,z,l,m,n,xi,eta,zeta,xhull,yhull,zhull,
     $   lhull,mhull,nhull,ibot,ibtrns,ittrns,ktrnsm,ktrd,-1)

c update the grid according to sink'n'trim
        if (isinkt /= 0) call sinktr(x,y,z,l,m,n,xi,eta,zeta,icode,
     $   xhull,yhull,zhull,lhull,mhull,nhull,
     $   ibot,itop,jbot,jtop,kbot,ktop)
c relative version:
c        if (isinkt /= 0) call rsinkt(x,y,z,l,m,n,xi,eta,zeta,icode,
c     $   xhull,yhull,zhull,lhull,mhull,nhull,
c     $   ibot,itop,jbot,jtop,kbot,ktop)
         if (isinkt < 0) then
           osink=sink
           otrim=trimm
         end if

        limit=0

        do i=0,l
        doj=.true.
        perc=1.0
        do j=0,m
c        if (.not.doj) goto 9000  
        i1=i
        j1=j
        i2=i-1
        j2=j
        i3=i
        j3=j-1
        i4=i-1
        j4=j-1
c restrictions no longer needed since ghost cells contain something
c        i1=max(min(i1,l-1),0)
c        j1=max(min(j1,m-1),0)
c        i2=max(min(i2,l-1),0)
c        j2=max(min(j2,m-1),0)
c        i3=max(min(i3,l-1),0)
c        j3=max(min(j3,m-1),0)
c        i4=max(min(i4,l-1),0)
c        j4=max(min(j4,m-1),0)

        z0=2.665e-2
        z0=0.0
        diff=0.25*(wh(i1,j1)+wh(i2,j2)+wh(i3,j3)+wh(i4,j4))+z0-z(i,j,n)

c water on deck percentage carry on j
        if (j > 0) diff=perc*diff

c limitter patches
call limz(i,j,z(i,j,n),diff,limit,jlimf,xi,eta,l,m,n,igo)
        call limzxy(i,j,z(i,j,n),diff,limit,jlimf,xi,eta,l,m,n,igo,x,y)
	if (igo == 1) goto 9000

        ifirst=1
        
c rloczi relies on going downwards
        do k=n,kbot,-1
        
c scale to local cell height
c history: 
c once the grid was concentrated close to bulb but not close to water surface
c i.e. the cells got smaller going downwards, which led to trouble
        if (diff < 0.0) then
          cf=(zeta(i,j,k)-zeta(i,j,max(k-1,kbot)))/
     $     (zeta(i,j,n)-zeta(i,j,n-1))
        else if (k == n) then
          cf=1.0
        else
          cf=(zeta(i,j,k+1)-zeta(i,j,k))/
     $     (zeta(i,j,n)-zeta(i,j,n-1))
        end if
c for Heaven's sake do not amplify
        cf=amin1(cf,1.0)

        xd=0.0
        yd=0.0
        zd=diff*echok(x,y,z,l,m,n,xi,eta,zeta,i,j,k,kbot,ktop)*cf
c        zd=diff*echok(x,y,z,l,m,n,xi,eta,zeta,i,j,k,kbot,kfirst)*cf

        if (i >= ibot.and.i <= itop.and.j >= jbot.and.j <= jtop.and.
     $   k >= kbot.and.k <= ktop) then
c the point to be moved (i,j,k) is on the hull
          if (ibot == itop.and.kbot == ktop) then
c Schweighofer case (just one point moves - use function)
            zd=diff
            yd=0.0
            xd=z_to_x(z(i,j,k)+zd)-x(i,j,k)
            goto 165
          end if
        
c sort of assume that n=ktop
          ihull1=i-ibot
          jhull1=j-jbot

c just calculate the differences xd,yd,zd - 
c xfield will handle the actual deformation and carry it across the field as well       

c          if (y(i,j,k) < 0.0) print *,'negative y',y(i,j,k)
c diff is the vertical displacement on the water surface
c calculate the vertical displacement difk at some k=k below in the water
            difk=diff*echok(x,y,z,l,m,n,xi,eta,zeta,i,j,k,kbot,ktop)
           call rloczi(ihull1,jhull1,xhull,yhull,zhull,lhull,
     $     mhull,nhull,x(i,j,k),y(i,j,k),z(i,j,k),xd,yd,zd,difk,k,n,doj,
     $     ifirst,ierr)
            if (ierr /= 0) then
              call wgridi(x,y,z,l,m,n,'gridi.3d')
	      stop
	    end if 
            ifirst=0
            if (.not.doj) write(6,*)doj,i,j,k
c            if (.not.doj) goto 9000
            if (.not.doj) perc=zd/anomin(diff)
            if (k == n) diff=difk

c          z(i,j,k)=z(i,j,k)+zd
c          zd=0.0
c basically the idea is to carry only lateral components across the field
c in practice this is bad presumably since on the hull the points are 
c distributed along the curve and elsewhere vertically, so near the bottom
c some hooks seem to appear
c and after all there is no problem even if we carry vertical components 
c too, since it will be compensated when we handle j vertically
c recall that diff = wh - zold, so z goes to wh anyway
165       call xfield(x,y,z,l,m,n,xi,eta,zeta,i,j,k,
     $     ibot,itop,jbot,jtop,kbot,ktop,xd,yd,zd,'j')
          zd=0.0

          if (i == ibot) then
c carry the lateral components to upstream
            if (abs(yd) > err.and.j == 0) then
c if you generalize this code then remove us
              write(6,*)'WARNING: yd not zero at bow at k =',k
              write(6,*)
     $ 'Stem contour does not lie strictly on the symmetry plane ???'
              yd=0.0
            end if
            call upstre(x,y,z,l,m,n,xi,eta,zeta,0,ibot,j,k,xd,yd,zd,
     $       jtop)
          end if
          if (i == itop) then
c carry the lateral components to downstream ...
            if (abs(yd) > err.and.j == 0) then
c if you generalize this code then remove us
              write(6,*)'WARNING: yd not zero at stern at k =',k
              write(6,*)
     $ 'Stern contour does not lie strictly on the symmetry plane ???'
              yd=0.0
            end if
c ... but not in the Schweighofer case
            if (.not.(ibot == itop.and.kbot == ktop))
     $       call dostre(x,y,z,l,m,n,xi,eta,zeta,l,itop,j,k,xd,yd,zd,
     $        jtop)
          end if

        else
c the point to be moved (i,j,k) is not on the hull
          x(i,j,k)=x(i,j,k) + xd
          y(i,j,k)=y(i,j,k) + yd
          z(i,j,k)=z(i,j,k) + zd
        end if

        end do ! k

9000    continue  
        end do ! j
        end do ! i

c transom
        if (ktrnsm /= 0)
     $   call tsom(x,y,z,l,m,n,xi,eta,zeta,xhull,yhull,zhull,
     $   lhull,mhull,nhull,ibot,ibtrns,ittrns,ktrnsm,ktrd,1)
        virgin=.false.

        return
      end if

      return
      end
C
C***********************************************************************
      subroutine xfield(x,y,z,l,m,n,xi,eta,zeta,i,j,k,
     $ ibot,itop,jbot,jtop,kbot,ktop,xd,yd,zd,dir)
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      character dir

      x(i,j,k)=x(i,j,k)+xd
      y(i,j,k)=y(i,j,k)+yd
      z(i,j,k)=z(i,j,k)+zd

c assume that only 1 of the following is true: ibot=itop, jbot=jtop, kbot=ktop
          if (dir == 'i') then
            if (l /= itop.and.i == itop) then
              do i1=itop+1,l
              alpha=real(l-i1)/real(l-itop)
              x(i1,j,k)=x(i1,j,k)+alpha*xd
              y(i1,j,k)=y(i1,j,k)+alpha*yd
              z(i1,j,k)=z(i1,j,k)+alpha*zd
              end do
            end if
            if (0 /= ibot.and.i == ibot) then
              do i1=0,ibot-1
              alpha=real(i1)/real(ibot)
              x(i1,j,k)=x(i1,j,k)+alpha*xd
              y(i1,j,k)=y(i1,j,k)+alpha*yd
              z(i1,j,k)=z(i1,j,k)+alpha*zd
              end do
            end if
          else if (dir == 'j') then
            if (m /= jtop.and.j == jtop) then
              safe=0.5
              do j1=jtop+1,m
              alpha=amin1(1.0,(1.0- 
     $         sposij(xi,eta,zeta,l,m,n,i,j1,k,jtop,m))/safe)
              x(i,j1,k)=x(i,j1,k)+alpha*xd
              y(i,j1,k)=y(i,j1,k)+alpha*yd
              z(i,j1,k)=z(i,j1,k)+alpha*zd
              end do
            end if
            if (0 /= jbot.and.j == jbot) then
              do j1=0,jbot-1
              alpha=real(j1)/real(jbot)
              x(i,j1,k)=x(i,j1,k)+alpha*xd
              y(i,j1,k)=y(i,j1,k)+alpha*yd
              z(i,j1,k)=z(i,j1,k)+alpha*zd
              end do
            end if
          else if (dir == 'k') then
            if (n /= ktop.and.k == ktop) then
              do k1=ktop+1,n
              alpha=real(n-k1)/real(n-ktop)
              x(i,j,k1)=x(i,j,k1)+alpha*xd
              y(i,j,k1)=y(i,j,k1)+alpha*yd
              z(i,j,k1)=z(i,j,k1)+alpha*zd
              end do
            end if
            if (0 /= kbot.and.k == kbot) then
              do k1=0,kbot-1
              alpha=real(k1)/real(kbot)
              x(i,j,k1)=x(i,j,k1)+alpha*xd
              y(i,j,k1)=y(i,j,k1)+alpha*yd
              z(i,j,k1)=z(i,j,k1)+alpha*zd
              end do
            end if
          end if

      return
      end
c
c***********************************************************************
      subroutine upstre(x,y,z,l,m,n,xi,eta,zeta,ibot,i,j,k,xd,yd,zd,
     $ jtop)
c carry to upstream
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)

c some dummy values
      itop=i
      kbot=0
      ktop=n
      
c carry to upstream
      do i1=ibot,i-1
      al=amin1(1.0,2.0*sposii(xi,eta,zeta,l,m,n,i1,j,k,ibot,i))
      xd1=al*xd
      yd1=al*yd
      zd1=al*zd
      if (j < jtop) then
        x(i1,j,k) = x(i1,j,k) + al*xd
        y(i1,j,k) = y(i1,j,k) + al*yd
        z(i1,j,k) = z(i1,j,k) + al*zd
      else
        call xfield(x,y,z,l,m,n,xi,eta,zeta,i1,j,k,
     $   ibot,itop,j,j,kbot,ktop,xd1,yd1,zd1,'j')
      end if
      end do

      return
      end
c
c***********************************************************************
      subroutine dostre(x,y,z,l,m,n,xi,eta,zeta,itop,i,j,k,xd,yd,zd,
     $ jtop)
c carry to downstream
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)

c some dummy values
      ibot=i
      kbot=0
      ktop=n
      
      do i1=i+1,itop
      al=1.0-amin1(1.0,2.0*sposii(xi,eta,zeta,l,m,n,i1,j,k,
     $ i,l))
      xd1=al*xd
      yd1=al*yd
      zd1=al*zd
      if (j < jtop) then
        x(i1,j,k) = x(i1,j,k) + al*xd
        y(i1,j,k) = y(i1,j,k) + al*yd
        z(i1,j,k) = z(i1,j,k) + al*zd
      else
        call xfield(x,y,z,l,m,n,xi,eta,zeta,i1,j,k,
     $   ibot,itop,j,j,kbot,ktop,xd1,yd1,zd1,'j')
      end if
      end do

      return
      end

      function z_to_x(z)
c cos(21.4 deg)
      cos21=0.93105582
      r=1450.0
      xc=-1000.0
      zc=r*cos21
      alfa=acos((zc-z)/r)
      z_to_x=xc-r*sin(alfa)
      return
      end
      
C
C***********************************************************************
C inihul.f
C
      subroutine inihul(xhull,yhull,zhull,lhull,mhull,nhull,
     $ x,y,z,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,xi,eta,zeta,zztop,
     $ iglobl,nglobl,LVLSTP,IOLD,ICYCLE,ICMAX,AKG,CZ,CM,prn)
c initialize deformable grid stuff
c in multiblock case you have to get IG(MGM,NB+1) and MGM

      USE STRIM
      USE TZANSC
      USE XYZK
      USE GLIM
      USE TRSINK
      USE ACHTNG
      USE VANHA
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
c      real zztop(-2:l+1,-2:m+1,-2:n+1)
      real zztop(0:l,0:m,0:n)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      logical zz,strez
      character*80 line
      character*3 prn

      write(6,*) 'griddeform version 8.12.2006 Hatchback'
      if (itop-ibot /= lhull) then
        write(6,*)'ibot,itop =',ibot,itop
        write(6,*)'lhull =',lhull
        stop 'i-dimensions dont match, man !'
      end if

      jold=IOLD
      iacht=0
      
cc modify the hull so that the given hull doesn't need to match the grid exactly
cc assume j=jbot is the hull
c      do ih=0,lhull
c      do jh=0,mhull
cc keep z invariant and y too (for a flat keel)
c      i=ibot + ih
c      j=jbot
c      if (zhull(ih,jh) <= z(i,j,k)) then
c        dist=9.0e+10
c        zz=.false.
c        do k=0,n
c        dist1=(xhull(ih,jh)-x(i,j,k))*(xhull(ih,jh)-x(i,j,k)) +
c     $   (yhull(ih,jh)-y(i,j,k))*(yhull(ih,jh)-y(i,j,k)) +
c     $   (zhull(ih,jh)-z(i,j,k))*(zhull(ih,jh)-z(i,j,k))
c        if (dist1 < dist) then
c          dist=dist1
c          kk=k
c        end if
c        end do
c        if (kk > 0) then
c          dotprd=(x(i,j,kk-1)-x(i,j,kk))*(xhull(ih,jh)-x(i,j,kk)) +
c     $     (y(i,j,kk-1)-y(i,j,kk))*(yhull(ih,jh)-y(i,j,kk)) +
c     $     (z(i,j,kk-1)-z(i,j,kk))*(zhull(ih,jh)-z(i,j,kk))
c          if (dotprd > 0.0 .or. kk == n) kk=kk-1
c        end if
cc interpolate
c        if (abs(z(i,j,kk+1)-z(i,j,kk)) >= abs(y(i,j,kk+1)-y(i,j,kk))) 
c     $   zz=.true.
c        if (zz) then
c          anomin=z(i,j,kk+1)-z(i,j,kk)
c          al=0.0
c          if (abs(anomin) > 1.0e-5) al=(zhull(ih,jh)-z(i,j,kk))/anomin
c          xhnew= (1.0-al)*x(i,j,kk) + al*x(i,j,kk+1)
c          yhnew= (1.0-al)*y(i,j,kk) + al*y(i,j,kk+1)
c          zhnew= (1.0-al)*z(i,j,kk) + al*z(i,j,kk+1)
c          dx=xhnew-xhull(ih,jh)
c          dy=yhnew-yhull(ih,jh)
c          dz=zhnew-zhull(ih,jh)
c          xhull(ih,jh)= xhnew
c          yhull(ih,jh)= yhnew
c        else
c          anomin=y(i,j,kk+1)-y(i,j,kk)
c          al=0.0
c          if (abs(anomin) > 1.0e-5) al=(yhull(ih,jh)-y(i,j,kk))/anomin
c          xhnew= (1.0-al)*x(i,j,kk) + al*x(i,j,kk+1)
c          yhnew= (1.0-al)*y(i,j,kk) + al*y(i,j,kk+1)
c          zhnew= (1.0-al)*z(i,j,kk) + al*z(i,j,kk+1)
c          dx=xhnew-xhull(ih,jh)
c          dy=yhnew-yhull(ih,jh)
c          dz=zhnew-zhull(ih,jh)
c          xhull(ih,jh)= xhnew
c          zhull(ih,jh)= zhnew
c        end if
c      else
cc above the still water surface
c        xhull(ih,jh)= xhull(ih,jh) + dx
c        yhull(ih,jh)= yhull(ih,jh) + dy
c        zhull(ih,jh)= zhull(ih,jh) + dz
c      end if
c      end do
c      end do
c
c      open(191,file='inihul.3d',form='unformatted')
c      write(191)1
c      write(191)lhull+1,mhull+1,1
c      write(191)xhull,yhull,zhull
c      close(191)

c Local or global grid resolving when inverted cells occur
c originally iglobl was to mean global or local grid resolving when in trouble
c now iglobl is the number of cells that are taken into account around
c the bad area when trying to resolve
c exception: iglobl = 0 => global grid resolving
      ktop=min(ktop,n)
      rewind 199
      read(199,*,iostat=ierr)
      read(199,'(a)',iostat=ierr)line
      read(line,*,iostat=ierr)iglobl,nglobl
      if (ierr /= 0) then
        nglobl=50
        read(line,*,iostat=ierr)iglobl
        if (ierr /= 0) then
          write(6,*)'ERROR: File fort.199 too short, man !'
          iglobl=0
        end if
      end if
      iglobl=iglobl/LVLSTP
      if (iglobl < 0) then
        write(6,*)'WARNING: Who needs this ! I know I don''t !'
        write(6,*)'You''re trying to give me a negative iglobl =',iglobl
        write(6,*)'I''m a setting it to zero, man !'
        write(6,*)'LVLSTP =',LVLSTP
        iglobl=0
      end if

c The grid movement on the hull was first implemented in a certain way
c later on an alternative approach was implemented which uses
c stretching functions
c ibasic=1 => a certain way
c ibasic=2 => stretching functions way
      read(199,*,iostat=ierr)ibasic
      if (ierr /= 0) then
        write(6,*)'ERROR: File fort.199 too short, man !'
        ibasic=1
      end if
      if (ibasic == 1) then
        write(6,*)' Grid moves in a certain way on the hull !'
        if (IOLD < 0) then
          do k=0,n
          do j=0,m
          do i=0,l
          i1=i
          j1=j
          k1=k
          zztop(i1,j1,k1)=hlenk0(x,y,z,l,m,n,
     $     i1,j1,x(i,j,k),y(i,j,k),z(i,j,k),0,n,-2,1)
          end do
          end do
          end do
c normalize
          do j=0,m
          do i=0,l
          i1=i
          j1=j
	  anom=zztop(i1,j1,ktop-kbot)-zztop(i1,j1,0)
          do k=n,0,-1
          k1=k
          zztop(i1,j1,k1)=(zztop(i1,j1,k1)-zztop(i1,j1,0))/anom
          end do
          end do
          end do
	end if
      else
        write(6,*)
     $ ' Grid moves according to the stretching functions on the hull !'
        write(6,*)
     $ ' Correction (we have a last minute change): ',
     $ 'according to zztop on the hull !'

c totally skip reading the zz.top and always generate it
c this is because with multiprocessors
c it may be that the processors read the data in random order
c so we would have to bring the block number in:
       goto 200

       if (IOLD == 0.or.IOLD == -1) goto 200     
       open(171,file='zz.top'//prn,status='OLD',err=200)
c by experiment with ifort-compiler you can open a file several times
c and the file is not rewinded unless closed in between
c (and no error is produced)
c i.e. this will work even with multi-block
       do k=0,n
       do j=0,m
       do i=0,l
       read(171,*,err=200)zztop(i,j,k)
       end do
       end do
       end do
close(171)
       write(6,*)'zz.top read !'
       goto 201
200     continue
        if (ibasic == 2) then
          write(6,*)' The hull is assumed to be monotonic in z',
     $     ' when k is between ',kbot,' and ',ktop
          do k=kbot,ktop
          do j=jbot,jtop
          do i=ibot,itop
          i1=i-ibot
          j1=j-jbot
          k1=k-kbot
          zztop(i1,j1,k1)=hlenk(xhull,yhull,zhull,lhull,mhull,nhull,
     $     i1,j1,z(i,j,k),0,nhull)
          end do
          end do
          end do
        else
          write(6,*)' Point to point correspondence of the hull',
     $    ' and the grid assumed in k.'
          do k=kbot,ktop
          do j=jbot,jtop
          do i=ibot,itop
          i1=i-ibot
          j1=j-jbot
          k1=k-kbot
c          zztop(i1,j1,k1)=hlenkk(xhull,yhull,zhull,lhull,mhull,nhull,
c     $     i1,j1,k,0,nhull)
          zztop(i1,j1,k1)=hlenk0(xhull,yhull,zhull,lhull,mhull,nhull,
     $     i1,j1,x(i,j,k),y(i,j,k),z(i,j,k),0,nhull,0,0)
          end do
          end do
          end do
        end if
c normalize
        do j=jbot,jtop
        do i=ibot,itop
        i1=i-ibot
        j1=j-jbot
	anom=zztop(i1,j1,ktop-kbot)-zztop(i1,j1,0)
        do k=ktop,kbot,-1
        k1=k-kbot
c        zztop(i1,j1,k1)=zztop(i1,j1,k1)/zztop(i1,j1,ktop-kbot)
        zztop(i1,j1,k1)=(zztop(i1,j1,k1)-zztop(i1,j1,0))/anom
        end do
        end do
        end do
        
        open(172,file='zz.top'//prn)
c by experiment with ifort-compiler you can open a file several times
c and the file is not rewinded unless closed in between
c (and no error is produced)
c i.e. this will work even with multi-block
        do k=0,n
        do j=0,m
        do i=0,l
        write(172,*)zztop(i,j,k)
        end do
        end do
        end do
close(172)
      end if

201   continue
c Sink and trim input-data
      read(199,*,iostat=ierr)isinkt,relax0,icfull
      if (ierr /= 0) isinkt=0
      if (isinkt > 0) isinkt=4 ! only developed Matusiak is supported
      if (isinkt == 1) then
        write(6,*)'Yes sink and trim by Saisto, musjoo !'
      else if (isinkt == 2) then
        write(6,*)'Yes sink and trim by Matusiak, musjoo !'
      else if (isinkt == 3) then
        write(6,*)'Yes sink and trim by developed Matusiak, musjoo !'
      else if (isinkt == 4) then
        write(6,*)'Yes sink and trim by ddeveloped Matusiak, musjoo !'
      else if (isinkt == -1) then
        backspace 199
        read(199,*,iostat=ierr)idummy,sink,trimm
        write(6,*)'Yes targeted sink and trim, musjoo !'
c BTW: it is stupid to always calculate sink and trim when they are constant
c but it is the easiest to program and we may need to add damping in the
c future or remove this whole target thing ... so let it be for now !
      else if (isinkt == -2) then
        write(6,*)'Yes sink and trim from file, musjoo !'
        write(6,*)'Sink and trim remain fixed, musjoo !'
      else
        write(6,*)'No sink or trim, musjoo !'
        isinkt=0
      end if
c      if (isinkt /= 0) ic0=ICYCLE ! relative cycle
      if (isinkt /= 0) ic0=1 ! absolute cycle
      if (icfull <= ic0) ic0=icfull-1 ! avoid divide-by-zero

c Transom input-data
c put ktrnsm=0 to suppress transom
      read(199,*,iostat=ierr)ktrnsm,ibtrns,ittrns,ktrd
      if (ierr /= 0) ktrnsm=0
      if (ktrnsm == 0) then
        write(6,*)'No transom, musjoo !'
      else
        ktrnsm=ktrnsm/LVLSTP
        ibtrns=ibtrns/LVLSTP
        ittrns=ittrns/LVLSTP
        ktrd=ktrd/LVLSTP
        
        write(6,*)'Yes transom, musjoo !'
        write(6,*)'Bottom of the transom is at k=',ktrnsm
        write(6,*)'Transom extends from i=',ibtrns,' to i=',ittrns
        write(6,*)'Steplike point movement is smoothed out in',ktrd,
     $   'grid lines above and below the transom'
      end if

c bulbous bow input-data
c put nlim=0 to suppress bulbous bow
      ind2=0
      read(199,*,iostat=ierr)nlim
      if (ierr /= 0) nlim=0
      if (nlim >= 0) then
c all the limitters are either limitters with damping in j-direction ...
        ia=0
      else
c ... or absolute limitters (user has handled the damping when doing the grid)
	ia=1
	nlim=-nlim
      end if
      do lime=1,nlim
      read(199,*)iblim(lime),itlim(lime),jlim(lime),limf(lime)
      iblim(lime)=iblim(lime)/LVLSTP
      itlim(lime)=itlim(lime)/LVLSTP
      jlim(lime)=jlim(lime)/LVLSTP
      if (itlim(lime)-iblim(lime) > 200.or.jlim(lime) > 200)
     $ stop 'FATAL: Ask applmngr to increase limitter space, man !'
        
      write(6,*)'Water surface limitter extending from',iblim(lime),
     $ ' to',itlim(lime),' in the grid, musjoo !'
      if (jlim(lime) == 0) then
        write(6,*)'And j-direction in full, musjoo !'
      else
        write(6,*)'And it extends to',jlim(lime),
     $   ' in j-direction, musjoo !'
      end if
      if (limf(lime) == 0) write(6,*) 'It is a downward limitter !'
      if (limf(lime) == 1) write(6,*) 'It is a total limitter !'

c take notes (water cannot fall under this height)
c we're gonna sink and trim this data with the background grid HULL.BIN
c x and y probably not needed but including them increases the execution
c time and thus the gross national product
      do j=0,ia*jlim(lime)
      do i=iblim(lime),itlim(lime)
      if (IOLD >= 0) then
        xlim(i-iblim(lime),j,lime)=x(i,j,n)
        ylim(i-iblim(lime),j,lime)=y(i,j,n)
        zlim(i-iblim(lime),j,lime)=z(i,j,n)
      else
c xi eta zeta used as temporary memory
        xlim(i-iblim(lime),j,lime)=xi(i,j,n)
        ylim(i-iblim(lime),j,lime)=eta(i,j,n)
        zlim(i-iblim(lime),j,lime)=zeta(i,j,n)
      end if
      end do
      end do
      end do
      if (nlim == 0) write(6,*)'No bulbous bow limitter, musjoo !'

      if (nlim > 0) then
107     ind2=ind2+1        
        read(199,*,iostat=ierr)(ijklim(ind1,ind2),ind1=1,8)
        if (ierr /= 0) then
          ind2=ind2-1
          goto 108
        end if
c iblock,ibot,itop,jbot,jtop,kbot,ktop,iecho2aboveblock
        do ind1=2,7
        ijklim(ind1,ind2)=ijklim(ind1,ind2)/LVLSTP
        end do
        write(6,'(7(a,i4),a)')
     $   'Bulbous bow in block',ijklim(1,ind2),
     $   ' extending from',ijklim(2,ind2),' to',ijklim(3,ind2),
     $   ' wrt i and from',ijklim(4,ind2),' to',ijklim(5,ind2),
     $   ' wrt j and from',ijklim(6,ind2),' to',ijklim(7,ind2),
     $   ' wrt k in the grid, musjoo !'
        if (ijklim(8,ind2) == 1) then
          write(6,*) 'There is water above the bulb.'

c might come as a surprise to some but not me:
c there is room for only one real bulb in this town (the last one will prevail)
          do i=ijklim(2,ind2),ijklim(3,ind2)
          dlim(i-ijklim(2,ind2))=sqrt(
     $     (x(i,0,n)-x(i,0,ijklim(7,ind2)))**2 +
     $     (y(i,0,n)-y(i,0,ijklim(7,ind2)))**2 +
     $     (z(i,0,n)-z(i,0,ijklim(7,ind2)))**2)
c it is supposed that ijklim(6,ind2) = ijklim(7,ind2) = 0
          end do

        else
          write(6,*) 
     $     'This is not as much of a bulb as the bottom of the ship.'
        end if
        if (ind2 < 9) goto 107
        write(6,*)'Oh, the maximum number of bulbs is exceeded. ',
     $   'Contact the program administrator, man !'
108     continue
      end if
      ijklim(1,ind2+1)=-1
      ib=0
      if (IOLD < 0) ib=1 ! we will not apply limitter on first cycle if from COMPUT

      do ind=1,200
      xdt(ind)=0.0
      ydt(ind)=0.0
      zdt(ind)=0.0
      kt(ind)=0
      end do
      virgin=.true.
      
c!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
c the call for vlcb0 should perhaps be in FINFLO directly and not here
c but I'll put it here because I don't want to edit FINFLO. Editing FINFLO
c would mean that I give editing instructions to Antonio and Tin, also. It
c is much easier to call this thing from here for now. RL
      icode=6
      ibow=ibot
      iaft=itop
      kkeel=0
      kwl=n
      
      if (isinkt == 1) then
c Saisto
call vlcb0(x,y,z,l,m,n,icode,ibow,iaft,kkeel,kwl,IOLD)
      else if (isinkt == 2) then
c Matusiak
        call Mvlcb0(x,y,z,l,m,n,icode,ibow,iaft,kkeel,kwl,IOLD,AKG,
     $   ICYCLE,CZ,CM)
      else if (isinkt >= 3) then
c developed Matusiak (same vlcb0 as in pure Matusiak)
        call Mvlcb0(x,y,z,l,m,n,icode,ibow,iaft,kkeel,kwl,IOLD,AKG,
     $   ICYCLE,CZ,CM)
      else if (isinkt == -2) then
c just set the sink&trim from previous grid level and let it stay
        call Mvlcb0(x,y,z,l,m,n,icode,ibow,iaft,kkeel,kwl,IOLD,AKG,
     $   ICYCLE,CZ,CM)
        osink=sink
        otrim=trimm
      end if 
      icfull=max(ic0+1,icfull)
c!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

c read trimmed hull
      if (IOLD > 0.and.isinkt /= 0) then
        call rhull(xhull,yhull,zhull,lhull,mhull,nhull,ierr)
c in the case FINFLO is stopped by writing bull on top of run in RUN-file
c at present the HULLST.BIN is not written - make sure that there is no
c HULLST.BIN then for then we rotate the original!
        if (ierr == 1) 
     $   call rothul(xhull,yhull,zhull,lhull,mhull,nhull,
     $    sink,trimm,xtrim,ytrim,ztrim)
      end if
      if (IOLD == -1.and.isinkt /= 0) then
        call rothul(xhull,yhull,zhull,lhull,mhull,nhull,
     $   sink,trimm,xtrim,ytrim,ztrim)
c put an empty line to sinkage.trim to indicate a level change
        write(601,*)

	print *,'INIThg:',sink,trimm,xtrim,ztrim	
        call dostg(x,y,z,l,m,n,
     $   sink,trimm,xtrim,ztrim+sink,0.0,0.0,xtrim,ztrim)
      end if
c      if (IOLD > 0.and.isinkt /= 0) 
c     $ call rgrid(x,y,z,l,m,n)

c check if the points in x,y,z are in the right order on the hull
c      call relchk(x,y,z,l,m,n,xhull,yhull,zhull,lhull,mhull,nhull,
c     $ ibot,itop,jbot,jtop,kbot,ktop)

      inquire(file='shipstretch.3d',exist=strez)
      if (strez) then
        if (IOLD == 0) strez=.false.
      end if
      if (strez) then
        open(191,file='shipstretch.3d',form='unformatted')
        read(191)nb
        read(191)lm1,mm1,nm1
        if (lm1 == l+1.and.mm1 == m+1.and.nm1 == n+1) then
          read(191)xi,eta,zeta
          write(6,*) 'Stretching read from "shipstretch.3d".'
        else
c stretching functions are probably from the previous multigrid level
          strez=.false.
        end if
        close(191)
      end if
      if (.not.strez) then
        call mkstr(x,y,z,l,m,n,0,l,0,m,0,n,xi,eta,zeta)
        write(6,*) 'Stretching functions interpolated.'
        open(191,file='shipstretch.3d',form='unformatted')
        write(191)1
        write(191)l+1,m+1,n+1
        write(191)xi,eta,zeta
        close(191)
      end if

      return
      end
C
C***********************************************************************
      subroutine rhull(xhull,yhull,zhull,lhull,mhull,nhull,ierr)
c read sinked and trimmed hull
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)

      open(173,file='HULLST.BIN',form='unformatted',status='OLD',
     $ err=9999)
      read(173)nbh
      read(173)lhull1,mhull1,nhull1
      lhull1=lhull1-1
      mhull1=mhull1-1
      nhull1=nhull1-1
      read(173)
     $ (((xhull(i,j,k),i=0,lhull),j=0,mhull),k=0,nhull),
     $ (((yhull(i,j,k),i=0,lhull),j=0,mhull),k=0,nhull),
     $ (((zhull(i,j,k),i=0,lhull),j=0,mhull),k=0,nhull)
c unless closed all the stuff will be after eachother in multiblock
c not standard PLOT3D however
close(173)
      ierr=0

      return

9999  continue
      write(6,*)'**************WARNING*********************'
      write(6,*)'No sinked and trimmed hull found, man !'
      write(6,*)'Trying to continue with the initial hull !'
      ierr=1

      return
      end
C
C***********************************************************************
      subroutine whull(xhull,yhull,zhull,lhull,mhull,nhull,LVLSTP,fname)
c write hull
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)
      character*(*) fname

      open(174,file=fname,form='unformatted')
      write(174)1
      write(174)lhull+1,mhull+1,nhull+1
      write(174)
     $ (((xhull(i,j,k),i=0,lhull),j=0,mhull),k=0,nhull),
     $ (((yhull(i,j,k),i=0,lhull),j=0,mhull),k=0,nhull),
     $ (((zhull(i,j,k),i=0,lhull),j=0,mhull),k=0,nhull)
c unless closed all the stuff will be after eachother in multiblock
c not standard PLOT3D however
close(174)
      write(6,*)fname,' written !'

      return
      end
C
C***********************************************************************
      subroutine rothul(xhull,yhull,zhull,lhull,mhull,nhull,
     $ sink,trimm,xtrim,ytrim,ztrim)
c rotate and sink the hull
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)

c trim
        call dotrim(xhull,yhull,zhull,lhull,mhull,nhull,
     $   trimm,xtrim,ztrim)
c        do lime=1,nlim
c        call dotrim(xlim(0,lime),ylim(0,lime),zlim(0,lime),
c     $   itlim(lime)-iblim(lime),0,0,
c     $   trimm,xtrim,ztrim)
c        end do

c sinkage
        call dosink(xhull,yhull,zhull,lhull,mhull,nhull,sink)
c        do lime=1,nlim
c        call dosink(xlim(0,lime),ylim(0,lime),zlim(0,lime),
c     $   itlim(lime)-iblim(lime),0,0,sink)
c        end do

      write(6,*)'HULL.BIN modified according to sinkage and trim'
      return
      end
C
C***********************************************************************
C transomstuff.f
C
      subroutine tsom(x,y,z,l,m,n,xi,eta,zeta,xhull,yhull,zhull,
     $ lhull,mhull,nhull,ibot,ibtrns,ittrns,ktrnsm,ktrd,ifor)
      USE XYZK
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)
      logical doj
 
      doj=.true. 
c transom
        jhull=0 ! only the real 2d-hull
	
        do ihull1=ibtrns,ittrns
        i=ibot + ihull1
        do j=0,0
        if (z(i,j,n) > zhull(ihull1,jhull,ktrnsm)) then
          if (ifor == 1) then
c fill xdt,ydt,zdt in forward pass
            dist1=9999.9
c we cannot move the surface point even if it is the closest
            do k=n-1,0,-1
            dist2=sqrt((xhull(ihull1,jhull,ktrnsm)-x(i,j,k))**2 +
     $       (yhull(ihull1,jhull,ktrnsm)-y(i,j,k))**2 +
     $       (zhull(ihull1,jhull,ktrnsm)-z(i,j,k))**2)
            if (dist2 < dist1) then
              dist1=dist2
              xdt(ihull1)=xhull(ihull1,jhull,ktrnsm)-x(i,j,k)
              ydt(ihull1)=yhull(ihull1,jhull,ktrnsm)-y(i,j,k)
              zdt(ihull1)=zhull(ihull1,jhull,ktrnsm)-z(i,j,k)
              kt(ihull1)=k
            else
              goto 107
            end if
            end do
107         continue
          else
            dist1=sqrt(xdt(ihull1)**2 + ydt(ihull1)**2 + zdt(ihull1)**2)
          end if

c          ktrbot=MAX(1,kt(ihull1)-ktrd)
c          ktrtop=MIN(n-1,kt(ihull1)+ktrd)
c porting troubel to f90: after I put the 'USE XYZK' above intrinsics 
c max and min cannot be found for some reason I'll replace them then:
          ktrbot=kt(ihull1)-ktrd
	  if (ktrbot < 1) ktrbot=1
          ktrtop=kt(ihull1)+ktrd
	  if (ktrtop > n-1) ktrtop=n-1
c this is worrying, man !!!!!!!!!!!!!!!



          ifirst=1
          do k=kt(ihull1),ktrbot,-1
          diff=ifor*sign(dist1,zdt(ihull1))
          difk=diff*echok(x,y,z,l,m,n,xi,eta,zeta,i,j,k,ktrbot,
     $     int(kt(ihull1)))
          k0=ktrnsm
          call rloczi(ihull1,jhull,xhull,yhull,zhull,lhull,mhull, 
     $     nhull,x(i,j,k),y(i,j,k),z(i,j,k),xd,yd,zd,difk,k,n,doj,
     $     ifirst,ierr)
          ifirst=0

          call xfield(x,y,z,l,m,n,xi,eta,zeta,i,j,k,
     $     ibot,itop,jbot,jtop,kbot,ktop,xd,yd,zd,'j')
          end do

          ifirst=1
          do k=ktrtop,kt(ihull1)+1,-1
          diff=ifor*sign(dist1,zdt(ihull1))
          difk=diff*(1.0-echok(x,y,z,l,m,n,xi,eta,zeta,i,j,k,
     $    int(kt(ihull1)),ktrtop))
          k0=ktrnsm
          call rloczi(ihull1,jhull,xhull,yhull,zhull,lhull,mhull, 
     $     nhull,x(i,j,k),y(i,j,k),z(i,j,k),xd,yd,zd,difk,k,n,doj,
     $     ifirst,ierr)
          ifirst=0

          call xfield(x,y,z,l,m,n,xi,eta,zeta,i,j,k,
     $     ibot,itop,jbot,jtop,kbot,ktop,xd,yd,zd,'j')
          end do

        end if

      end do
      end do
	print *,''
      return
      end
c
c***********************************************************************
      subroutine tr3(x,y,z,l,m,n,xi,eta,zeta,jdist,
     $ alpha1,alpha2,ibot,itop,kbot,ktop)
c handle the transom bottom by interpolation            

      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xi(0:l,0:m,0:n)           
      real eta(0:l,0:m,0:n)           
      real zeta(0:l,0:m,0:n)           

c the surface to which the orthogonalization is done
      jbase=0

      do 110 k=kbot,ktop
      do 110 i=ibot,itop
      do 110 j=jbase+1,jbase+jdist-1

c now this is good Fortran programming ...
      if (k == 0.or.k == n) goto 110
c      if (i == 0.or.i == l) goto 110

      r=(eta(l,j,k)-eta(l,jbase,k))/
     $ (eta(l,jbase+jdist,k)-eta(l,jbase,k))      
        x(i,j,k)=r*x(i,jbase+jdist,k)+(1.0-r)*x(i,jbase,k)
        y(i,j,k)=r*y(i,jbase+jdist,k)+(1.0-r)*y(i,jbase,k)
        z(i,j,k)=r*z(i,jbase+jdist,k)+(1.0-r)*z(i,jbase,k)

110   continue
  
      return
      end
C
C***********************************************************************
C relocate.f
C
      subroutine rloczi(i,j,x,y,z,l,m,n,xe,ye,ze,xd,yd,zd,
     $ diff,kgrid,ngrid,doj,ifirst,ierr)
c relocate xe,ye,ze at i
c let's keep x,z invariant though
      real x(0:l,0:m,0:n)
      real y(0:l,0:m,0:n)
      real z(0:l,0:m,0:n)
      logical doj
c We need to store k and al between consecutive call of this subr.
c (kstore,alstor)
c to a small experiment f90 actually does this if not then
c another way to replace the common statement must be found:
      INTEGER :: kstore = 0,alstor = 0.0
      data err/1.0e-9/
      anomin(a)=sign(amax1(abs(a),err),a)

      ierr=0
      
      k=0 ! just for security, k sould obtain values from kofz or kofxyz
      
      xp=xe
      yp=ye

      if (kgrid == ngrid) then
c handle the point on the hull that is on the free-surface as well
c just project the new location
        zp=ze + diff

c search for the cell the point is in 
c find k such that zp is between k and k+1 ...
        call kofz(i,j,k,zp,z,l,m,n)

c project the point onto the line
        alambd=(zp-z(i,j,k))/anomin(z(i,j,k+1)-z(i,j,k))
        xp=(1.0-alambd)*x(i,j,k) + alambd*x(i,j,k+1)
        yp=(1.0-alambd)*y(i,j,k) + alambd*y(i,j,k+1)
        if (alambd > 1.01 .or. alambd < -0.01) 
     $   write(6,*)'WARNING: (rloczi) Lambda:',alambd,i,j,k
c        alambd=min(1.0,max(0.0,alambd))

        xd=xp-xe
        yd=yp-ye
        zd=diff

c ERROR CHECK: water on deck
c we care
        icare=0
        if (k+1 == n.and.alambd > 1.0) then
          write(6,*)'Water on the deck, man ! Ship is sinking, man !',
     $     i,j,k+1,x(i,j,k+1),y(i,j,k+1),z(i,j,k+1),char(10),
     $     'Everybody for themselves !'
          if (icare == 1) then
            doj=.false.
            xp=x(i,j,k+1)
            yp=y(i,j,k+1)
            zp=z(i,j,k+1)
          else
            doj=.true.
            write(6,*)'But we don''t care, man !'
            write(6,*)'Extrapolazione used above freeboard, man !'
          end if          
          xd=xp-xe
          yd=yp-ye
          zd=zp-ze
          alambd=(zp-z(i,j,k))/anomin(z(i,j,k+1)-z(i,j,k))
        end if

c pretend that diff was y**2 + z**2
c        diff=sign(sqrt(yd*yd + zd*zd),diff)
c        diff=sign(sqrt(xd*xd + yd*yd + zd*zd),diff)
c let's integrate from (xp,yp,zp) for we know that it is between k and k+1
        xt=xp
        yt=yp
        zt=zp
        if (diff < 0.0) then
          diff=0.0
          do k1=k+1,n
          if (z(i,j,k1) >= ze) goto 107
          diff=diff-sqrt((xt-x(i,j,k1))**2 + (yt-y(i,j,k1))**2 + 
     $     (zt-z(i,j,k1))**2)
          xt=x(i,j,k1)
          yt=y(i,j,k1)
          zt=z(i,j,k1)
          end do
107       diff=diff-sqrt((xt-xe)**2 + (yt-ye)**2 + 
     $     (zt-ze)**2)
        else
          diff=0.0
          do k1=k,0,-1
          if (z(i,j,k1) <= ze) goto 108
          diff=diff+sqrt((xt-x(i,j,k1))**2 + (yt-y(i,j,k1))**2 + 
     $     (zt-z(i,j,k1))**2)
          xt=x(i,j,k1)
          yt=y(i,j,k1)
          zt=z(i,j,k1)
          end do
108       diff=diff+sqrt((xt-xe)**2 + (yt-ye)**2 + 
     $     (zt-ze)**2)
        end if

c ERROR CHECK:
c store k and alambd to resist points ending up in wrong order        
        kstore=k
        alstor=
     $   sqrt((xp-x(i,j,k))**2+(yp-y(i,j,k))**2+(zp-z(i,j,k))**2)/
     $   sqrt((x(i,j,k+1)-x(i,j,k))**2+(y(i,j,k+1)-y(i,j,k))**2+
     $   (z(i,j,k+1)-z(i,j,k))**2)

      else ! kgrid == ngrid
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c handle the point on the hull that is below the free-surface
c project the old location and then ...
c why not x also 25.3.1999
        zp=ze

c search for the cell the point is in 
c find k such that zp is between k and k+1 ...
        call kofxyz(i,j,k,xp,yp,zp,x,y,z,l,m,n)

c project the old point onto the line (is this necessary ?)
c maybe we should consider x as well ???
c        if (abs(z(i,j,k+1)-z(i,j,k)) >= 
c     $   abs(y(i,j,k+1)-y(i,j,k))) then
c          alambd=(zp-z(i,j,k))/anomin(z(i,j,k+1)-z(i,j,k))
c          xp=(1.0-alambd)*x(i,j,k) + alambd*x(i,j,k+1)
c          yp=(1.0-alambd)*y(i,j,k) + alambd*y(i,j,k+1)
c        else
c          alambd=(yp-y(i,j,k))/anomin(y(i,j,k+1)-y(i,j,k))
c          xp=(1.0-alambd)*x(i,j,k) + alambd*x(i,j,k+1)
c          zp=(1.0-alambd)*z(i,j,k) + alambd*z(i,j,k+1)
c        end if
        anom=sqrt((x(i,j,k+1)-x(i,j,k))**2+
     $   (y(i,j,k+1)-y(i,j,k))**2+(z(i,j,k+1)-z(i,j,k))**2)
        if (anom < err) then
c singularity
          xp = x(i,j,k+1)
          yp = y(i,j,k+1)
          zp = z(i,j,k+1)
          alambd=1.0
        else
          alambd=
     $     sqrt((xp-x(i,j,k))**2+(yp-y(i,j,k))**2+(zp-z(i,j,k))**2)/
     $     anom
          xp=(1.0-alambd)*x(i,j,k) + alambd*x(i,j,k+1)
          yp=(1.0-alambd)*y(i,j,k) + alambd*y(i,j,k+1)
          zp=(1.0-alambd)*z(i,j,k) + alambd*z(i,j,k+1)
        end if

        if (alambd > 1.01 .or. alambd < -0.01 .and.
     $  (x(i,j,k+1)-x(i,j,k))**2+(y(i,j,k+1)-y(i,j,k))**2+
     $  (z(i,j,k+1)-z(i,j,k))**2 > err) 
     $   write(6,*)'WARNING: (rloczi) LAMBDA:',alambd,i,j,k,
     $   ' nominator = ',anomin(z(i,j,k+1)-z(i,j,k)),
     $   ' or = ',anomin(y(i,j,k+1)-y(i,j,k))
c        alambd=min(1.0,max(0.0,alambd))

c start
        k0=max(nint(sign(1.0,diff)),0)
100     continue
        if (k+k0 > n) then
          xp=x(i,j,n)
          yp=y(i,j,n)
          zp=z(i,j,n)
          k=n-1 ! the point is supposed to be between k and k+1
          goto 101
        end if
        if (k+k0 < 0) then
          xp=x(i,j,0)
          yp=y(i,j,0)
          zp=z(i,j,0)
          k=0
          goto 101
        end if
        xnew=x(i,j,k+k0)
        ynew=y(i,j,k+k0)
        znew=z(i,j,k+k0)
c        dist=sqrt((yp-ynew)*(yp-ynew) + (zp-znew)*(zp-znew))
        dist=sqrt((xp-xnew)*(xp-xnew) + (yp-ynew)*(yp-ynew) + 
     $   (zp-znew)*(zp-znew))
        if (abs(diff) > dist) then
          xp=xnew
          yp=ynew
          zp=znew
          k=k+nint(sign(1.0,diff))
          diff=diff-sign(dist,diff)

          goto 100
        else
          amy=abs(diff)/amax1(dist,err)
          xp=(1.0-amy)*xp + amy*xnew
          yp=(1.0-amy)*yp + amy*ynew
          zp=(1.0-amy)*zp + amy*znew

        end if
c actually this produces an error so it'll be commented
cc just to confirm (*new is a grid point on the hull but *p is actually
cc a point on a grid line segment and the above interpolation
cc while in principle produced a *p on the segment may or may not
cc have produced anomalies)
c        amy=sqrt((xp-x(i,j,k))**2 + (yp-y(i,j,k))**2 + (zp-z(i,j,k))**2)/
c     $   sqrt((x(i,j,k+1)-x(i,j,k))**2 + (y(i,j,k+1)-y(i,j,k))**2 + 
c     $   (z(i,j,k+1)-z(i,j,k))**2)
c        if (amy > 1.01) write(6,*)'WARNING: (rloczi) MY:',amy,i,j,k
c        if (amy < -0.01) write(6,*)'WARNING: (rloczi) MY:',amy,i,j,k
c        amy=min(1.0,max(0.0,amy))
c        xp=(1.0-amy)*x(i,j,k) + amy*x(i,j,k+1)
c        yp=(1.0-amy)*y(i,j,k) + amy*y(i,j,k+1)
c        zp=(1.0-amy)*z(i,j,k) + amy*z(i,j,k+1)

101     continue
        xd=xp-xe
        yd=yp-ye
        zd=zp-ze

        if (k == 0.and.amy < 0.0) 
     $   write(6,*)'Waves are ultra deep, you know !',
     $   i,j,k,x(i,j,k),y(i,j,k),z(i,j,k)
     
c ERROR CHECK:
c check&store k and alambd to resist points ending up in wrong order
c        xm=abs(x(i,j,k+1)-x(i,j,k))
c        ym=abs(y(i,j,k+1)-y(i,j,k))
c        zm=abs(z(i,j,k+1)-z(i,j,k))
c        if (zm >= max(xm,ym)) then
c          alambd=(zp-z(i,j,k))/anomin(z(i,j,k+1)-z(i,j,k))
c        else if (ym >= xm) then
c          alambd=(yp-y(i,j,k))/anomin(y(i,j,k+1)-y(i,j,k))
c        else
c          alambd=(xp-x(i,j,k))/anomin(x(i,j,k+1)-x(i,j,k))
c        end if
        alambd=
     $   sqrt((xp-x(i,j,k))**2+(yp-y(i,j,k))**2+(zp-z(i,j,k))**2)/
     $   sqrt((x(i,j,k+1)-x(i,j,k))**2+(y(i,j,k+1)-y(i,j,k))**2+
     $   (z(i,j,k+1)-z(i,j,k))**2)

        if (ifirst /= 1.and.kgrid /= 0.and.(k > kstore.or.
     $   (k == kstore.and.alambd > alstor))) then
c points in wrong order, man !
c assumes descending k-loop around this routine
          write(6,*)'Points in wrong order, man !'
          write(6,*)'ihull,jhull,khull,kstore =',i,j,k,kstore
          write(6,*)'alambd,alstore =',alambd,alstore
          k=kstore
          alambd=alstor ! - 1.0e-6 ! singularities !!!
          xp=(1.0-alambd)*x(i,j,k) + alambd*x(i,j,k+1)
          yp=(1.0-alambd)*y(i,j,k) + alambd*y(i,j,k+1)
          zp=(1.0-alambd)*z(i,j,k) + alambd*z(i,j,k+1)
          
          xd=xp-xe
          yd=yp-ye
          zd=zp-ze

c in normal situations one must stop at this error
c for debugging you may, however, comment the following lines and the program
c will crash for some other error soon  
          write(6,'(a$)')' Probable cause: free-surface reaching the '
          write(6,*)'bottom of the block at k= ',k
          write(6,*)'... Or NaN-values appearing !'
          write(6,*)'***Severe error***'
          write(6,*)'*** Vamos ***'
          write(6,*)'Aborting ...'
	  ierr=1
        end if

        kstore=k
        alstor=alambd

      end if  ! kgrid == ngrid

      return
      end
C
C***********************************************************************
      subroutine kofz(i,j,k,zp,z,l,m,n)
c find largest k such that zp is between k and k+1 ...
c (to find the largest is just a clumsy way to handle concave stern)
c remember that this routine is only used when finding a point on the 
c free-surface otherwise concavity may cause problems
      real z(0:l,0:m,0:n)

        do 100 k1=n,0,-1
        if (zp > z(i,j,k1)) goto 101
100     continue
101     k=k1
c ... now zp is between k and k+1
c and an exception ...
        if (k == n) k=k-1

      return
      end
C
C***********************************************************************
      subroutine kofxyz(i,j,k,xp,yp,zp,x,y,z,l,m,n)
c find k such that (xp,yp,zp) is between k and k+1 ...
      real x(0:l,0:m,0:n)
      real y(0:l,0:m,0:n)
      real z(0:l,0:m,0:n)

c just find closest segment
        d=9.9e10
        do 10 k1=0,n-1
        dotprd=(xp-x(i,j,k1))*(x(i,j,k1+1)-x(i,j,k1)) +
     $   (yp-y(i,j,k1))*(y(i,j,k1+1)-y(i,j,k1)) +
     $   (zp-z(i,j,k1))*(z(i,j,k1+1)-z(i,j,k1))
        if (dotprd <= 0.0) then
          d1=(xp-x(i,j,k1))**2 + (zp-z(i,j,k1))**2 + (yp-y(i,j,k1))**2
        else if (dotprd >= (x(i,j,k1+1)-x(i,j,k1))**2 +
     $   (z(i,j,k1+1)-z(i,j,k1))**2 + (y(i,j,k1+1)-y(i,j,k1))**2) then
          d1=(xp-x(i,j,k1+1))**2 + (zp-z(i,j,k1+1))**2 + 
     $     (yp-y(i,j,k1+1))**2
        else
          dotprd=dotprd/((x(i,j,k1+1)-x(i,j,k1))**2 +
     $   (z(i,j,k1+1)-z(i,j,k1))**2 + (y(i,j,k1+1)-y(i,j,k1))**2)
          d1=(xp-x(i,j,k1)-dotprd*(x(i,j,k1+1)-x(i,j,k1)))**2 +
     $     (yp-y(i,j,k1)-dotprd*(y(i,j,k1+1)-y(i,j,k1)))**2 +         
     $     (zp-z(i,j,k1)-dotprd*(z(i,j,k1+1)-z(i,j,k1)))**2        
        end if

        if (d1 <= d) then
          d=d1
          k=k1
        end if
10      continue
        
      return
      end
C
C***********************************************************************
      subroutine sloczi(ihull,jhull,xhull,yhull,zhull,
     $ lhull,mhull,nhull,i,j,k,xi,eta,zeta,l,m,n,
     $ x,y,z,cwh,kbot,ktop,zztop,zg,llb,llt,iforce)
c relocate xe,ye,ze at i by stretching functions
c let's keep x,z invariant though
      real xhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real yhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real zhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      real zg(-2:l+1,-2:m+1,-2:n+1)
c      real zztop(-2:l+1,-2:m+1,-2:n+1)
      real zztop(0:l,0:m,0:n)
      
c htlen = total curvelength
c zztop stores the relative position of point (always between 0 and 1)
c uplim = curvelength to the point in question
c htlenb = bottom (keel) point from which to integrate the curvelength
c actually the curvelength to that point from keel

c total curve length along the hull from keel to current water height cwh
c to make the code faster the initial value could be calculated
c elsewhere (once) and stored and just the difference to that here
c and definitely outside the k-loop
c      htlen=hlenk(xhull,yhull,zhull,lhull,mhull,nhull,ihull,jhull,
c     $ cwh,0,nhull)
c choose upper waterline point (if multiple)
      if (iforce == 0) then
        htlen=hlenkr(xhull,yhull,zhull,lhull,mhull,nhull,ihull,jhull,
     $   cwh,0,nhull,llb,llt)
      else
c the only difference here is that if cwh is less than the end point
c of curve the end point of curve is taken if the curve is descending
c (the one above takes some point on the curve which is theoretically
c the right thing to do and also practically if hull is properly generated)
        htlen=hlenkf(xhull,yhull,zhull,lhull,mhull,nhull,ihull,jhull,
     $   cwh,0,nhull,llb,llt)
      end if

c for the stretching functions there are two approaches: curve length 
c (strict) or just plain value (approximate but always monotonic and 
c probably sufficient - this is not physical remember)
c      stlen=slenk(xi,eta,zeta,l,m,n,i,j,0,n)

c      cf=slenk(xi,eta,zeta,l,m,n,i,j,0,k)/stlen
c      cf=zeta(i,j,k)
      cf=zztop(i,j,k)
          
      uplim=cf*htlen
      if (kbot > 0) then
c htlenb could be saved in a common area if sloczi is called in proper order
        htlenb=hlenkr(xhull,yhull,zhull,lhull,mhull,nhull,ihull,jhull,
     $   zg(i,j,kbot),0,nhull,llb,llt)
c        cf=(zztop(i,j,k)-zztop(i,j,kbot))/
c     $   (zztop(i,j,ktop)-zztop(i,j,kbot))
c        uplim=htlenb + cf*(htlen-htlenb)
c in practise trouble will come if the curve on which the points are distributed
c is zero in length, in particular soon RO will get NaN-values and 
c thus WH as well and we get a WH is NaN condition, remedy:
        uplim=htlenb + cf*max(htlen-htlenb,1.0e-5)
      end if
      call inthk(xhull,yhull,zhull,lhull,mhull,nhull,ihull,jhull,
     $ uplim,x,y,z,llb,llt)

      return
      end
C
C***********************************************************************
      subroutine relchk(x,y,z,l,m,n,xhull,yhull,zhull,lhull,mhull,nhull,
     $ ibot,itop,jbot,jtop,kbot,ktop)
c check and reorganize wrt k
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)
      anomin(a)=sign(amax1(abs(a),1.0e-6),a)

      do j=jbot,jtop
      do i=ibot,itop
      ifirst=1
      do k=kbot,ktop
      ihull=i-ibot
      jhull=j-jbot

c find khull for x,y,z
      call kofxyz(ihull,jhull,khull,x(i,j,k),y(i,j,k),z(i,j,k),
     $ xhull,yhull,zhull,lhull,mhull,nhull)
      alambd=sqrt((x(i,j,k)-xhull(ihull,jhull,khull))**2 +
     $ (y(i,j,k)-yhull(ihull,jhull,khull))**2 +
     $ (z(i,j,k)-zhull(ihull,jhull,khull))**2)/anomin(sqrt(
     $ (xhull(ihull,jhull,khull+1)-xhull(ihull,jhull,khull))**2 +
     $ (yhull(ihull,jhull,khull+1)-yhull(ihull,jhull,khull))**2 +
     $ (zhull(ihull,jhull,khull+1)-zhull(ihull,jhull,khull))**2))

      if (ifirst /= 1) then 
        if (khull < khold.or.
     $   (khull == khold.and.alambd < alold)) then
        write(6,*)'Points in wrong order, man !'
        write(6,*)x(i,j,k-1),y(i,j,k-1),z(i,j,k-1),i,j,k-1
        write(6,*)'above'
        write(6,*)x(i,j,k),y(i,j,k),z(i,j,k),i,j,k
         
c we could just add 1e-6 for ex. but then we might get over 1
        khull=khold
        alambd=0.8*alold + 0.2*1.0
        x(i,j,k)=(1.0-alambd)*xhull(ihull,jhull,khull) +
     $   alambd*xhull(ihull,jhull,khull+1)
        y(i,j,k)=(1.0-alambd)*yhull(ihull,jhull,khull) +
     $   alambd*yhull(ihull,jhull,khull+1)
        z(i,j,k)=(1.0-alambd)*zhull(ihull,jhull,khull) +
     $   alambd*zhull(ihull,jhull,khull+1)
        end if
      end if

      ifirst=0
      khold=khull
      alold=alambd
      end do
      end do
      end do
      
      return
      end

C
C***********************************************************************
C mkstr3.f
C
      SUBROUTINE MKSTR(X,Y,Z,L,M,N,ibot,itop,jbot,jtop,kbot,ktop,
     $ XI,ETA,ZETA)
C MAKE THE STRETCHING FUNCTIONS XI AND ETA AND ZETA
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      REAL XI(0:L,0:M,0:N),ETA(0:L,0:M,0:N),ZETA(0:L,0:M,0:N)
      real ds1xi(0:1,0:1),ds2xi(0:1,0:1)
      real ds1et(0:1,0:1),ds2et(0:1,0:1)
      real ds1ze(0:1,0:1),ds2ze(0:1,0:1)

C FILL THE FACES INITIALLY
      DO 10 K=kbot,ktop,MAX(1,ktop-kbot)
      DO 10 J=jbot,jtop
      DO 10 I=ibot,itop

      CALL FXI(XI,L,M,N,J,K,J,K,X,Y,Z,ibot,itop)
      CALL FETA(ETA,L,M,N,K,I,K,I,X,Y,Z,jbot,jtop)
      ZETA(I,J,K)=REAL(K-kbot)/REAL(MAX(1,ktop-kbot))
10    CONTINUE

      DO 11 K=kbot,ktop
      DO 11 J=jbot,jtop,MAX(1,jtop-jbot)
      DO 11 I=ibot,itop

      CALL FXI(XI,L,M,N,J,K,J,K,X,Y,Z,ibot,itop)
      CALL FZETA(ZETA,L,M,N,I,J,I,J,X,Y,Z,kbot,ktop)
      ETA(I,J,K)=REAL(J-jbot)/REAL(MAX(1,jtop-jbot))
11    CONTINUE

      DO 12 K=kbot,ktop
      DO 12 J=jbot,jtop
      DO 12 I=ibot,itop,MAX(1,itop-ibot)

      CALL FETA(ETA,L,M,N,K,I,K,I,X,Y,Z,jbot,jtop)
      CALL FZETA(ZETA,L,M,N,I,J,I,J,X,Y,Z,kbot,ktop)
      XI(I,J,K)=REAL(I-ibot)/REAL(MAX(1,itop-ibot))
12    CONTINUE

C INTERPLOLATE THE FACES
      DO 50 K=kbot,ktop,MAX(1,ktop-kbot)
      DO 50 J=jbot+1,jtop-1
      DO 50 I=ibot+1,itop-1

      call crossp(XI(I,jbot,K),ETA(I,jbot,K),XI(I,jtop,K),ETA(I,jtop,K),
     $ XI(ibot,J,K),ETA(ibot,J,K),XI(itop,J,K),ETA(itop,J,K),
     $ XI(I,J,K),ETA(I,J,K))
      ZETA(I,J,K)=REAL(K-kbot)/REAL(MAX(1,ktop-kbot))
50    CONTINUE

      DO 51 K=kbot+1,ktop-1
      DO 51 J=jbot,jtop,MAX(1,jtop-jbot)
      DO 51 I=ibot+1,itop-1

      call crossp(XI(I,J,kbot),ZETA(I,J,kbot),
     $ XI(I,J,ktop),ZETA(I,J,ktop),
     $ XI(ibot,J,K),ZETA(ibot,J,K),XI(itop,J,K),ZETA(itop,J,K),
     $ XI(I,J,K),ZETA(I,J,K))
      ETA(I,J,K)=REAL(J-jbot)/REAL(MAX(1,jtop-jbot))
51    CONTINUE

      DO 52 K=kbot+1,ktop-1
      DO 52 J=jbot+1,jtop-1
      DO 52 I=ibot,itop,MAX(1,itop-ibot)

      call crossp(ETA(I,J,kbot),ZETA(I,J,kbot),
     $ ETA(I,J,ktop),ZETA(I,J,ktop),
     $ ETA(I,jbot,K),ZETA(I,jbot,K),ETA(I,jtop,K),ZETA(I,jtop,K),
     $ ETA(I,J,K),ZETA(I,J,K))
      XI(I,J,K)=REAL(I-ibot)/REAL(MAX(1,itop-ibot))
52    CONTINUE

      DO K=kbot+1,ktop-1
      DO J=jbot+1,jtop-1
      DO I=ibot+1,itop-1
      call crossp(xi(ibot,j,k),eta(ibot,j,k),xi(itop,j,k),eta(itop,j,k),
     $ xi(i,jbot,k),eta(i,jbot,k),xi(i,jtop,k),eta(i,jtop,k),
     $ xi1,eta1)
      call crossp(eta(i,jbot,k),zeta(i,jbot,k),
     $ eta(i,jtop,k),zeta(i,jtop,k),
     $ eta(i,j,kbot),zeta(i,j,kbot),eta(i,j,ktop),zeta(i,j,ktop),
     $ eta2,zeta1)
      call crossp(zeta(i,j,kbot),xi(i,j,kbot),
     $ zeta(i,j,ktop),xi(i,j,ktop),
     $ zeta(ibot,j,k),xi(ibot,j,k),zeta(itop,j,k),xi(itop,j,k),
     $ zeta2,xi2)
      xi(i,j,k)=0.5*(xi1+xi2)
      eta(i,j,k)=0.5*(eta1+eta2)
      zeta(i,j,k)=0.5*(zeta1+zeta2)
      END DO
      END DO
      END DO
c      call strint(xi,eta,zeta,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,100)
      call spek(xi,eta,zeta,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,100)

      DO IND=1,100
      call sskew3(xi,eta,zeta,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,
     $ rhomin,mini,minj,mink,nleft,ibneg,itneg,jbneg,jtneg,
     $ kbneg,ktneg,1)
      if (nleft == 0) goto 100
      DO K=kbot+1,ktop-1
      DO J=jbot+1,jtop-1
      DO I=ibot+1,itop-1
      xi(i,j,k)=(xi(i+1,j,k)+xi(i-1,j,k)+xi(i,j+1,k)+xi(i,j-1,k)+
     $ xi(i,j,k+1)+xi(i,j,k-1))/6.0
      eta(i,j,k)=(eta(i+1,j,k)+eta(i-1,j,k)+eta(i,j+1,k)+eta(i,j-1,k)+
     $ eta(i,j,k+1)+eta(i,j,k-1))/6.0
      zeta(i,j,k)=(zeta(i+1,j,k)+zeta(i-1,j,k)+zeta(i,j+1,k)+
     $ zeta(i,j-1,k)+zeta(i,j,k+1)+zeta(i,j,k-1))/6.0
      END DO
      END DO
      END DO
      END DO

100   CONTINUE

      RETURN
      END
C
C***********************************************************************
      SUBROUTINE FXI(XI,L,M,N,J,K,JXYZ,KXYZ,X,Y,Z,ibot,itop)
      REAL XI(0:L,0:M,0:N)
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)


        XI(ibot,J,K)=0.0

        DO I=ibot,itop-1
        XI(I+1,J,K)=XI(I,J,K)+SQRT(
     $   (X(I+1,JXYZ,KXYZ)-X(I,JXYZ,KXYZ))*
     $   (X(I+1,JXYZ,KXYZ)-X(I,JXYZ,KXYZ)) +
     $   (Y(I+1,JXYZ,KXYZ)-Y(I,JXYZ,KXYZ))*
     $   (Y(I+1,JXYZ,KXYZ)-Y(I,JXYZ,KXYZ)) +
     $   (Z(I+1,JXYZ,KXYZ)-Z(I,JXYZ,KXYZ))*
     $   (Z(I+1,JXYZ,KXYZ)-Z(I,JXYZ,KXYZ)))
        END DO

        IF (XI(itop,J,K) < 0.00001) THEN
c it seems that the whole edge is collapsed to a point
c don't let this happen to the stretching functions
          DO I=ibot+1,itop
          XI(I,J,K)=REAL(I-ibot)/REAL(itop-ibot)
          END DO
          RETURN
        END IF

c normalize
        DO I=ibot,itop-1
        XI(I,J,K)=XI(I,J,K)/XI(itop,J,K)
        END DO

        XI(itop,J,K)=1.0

      RETURN
      END
C
C***********************************************************************
      SUBROUTINE FETA(ETA,L,M,N,K,I,KXYZ,IXYZ,X,Y,Z,jbot,jtop)
      REAL ETA(0:L,0:M,0:N)
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)


        ETA(I,jbot,K)=0.0

        DO J=jbot,jtop-1
        ETA(I,J+1,K)=ETA(I,J,K)+SQRT(
     $   (X(IXYZ,J+1,KXYZ)-X(IXYZ,J,KXYZ))*
     $   (X(IXYZ,J+1,KXYZ)-X(IXYZ,J,KXYZ)) +
     $   (Y(IXYZ,J+1,KXYZ)-Y(IXYZ,J,KXYZ))*
     $   (Y(IXYZ,J+1,KXYZ)-Y(IXYZ,J,KXYZ)) +
     $   (Z(IXYZ,J+1,KXYZ)-Z(IXYZ,J,KXYZ))*
     $   (Z(IXYZ,J+1,KXYZ)-Z(IXYZ,J,KXYZ)))
        END DO

        IF (ETA(I,jtop,K) < 0.00001) THEN
c it seems that the whole edge is collapsed to a point
c don't let this happen to the stretching functions
          DO J=jbot+1,jtop
          ETA(I,J,K)=REAL(J-jbot)/REAL(jtop-jbot)
          END DO
          RETURN
        END IF

c normalize
        DO J=jbot+1,jtop-1
        ETA(I,J,K)=ETA(I,J,K)/ETA(I,jtop,K)
        END DO

        ETA(I,jtop,K)=1.0

      RETURN
      END
C
C***********************************************************************
      SUBROUTINE FZETA(ZETA,L,M,N,I,J,IXYZ,JXYZ,X,Y,Z,kbot,ktop)
      REAL ZETA(0:L,0:M,0:N)
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)


        ZETA(I,J,kbot)=0.0

        DO K=kbot,ktop-1
        ZETA(I,J,K+1)=ZETA(I,J,K)+SQRT(
     $   (X(IXYZ,JXYZ,K+1)-X(IXYZ,JXYZ,K))*
     $   (X(IXYZ,JXYZ,K+1)-X(IXYZ,JXYZ,K)) +
     $   (Y(IXYZ,JXYZ,K+1)-Y(IXYZ,JXYZ,K))*
     $   (Y(IXYZ,JXYZ,K+1)-Y(IXYZ,JXYZ,K)) +
     $   (Z(IXYZ,JXYZ,K+1)-Z(IXYZ,JXYZ,K))*
     $   (Z(IXYZ,JXYZ,K+1)-Z(IXYZ,JXYZ,K)))
        END DO

        IF (ZETA(I,J,ktop) < 0.00001) THEN
c it seems that the whole edge is collapsed to a point
c don't let this happen to the stretching functions
          DO K=kbot+1,ktop
          ZETA(I,J,K)=REAL(K-kbot)/REAL(ktop-kbot)
          END DO
          RETURN
        END IF

c normalize
        DO K=kbot+1,ktop-1
        ZETA(I,J,K)=ZETA(I,J,K)/ZETA(I,J,ktop)
        END DO

        ZETA(I,J,ktop)=1.0

      RETURN
      END
C
C***********************************************************************
      subroutine spek(x,y,z,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,niter)
c interpolate 3d stretching functions
      real x(0:l,0:m,0:n),y(0:l,0:m,0:n),z(0:l,0:m,0:n)
      logical slut
      data err,err1/1.0e-6,1.0e-6/

      do ind=1,niter
      slut=.true.
      DO K=kbot,ktop
      DO J=jbot,jtop
      DO I=ibot,itop

      xold=x(i,j,k)
      yold=y(i,j,k)
      zold=z(i,j,k)

      x(i,j,k)=x(i,0,0)*(1.0-y(i,j,k))*(1.0-z(i,j,k)) +  
     $ x(i,M,0)*y(i,j,k)*(1.0-z(i,j,k)) +  
     $ x(i,0,N)*(1.0-y(i,j,k))*z(i,j,k) + x(i,M,N)*y(i,j,k)*z(i,j,k)
      y(i,j,k)=y(0,j,0)*(1.0-x(i,j,k))*(1.0-z(i,j,k)) +  
     $ y(L,j,0)*x(i,j,k)*(1.0-z(i,j,k)) +  
     $ y(0,j,N)*(1.0-x(i,j,k))*z(i,j,k) + y(L,j,N)*x(i,j,k)*z(i,j,k)
      z(i,j,k)=z(0,0,k)*(1.0-x(i,j,k))*(1.0-y(i,j,k)) +  
     $ z(L,0,k)*x(i,j,k)*(1.0-y(i,j,k)) +  
     $ z(0,M,k)*(1.0-x(i,j,k))*y(i,j,k) + z(L,M,k)*x(i,j,k)*y(i,j,k)

      if ((x(i,j,k)-xold)*(x(i,j,k)-xold) +   
     $ (y(i,j,k)-yold)*(y(i,j,k)-yold) +    
     $ (z(i,j,k)-zold)*(z(i,j,k)-zold) < err1)  slut=.false. 
      end do
      end do
      end do
      if (slut) return
      end do

      return
      end
C
C***********************************************************************
      subroutine crossp(x11,y11,x12,y12,x21,y21,x22,y22,x,y)
c calculate the crossing point (x,y) of the lines 
c L1 = (x11,y11) -> (x12,y12) and L2 = (x21,y21) -> (x22,y22)
c cf. Pentikainen: Matematiikan kaavoja p.14 and p.34

      call linecf(x11,y11,x12,y12,a1,b1,c1)
      call linecf(x21,y21,x22,y22,a2,b2,c2)
      d = a1*b2 - b1*a2
      d1= c1*b2 - b1*c2
      d2= a1*c2 - c1*a2

      if (d /= 0.0) then
        x = -d1/d
        y = -d2/d
      else
        x = x11
        y = y11
        write(*,*) 'CROSSP: Can''t resolve; Lines are in parallel, man!'
        write(*,*) '***** Error ocurred *****'
      end if

      return
      end
C
C***********************************************************************
      subroutine linecf(x1,y1,x2,y2,a,b,c)
c calculate the coefficients a,b,c of a line 
c L = (x1,y1) -> (x2,y2) in the normal form
c cf. Pentikainen: Matematiikan kaavoja p.34

      b = x1 - x2
      a = y2 - y1
      c = -a*x1 - b*y1
      return
      end
C
C***********************************************************************
C sinktrim.f
C
      subroutine sinktr(x,y,z,l,m,n,xi,eta,zeta,icode,
     $ xhull,yhull,zhull,lhull,mhull,nhull,
     $ ibot,itop,jbot,jtop,kbot,ktop)
c sinkage and trim about (xtrim,ytrim,ztrim)
c MGM and NB should in fact come in as parameters
      USE TRSINK
      USE GLIM
      USE XYZK
      USE CENG
      parameter(MGM=6,NB=96)

      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)
      logical doj


c Note: The sinkage and trim code was first developed so that the centre of
c       rotation could be anywhere, which means that the old trim had to be
c       first reset with the old COR and only after this the new trim could 
c       be applied with the new COR. After glueing the COR to COG this became
c       unnecessary since FINFLO kernel calculates the moment about the new
c       location. Some of the routines may, however, strike as cumbersome if 
c       one does not know the history.

      if (ibasic == 2 .or. ibasic == 3 .or. ibasic == 1) then
c the other way
        dsink=sink-osink
        dtrim=trimm-otrim
c sink and trim the hull:
c        call dosth(xhull,yhull,zhull,lhull,mhull,nhull,
c     $   sink,trimm,xtrim,ztrim,-osink,-otrim,oxtrim,oztrim)
        call dosth(xhull,yhull,zhull,lhull,mhull,nhull,
     $   dsink,dtrim,xtrim,ztrim,0.0,0.0,oxtrim,oztrim)
c sink and trim the grid:
c        call dostg(x,y,z,l,m,n,
c     $   sink,trimm,xtrim,ztrim,-osink,-otrim,oxtrim,oztrim)
        call dostg(x,y,z,l,m,n,
     $   dsink,dtrim,xtrim,ztrim,0.0,0.0,oxtrim,oztrim)
c sink and trim the bulb-limitters:
        do lime=1,nlim
c          call dosth(xlim(0,lime),ylim(0,lime),zlim(0,lime),
c     $     itlim(lime)-iblim(lime),0,0,
c     $     sink,trimm,xtrim,ztrim,-osink,-otrim,oxtrim,oztrim)
          call dosth(xlim(0,0,lime),ylim(0,0,lime),zlim(0,0,lime),
     $     itlim(lime)-iblim(lime),ia*jlim(lime),0,
     $     dsink,dtrim,xtrim,ztrim,0.0,0.0,oxtrim,oztrim)
        end do
c sink and trim the cog
c NOPE: this has been transferred to subr. Mstdd for multi-block reasons
c        call dosth(xcg,ycg,zcg,0,0,0,
c     $   sink,trimm,xtrim,ztrim,-osink,-otrim,oxtrim,oztrim)
c         zcg=zcg+sink+osink ! sign change of osink above
        return
      end if

c this crap that follows is the old way of doing those things that
c were done above (we'll use it for ibasic=1 for sometime still just to be sure)

      if (icode == 6) then
c for the hull:
c =============
c!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
c since the sinkage'n'trim is calculated wrt initial state we must
c either have the initial state i.e. initial hull 'n' initial grid stored
c or we'll first have to revert our previous sinkage'n'trim - the latter
c is selected as our approach for the time being


c sink and trim the cog
c NOPE: this has been transferred to subr. Mstdd for multi-block reasons
c        call dosth(xcg,ycg,zcg,0,0,0,
c     $   sink,trimm,xtrim,ztrim,-osink,-otrim,oxtrim,oztrim)
c         zcg=zcg+sink-osink

c revert old sinkage
        call dosink(xhull,yhull,zhull,lhull,mhull,nhull,-osink)
        do lime=1,nlim
        call dosink(xlim(0,0,lime),ylim(0,0,lime),zlim(0,0,lime),
     $   itlim(lime)-iblim(lime),ia*jlim(lime),0,-osink)
        end do

c revert old trim
        call dotrim(xhull,yhull,zhull,lhull,mhull,nhull, 
     $   -otrim,oxtrim,oztrim)
        do lime=1,nlim
        call dotrim(xlim(0,0,lime),ylim(0,0,lime),zlim(0,0,lime),
     $   itlim(lime)-iblim(lime),ia*jlim(lime),0, 
     $   -otrim,oxtrim,oztrim)
        end do
c!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

c trim
        call dotrim(xhull,yhull,zhull,lhull,mhull,nhull,
     $   trimm,xtrim,ztrim)
        do lime=1,nlim
        call dotrim(xlim(0,0,lime),ylim(0,0,lime),zlim(0,0,lime),
     $   itlim(lime)-iblim(lime),ia*jlim(lime),0,
     $   trimm,xtrim,ztrim)
        end do

c sinkage
        call dosink(xhull,yhull,zhull,lhull,mhull,nhull,sink)
        do lime=1,nlim
        call dosink(xlim(0,0,lime),ylim(0,0,lime),zlim(0,0,lime),
     $   itlim(lime)-iblim(lime),ia*jlim(lime),0,sink)
        end do

c for the grid:
c =============
c sinkage'n'trim together, man !
        do j=jbot,jtop
        do i=ibot,itop
        ifirst=1
        do k=ktop,kbot,-1

        if (i >= ibot.and.i <= itop.and.j >= jbot.and.j <= jtop.and.
     $   k >= kbot.and.k <= ktop) then
c we just have to do this this funny way: first transform and then antitransform
c otherwise we get away from the hull i.e. we first do sinkage'n'trim
c and then put the waterline where it used to be with rloczi
          xold=x(i,j,k)
          yold=y(i,j,k)
          zold=z(i,j,k)

c!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
c since the sinkage'n'trim is calculated wrt initial state we must
c either have the initial state i.e. initial hull 'n' initial grid stored
c or we'll first have to revert our previous sinkage'n'trim - the latter
c is selected as our approach for the time being

          z(i,j,k)=z(i,j,k) - osink
          dx=x(i,j,k)-oxtrim
          dz=z(i,j,k)-oztrim
          x(i,j,k)=oxtrim + dx*cos(-otrim) - dz*sin(-otrim)
          z(i,j,k)=oztrim + dx*sin(-otrim) + dz*cos(-otrim)
c!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          dx=x(i,j,k)-xtrim
          dz=z(i,j,k)-ztrim
          x(i,j,k)=xtrim + dx*cos(trimm) - dz*sin(trimm)
          z(i,j,k)=ztrim + dx*sin(trimm) + dz*cos(trimm)
          z(i,j,k)=z(i,j,k) + sink
          al=echok(x,y,z,l,m,n,xi,eta,zeta,i,j,k,kbot,ktop)
          al=2.0*
     $     amax1(0.0,sposik(xi,eta,zeta,l,m,n,i,j,k,kbot,ktop)-0.5)
          diff = al*(zold - z(i,j,k))

          ihull1=i-ibot
          jhull1=j-jbot
          doj=.true.
          call rloczi(ihull1,jhull1,xhull,yhull,zhull,
     $     lhull,mhull,nhull,
     $     x(i,j,k),y(i,j,k),z(i,j,k),xd,yd,zd,diff,k,n,doj,ifirst,ierr)
          ifirst=0
          xnew = x(i,j,k) + xd
          ynew = y(i,j,k) + yd
          znew = z(i,j,k) + zd
c         xd=xd + xtrim + dx*cos(dtrim) - dz*sin(dtrim) - x(i,j,k)
c         zd=zd + dsink + ztrim + dx*sin(dtrim) + dz*cos(dtrim) - 
c     $     z(i,j,k)
          xd=xnew-xold
          yd=ynew-yold
          zd=znew-zold
          x(i,j,k)=xold
          y(i,j,k)=yold
          z(i,j,k)=zold
c          if (abs(zd) > 1.0e-5) write(6,*)'zd not 0 in sinkntrim'
          call xfield(x,y,z,l,m,n,xi,eta,zeta,i,j,k,
     $     ibot,itop,jbot,jtop,kbot,ktop,xd,yd,zd,'j')
 
c echo to the complement
c yd mussen zero be
          yd=0.0

          if (k == kbot .and. kbot > 0 .and. nlim == 0) then
c carry to depth
c do not if there is a bulb namely the construction is supposed to be
c like the hull consists of three parts upper part, keel part and bulb
c this is the upper part and below it is the keel part, in front of
c the keel part is the bulb
            do k1=0,k-1
            al=amin1(1.0,2.0*sposik(xi,eta,zeta,l,m,n,i,j,k1,0,kbot))
            xd1=al*xd
            yd1=al*yd
            zd1=al*zd
c            x(i,j,k1) = x(i,j,k1) + al*xd
c            y(i,j,k1) = y(i,j,k1) + al*yd
c            z(i,j,k1) = z(i,j,k1) + al*zd
            call xfield(x,y,z,l,m,n,xi,eta,zeta,i,j,k1,
     $       ibot,itop,jbot,jtop,kbot,ktop,xd1,yd1,zd1,'j')
            end do
          end if

          if (i == ibot .and. ibot > 0 .and. ijklim(1,1) == -1) then
c carry to upstream
c do only if there are no bulbs or anything
c in case of a bulb let it handle this
            do i1=0,i-1
            al=amin1(1.0,2.0*sposii(xi,eta,zeta,l,m,n,i1,j,k,0,ibot))
            xd1=al*xd
            yd1=al*yd
            zd1=al*zd
c            x(i1,j,k) = x(i1,j,k) + al*xd
c            y(i1,j,k) = y(i1,j,k) + al*yd
c            z(i1,j,k) = z(i1,j,k) + al*zd
            call xfield(x,y,z,l,m,n,xi,eta,zeta,i1,j,k,
     $       ibot,itop,jbot,jtop,kbot,ktop,xd1,yd1,zd1,'j')
            end do
          end if

          if (i == itop .and. itop < l) then
c carry to downstream
            do i1=i+1,l
            al=1.0-amin1(1.0,2.0*sposii(xi,eta,zeta,l,m,n,i1,j,k,
     $       itop,l))
            xd1=al*xd
            yd1=al*yd
            zd1=al*zd
c            x(i1,j,k) = x(i1,j,k) + al*xd
c            y(i1,j,k) = y(i1,j,k) + al*yd
c            z(i1,j,k) = z(i1,j,k) + al*zd
            call xfield(x,y,z,l,m,n,xi,eta,zeta,i1,j,k,
     $       ibot,itop,jbot,jtop,kbot,ktop,xd1,yd1,zd1,'j')
            end do
          end if

        end if
        end do
        end do
        end do

        if (ijklim(1,1) == -1) return
c bulb or keel part of the hull

c some theory:
c ============
c
c despite of the nominal generality the thang below relies on the following
c decomposition:
c                 -----------------------------------------
c                |            |                            |
c                |            |         Hull               |
c                |   Above    |                            |
c                |            |                            |
c                |            |----------------------------|
c                |            |                            |
c                |------------|                            |
c                |            |         Keel               |
c                |   Bulb     |                            |
c                |            |                            |
c                 -----------------------------------------
c
c the problem is that, if all the patches are treated fully then the
c interpatch boundaries will be treated twice
c quick an dirty solution: do not treat the right-hand boundary of Bulb or Above
c nor the upper boundary of Keel (Above is treated by echoing from Bulb
c so there is no problem there)
c BTW: At this point Hull is already treated and Bulb and Keel are determined
c by ijklim in random order ( ijklim(8,.) = 1 for Bulb )

        ibulb=0
102     ibulb=ibulb + 1
        do k=ijklim(6,ibulb),ijklim(7,ibulb)
        do j=ijklim(4,ibulb),ijklim(5,ibulb)
        do i=ijklim(2,ibulb),ijklim(3,ibulb)

c!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
c since the sinkage'n'trim is calculated wrt initial state we must
c either have the initial state i.e. initial hull 'n' initial grid stored
c or we'll first have to revert our previous sinkage'n'trim - the latter
c is selected as our approach for the time being

c the right-hand boundary of the Bulb
        if (i == ijklim(3,ibulb) .and. ijklim(3,ibulb) < l 
     $      .and. ijklim(8,ibulb) == 1) goto 991
c the top of the Keel part
c freestyler - straight from the top of my doon
c rockarockarocka my cafoon
        if (k == ijklim(7,ibulb) .and. ijklim(7,ibulb) < n 
     $     .and. ijklim(8,ibulb) /= 1) goto 991


          znew=z(i,j,k) - osink
          dx=x(i,j,k)-oxtrim
          dz=znew-oztrim
          xnew=oxtrim + dx*cos(-otrim) - dz*sin(-otrim)
          znew=oztrim + dx*sin(-otrim) + dz*cos(-otrim)
c!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          dx=xnew-xtrim
          dz=znew-ztrim
          xnew=xtrim + dx*cos(trimm) - dz*sin(trimm)
          znew=ztrim + dx*sin(trimm) + dz*cos(trimm)
          znew=znew + sink
          xd=xnew-x(i,j,k)
          yd=0.0
          zd=znew-z(i,j,k)
c          if (abs(zd) > 1.0e-5) write(6,*)'zd not zero in sinkntrim'
          call xfield(x,y,z,l,m,n,xi,eta,zeta,i,j,k,
     $     ijklim(2,ibulb),ijklim(3,ibulb),
     $     ijklim(4,ibulb),ijklim(5,ibulb),
     $     ijklim(6,ibulb),ijklim(7,ibulb),xd,yd,zd,'j')
 
c echo to the complement
c yd mussen zero be
          yd=0.0

          if (k == ijklim(6,ibulb) .and. ijklim(6,ibulb) > 0) then
c carry to depth
            do k1=0,k-1
            al=amin1(1.0,2.0*sposik(xi,eta,zeta,l,m,n,i,j,k1,0,k))
            xd1=al*xd
            yd1=al*yd
            zd1=al*zd
            call xfield(x,y,z,l,m,n,xi,eta,zeta,i,j,k1,
     $       ijklim(2,ibulb),ijklim(3,ibulb),
     $     ijklim(4,ibulb),ijklim(5,ibulb),
     $     ijklim(6,ibulb),ijklim(7,ibulb),xd1,yd1,zd1,'j')
            end do
          end if

          if (i == ijklim(2,ibulb) .and. ijklim(2,ibulb) > 0 
     $      .and. ijklim(8,ibulb) == 1) then
c carry to upstream
c only if this is the bulb
c if this is the keel part then please don't do this since bulb is ahead
            do i1=0,i-1
            al=amin1(1.0,2.0*sposii(xi,eta,zeta,l,m,n,i1,j,k,0,i))
            xd1=al*xd
            yd1=al*yd
            zd1=al*zd
            call xfield(x,y,z,l,m,n,xi,eta,zeta,i1,j,k,
     $       ijklim(2,ibulb),ijklim(3,ibulb),
     $     ijklim(4,ibulb),ijklim(5,ibulb),
     $     ijklim(6,ibulb),ijklim(7,ibulb),xd1,yd1,zd1,'j')
            end do
          end if

          if (i == ijklim(3,ibulb) .and. ijklim(3,ibulb) < l 
     $      .and. ijklim(8,ibulb) /= 1) then
c carry to downstream
c only if this is the keel part
c if this is the bulb then please don't do this since keel part is ahead
            do i1=i+1,l
            al=1.0-amin1(1.0,2.0*sposii(xi,eta,zeta,l,m,n,i1,j,k,
     $       i,l))
            xd1=al*xd
            yd1=al*yd
            zd1=al*zd
            call xfield(x,y,z,l,m,n,xi,eta,zeta,i1,j,k,
     $       ijklim(2,ibulb),ijklim(3,ibulb),
     $     ijklim(4,ibulb),ijklim(5,ibulb),
     $     ijklim(6,ibulb),ijklim(7,ibulb),xd1,yd1,zd1,'j')
            end do
          end if

          if (k == ijklim(7,ibulb) .and. ijklim(7,ibulb) < n 
     $     .and. ijklim(8,ibulb) == 1) then
c carry to up
c only if this is the bulb
c if this is the keel part then please don't do this since 
c the upper part is ahead

            dist=sqrt((x(i,j,n)-x(i,j,k)-xd)**2 +
     $       (y(i,j,n)-y(i,j,k)-yd)**2 + (z(i,j,n)-z(i,j,k)-zd)**2)
            almin=0.0
            if (dist < dlim(i-ijklim(2,ibulb))) almin=1.0
            do k1=k+1,n
            al=1.0-amin1(1.0,2.0*sposik(xi,eta,zeta,l,m,n,i,j,k1,
     $       k,n))
            al=amax1(al,almin)
            xd1=al*xd
            yd1=al*yd
            zd1=al*zd
            call xfield(x,y,z,l,m,n,xi,eta,zeta,i,j,k1,
     $       ijklim(2,ibulb),ijklim(3,ibulb),
     $     ijklim(4,ibulb),ijklim(5,ibulb),
     $     ijklim(6,ibulb),ijklim(7,ibulb),xd1,yd1,zd1,'j')
            
            if (i == ijklim(2,ibulb) .and. ijklim(2,ibulb) > 0) then
c carry to upstream
              do i1=0,i-1
              al=amin1(1.0,2.0*sposii(xi,eta,zeta,l,m,n,i1,j,k,0,i))
              xd2=al*xd1
              yd2=al*yd1
              zd2=al*zd1
              call xfield(x,y,z,l,m,n,xi,eta,zeta,i1,j,k1,
     $         ijklim(2,ibulb),ijklim(3,ibulb),
     $       ijklim(4,ibulb),ijklim(5,ibulb),
     $       ijklim(6,ibulb),ijklim(7,ibulb),xd2,yd2,zd2,'j')
              end do
            end if
     
            end do
          end if

991     continue
        end do
        end do
        end do
        if (ijklim(1,ibulb+1) /= -1) goto 102
      end if
      return
      end
c
c***********************************************************************
      subroutine dostg(x,y,z,l,m,n,
     $ sink,trimm,xtrim,ztrim,osink,otrim,oxtrim,oztrim)
c do sinkage and trim for the grid
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)

      do k=0,n
      do j=0,m
      do i=0,l
      xg=x(i,j,k)
      zg=z(i,j,k)
      x(i,j,k)=xtrim + (oxtrim - xtrim)*Cos(trimm) + 
     -    (-oxtrim + xg)*Cos(otrim + trimm) - oztrim*Sin(trimm) + 
     -    ztrim*Sin(trimm) - osink*Sin(otrim + trimm) + 
     -    oztrim*Sin(otrim + trimm) - zg*Sin(otrim + trimm)
      z(i,j,k)=sink + ztrim + (oztrim - ztrim)*Cos(trimm) + 
     -    (osink - oztrim + zg)*Cos(otrim + trimm) + oxtrim*Sin(trimm) - 
     -  xtrim*Sin(trimm) - oxtrim*Sin(otrim + trimm) + 
     -  xg*Sin(otrim + trimm)

      goto 100
      x1=x(i,j,k)
      z1=z(i,j,k)
c revert old sinkage
      z1=z1 + osink
c revert old trim
      dx=x1-oxtrim
      dz=z1-oztrim
      x1=oxtrim + dx*cos(otrim) - dz*sin(otrim)
      z1=oztrim + dx*sin(otrim) + dz*cos(otrim)
c trim
      dx=x1-xtrim
      dz=z1-ztrim
      x1=xtrim + dx*cos(trimm) - dz*sin(trimm)
      z1=ztrim + dx*sin(trimm) + dz*cos(trimm)
c sinkage
      z1=z1 + sink
      x(i,j,k)=x1
      z(i,j,k)=z1
100   continue

      end do
      end do
      end do

      return
      end
c
c***********************************************************************
      subroutine dosth(xhull,yhull,zhull,lhull,mhull,nhull,
     $ sink,trimm,xtrim,ztrim,osink,otrim,oxtrim,oztrim)
c do sinkage and trim for the hull
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)

      do k=0,nhull
      do j=0,mhull
      do i=0,lhull
      x=xhull(i,j,k)
      z=zhull(i,j,k)
      xhull(i,j,k)=xtrim + (oxtrim - xtrim)*Cos(trimm) + 
     -    (-oxtrim + x)*Cos(otrim + trimm) - oztrim*Sin(trimm) + 
     -    ztrim*Sin(trimm) - osink*Sin(otrim + trimm) + 
     -    oztrim*Sin(otrim + trimm) - z*Sin(otrim + trimm)
      zhull(i,j,k)=sink + ztrim + (oztrim - ztrim)*Cos(trimm) + 
     -    (osink - oztrim + z)*Cos(otrim + trimm) + oxtrim*Sin(trimm) - 
     -  xtrim*Sin(trimm) - oxtrim*Sin(otrim + trimm) + 
     -    x*Sin(otrim + trimm)

      goto 100
      x1=xhull(i,j,k)
      z1=zhull(i,j,k)
c revert old sinkage
      z1=z1 + osink
c revert old trim
      dx=x1-oxtrim
      dz=z1-oztrim
      x1=oxtrim + dx*cos(otrim) - dz*sin(otrim)
      z1=oztrim + dx*sin(otrim) + dz*cos(otrim)
c trim
      dx=x1-xtrim
      dz=z1-ztrim
      x1=xtrim + dx*cos(trimm) - dz*sin(trimm)
      z1=ztrim + dx*sin(trimm) + dz*cos(trimm)
c sinkage
      z1=z1 + sink
      xhull(i,j,k)=x1
      zhull(i,j,k)=z1
100   continue
      end do
      end do
      end do

      return
      end
c
c***********************************************************************
      subroutine dotrim(xhull,yhull,zhull,lhull,mhull,nhull,
     $ trimm,xtrim,ztrim)
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)

      do k=0,nhull
      do j=0,mhull
      do i=0,lhull
      dx=xhull(i,j,k)-xtrim
      dz=zhull(i,j,k)-ztrim
      xhull(i,j,k)=xtrim + dx*cos(trimm) - dz*sin(trimm)
      zhull(i,j,k)=ztrim + dx*sin(trimm) + dz*cos(trimm)
      end do
      end do
      end do

      return
      end
c
c***********************************************************************
      subroutine dosink(xhull,yhull,zhull,lhull,mhull,nhull,sink)
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)

      do k=0,nhull
      do j=0,mhull
      do i=0,lhull
      zhull(i,j,k)=zhull(i,j,k) + sink
      end do
      end do
      end do

      return
      end
c
c***********************************************************************
      subroutine Mvlcb0(x,y,z,l,m,n,icode,
     $ ibow,iaft,kkeel,kwl,IOLD,AKG,ICYCLE,CZ,CM)
c Matusiak approach
c See: On the evaluation of sinkage and trim of a ship from the
c results of Finflo-computations (version 2) by Matusiak and Schweighofer
c Memorandum of the shippendaler laborarories of HUT at 14.7.1999

c Abstract of the theory:
c initial:
c calculate flotation centre lcf
c calculate wetted surface s0
c integrate z*nz over the wetted surface to get czs0
c integrate z*nz*(lcf - x) over the wetted surface to get cms0
c iteration:
c know freestream velocity FRSVEL
c know g=9.81
c calculate waterplane area aw
c calculate vertical force coefficient czship:
c	know cz from finflo
c	integrate z*nz over the wetted surface to get czs
c	czship = cz + (czs - czs0)*g/(0.5*FRSVEL^2*s0)
c sink = FRSVEL^2 s0 czship/(2 g aw)
c know initial metacentric radius gml
c calculate displacement v
c know reference length lref e.g. lpp
c calculate moment coefficient cmship:
c	know cm from finflo
c	integrate z*nz*(lcf - x) over the wetted surface to get cms
c	cmship = cm + (cms - cms0)*g/(0.5*FRSVEL^2*s0*lref)
c trim = FRSVEL^2 s0 lref cmship/(2 g v gml)
c NOTE: FINFLO and sinkntrim trim about different points which is
c also taken into account
c NOTE: It is perhaps better to use the initial lcf throughout
c to enforce Eq. (6) of the Memorandum; otherwise we would have different
c lcf in SD and S0 integrals which would need to be compensated


c calculate v0 and lcb0

      USE TRSINK
      USE VLCB
      USE GM
      USE CENG
      USE STRIM
      USE DDDAMP
      USE MATU
      USE GLIM
      USE CGLOC
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      character*120 line
      character*3 id

c initial state
      sink=0.0
      trimm=0.0
c      xtrim=0.0
      ytrim=0.0
      ztrim=0.0
      
      alcf0=-9.9e9 ! bullshit

c try first reading the data
      write(id,'(i3.3)') l
      if (IOLD < 0) write(id,'(i3.3)') l/2
        open(601,file='sinkage.trim.'//id)
        ierr=-2
        if (IOLD /= 0) then
          read(601,'(a)',iostat=ierr)line
          if (ierr == 0) then
            if (line(2:2) == 'M') then
              read(line(3:17),*)alcb0
              read(line(18:32),*)v0
              read(line(33:50),*)alcf0
              read(line(51:70),*)S0
              read(line(71:90),*)GML
              read(line(91:110),*)awp0
              read(601,'(a)',iostat=ierr)line
              if (ierr == 0) then
                read(line(3:17),*)xtrim
                read(line(18:32),*)ytrim
                read(line(33:50),*)ztrim
                read(line(51:70),*)xcg
                read(line(71:90),*)ycg
                read(line(91:110),*)zcg
              else
                write(6,*)'Making up centroid data !'
                xtrim=0.0
                ytrim=0.0
                ztrim=0.0
                xcg=0.0
                ycg=0.0
                zcg=0.0
              end if
            else
              write(6,*)'***************WARNING:'
              write(6,*)
     $       'Trying to continue Matusiak from a non-Matusiak starter !'
              ierr=-3
            end if
          end if
        end if
      if (ierr == 0) then
        indst5=0
100     read(601,*,end=101)
        indst5=indst5+1
        goto 100
101     continue
        backspace 601
        backspace 601
	if (indst5 <= 3) then
	  osink=0.0
	  otrim=0.0
	else
	  backspace 601
          read(601,*)osink,otrim,oxtrim,oytrim,oztrim
	end if
        read(601,*)sink,trimm,xtrim,ytrim,ztrim,CZ,CM
        damp0=relax0
        ddamp=(1.0-relax0)/icfull
        if (IOLD < 0) then
          close(601)
	  icfull=1 ! cannot have continuation on a different level with damping 
          write(id,'(i3.3)') l
          open(601,file='sinkage.trim.'//id)
          goto 102 ! do the centroid etc. data again
        end if
        goto 9999
      end if

102   continue

c the hull is on the surface of j=0
      j=0

      CZshi0=0.0
      CMshi0=0.0
c wetted surface
      s0=0.0

c do the waterlineplane
c to get a little off the execution time one can do a separate wplane for 
c Mvlcb0 where aiwp and zsum are not calculated
      call wplane(x,y,z,l,m,n,ibow,iaft,kwl,awp0,amwp,aiwp,zsum)

c flotation centre (new only in the beginning of sinkage and trim calculation)
      if (alcf0 < -9.0e9) alcf0=amwp/awp0
c Steiner
      aiwp = aiwp - alcf0*alcf0*awp0

c alcb not needed here
c actually v0 is not used either but in case someone wants to use the 
c initial displacement instead of the present one 
c (the calculation does not utilize much resources)
      call disp(x,y,z,l,m,n,ibow,iaft,kkeel,kwl,v0,alcb0,b0,
     $ s0,CZshi0,CMshi0,alcf0,1)

c initial state (we don't sink about lcf any longer so you can remove this)
      xtrim=alcf0
c actually, if you remove this then you get divergent trim - why the heck
c is this so important ??? This is only an initial value and also
c false because the trim is supposed to be about the centre of gravity xcg !!!
c we will replace this by xcg as soon as we get to Mstdd - see for yourself !!!

c what we here want to know is the vertical position of G
c ship people want to give KG but then we need T
c for simplicity:
c let us play like AKG is the vertical position of G instead of being KG
c      G0=AKG-T
      G0=AKG
      call momzzz(x,y,z,l,m,n,ibow,iaft,kkeel,kwl,alcf0,
     $ areine,volmom)
c      BM=areine/v0
      BM=aiwp/v0
      BG=G0-b0
      GML=BM-BG
c I am not sure but suspect that when we come here with a new grid level
c we already have a sinked and trimmed grid -> it would be bad to calculate
c zcg from that one
      if (IOLD >= 0.or.ierr /= 0) xcg=alcb0
      ycg=0.0
      zcg=G0+sink
      write(6,*)'BG,BML,GML,b0',BG,BM,GML,b0
      write(6,*)'G',zcg

c damp
c      damp0=0.0015
c      ddamp=0.0001
      damp0=relax0
      ddamp=(1.0-relax0)/icfull
      
      line=''
      line(1:1)='#'
      line(2:2)='M'
      write(6,*)'Writing hydrostatic data to sinkage.trim ...'
      write(line(3:17),*,iostat=ierr)alcb0
      if (ierr /= 0) write(6,*)'... Cannot write alcb0 =',alcb0
      write(line(18:32),*,iostat=ierr)v0
      if (ierr /= 0) write(6,*)'... Cannot write v0 =',v0
      write(line(33:50),*,iostat=ierr)alcf0
      if (ierr /= 0) write(6,*)'... Cannot write alcf0 =',alcf0
      write(line(51:70),*,iostat=ierr)S0
      if (ierr /= 0) write(6,*)'... Cannot write S0 =',S0
      write(line(71:90),*,iostat=ierr)GML
      if (ierr /= 0) write(6,*)'... Cannot write GML =',GML
      write(line(91:110),*,iostat=ierr)awp0
      if (ierr /= 0) write(6,*)'... Cannot write awp0 =',awp0
      write(601,'(a)')line
      line=''
      line(1:1)='#'
      line(2:2)='M'
      write(line(3:17),*,iostat=ierr)xtrim
      if (ierr /= 0) write(6,*)'... Cannot write xtrim =',xtrim
      write(line(18:32),*,iostat=ierr)ytrim
      if (ierr /= 0) write(6,*)'... Cannot write ytrim =',ytrim
      write(line(33:50),*,iostat=ierr)ztrim
      if (ierr /= 0) write(6,*)'... Cannot write ztrim =',ztrim
      write(line(51:70),*,iostat=ierr)xcg
      if (ierr /= 0) write(6,*)'... Cannot write xcg =',xcg
      write(line(71:90),*,iostat=ierr)ycg
      if (ierr /= 0) write(6,*)'... Cannot write ycg =',ycg
      write(line(91:110),*,iostat=ierr)zcg
      if (ierr /= 0) write(6,*)'... Cannot write zcg =',zcg
      write(601,'(a)')line

9999  continue
      zcgloc(mod(ICYCLE-1,2)+1)=zcg
      
      return
      end
c
c***********************************************************************
      subroutine Mstdd(x,y,z,l,m,n,icode,
     $ ibow,iaft,kkeel,kwl,XMOM,YMOM,ZMOM,CX,CY,CZ,CM,FRSVEL,GZ,AKG,
     $ froude,ICYCLE,IBLOCK,AREF,CHLREF)
c developed Matusiak approach
c calculate sinkage and trim

      USE TRSINK
      USE VLCB
      USE GM
      USE CENG
      USE DDDAMP
      USE STRIM
      USE VANHA
      USE MATU
      USE GLIM
      USE CGLOC
c idea for damping: there is the user(programmer) damping times the damping
c that tells the order of magnitude
      REAL :: sdamp=1.0,tdamp=1.0,smdamp=0.01,tmdamp=0.001
      
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)
      data slimit,tlimit,salimi,talimi/1.e-6,1.e-6,1.e-2,1.e-3/
      data icount/0/

c      g=-GZ
c I wondered why is it nowadays GZ=0 all the time - then I remembered 
c sawing a glimpse of the subroutine call of grid3 and I think
c that someone had changed GZ to GK there.
c Well I don't know what GK is and I don't care, but what we need here is
c the acceleration of gravity 9.81 (which is -GZ in finflo usually eh... often)
      g=9.81
      
c      smdamp=10.0**(10.0*froude-6.0)

c old values
c      osink=sink
c      otrim=trimm
      oxtrim=xtrim
      oytrim=ytrim
      oztrim=ztrim

c FINFLO calculated forces and moments
      aLift=2*CZ*0.5*FRSVEL**2*AREF
      aMomen=2*CM*0.5*FRSVEL**2*AREF*CHLREF

c      damp0=damp0+ddamp
      damp=damp0+real(ICYCLE-ic0)/real(icfull-ic0)*(1.0-damp0)
      damp=amin1(1.0,amax1(0.0,damp))
      write(6,*)'damp=',damp,damp0

c sinkage wrt initial state
      sink=damp/awp0*(aLift/g - v0)
      trimm=-damp*aMomen/g/v0/GML

      sink=osink+sink*sdamp*smdamp
      trimm=otrim+trimm*tdamp*tmdamp

c see this ...
c trim about the same point as the moment is calculated
c unfortunately in multiprocessors already the first processor changes ZMOM
c      xtrim=XMOM
c      ytrim=YMOM
c      ztrim=ZMOM
      xtrim=xcg
      ytrim=ycg
      ztrim=zcgloc(mod(ICYCLE-1,2)+1)

c sink the cog
c      zcg=zcg+sink-osink
c for multiprocessors the old value must be with respect to ICYCLE
c don't need an infinite array - congruent modulo 2 is enough
      zcgloc(mod(ICYCLE,2)+1)=zcgloc(mod(ICYCLE-1,2)+1)+sink-osink
      zcg=zcgloc(mod(ICYCLE,2)+1)    

      XMOM=xcg
      YMOM=ycg
      ZMOM=zcg
      
c the thinking about the order of the above is as follows:
c we have calculated the moment using XMOM,YMOM,ZMOM
c so we'll use that point for rotation of the grid as well

c      if (abs(osink-sink) > slimit) then
c        sink=osink+sign(slimit,sink-osink)
c        write(6,*)'Sinkage limitter applied'
c      end if
c      if (abs(otrim-trimm) > tlimit) then
c        trimm=otrim+sign(tlimit,trimm-otrim)
c        write(6,*)'Trim limitter applied'
c      end if
c      if (abs(sink) > salimi) then
c        sink=sign(salimi,sink)
c        write(6,*)'Sinkage absolute limitter applied'
cc        sdamp=sdamp*0.1
c      end if
c      if (abs(trimm) > talimi) then
c        trimm=sign(talimi,trimm)
c        write(6,*)'Trim absolute limitter applied'
cc        trimm=0.9*trimm
cc        tdamp=tdamp*0.1
c      end if
      
c counter
      if (IBLOCK == 1) icount=icount+1
      ith=1
      if (mod(icount,ith) /= 0) then
        sink=osink
        trimm=otrim
      end if

c RESTARTER goodie (needed since RSTART does not store CZ or CMY)
c results in a nuisance: duplicate sink and trim on restart
c      if (abs(aLift) < 1.0e-6) then
      if (icount == 1) then
        sink=osink
        trimm=otrim
      end if
            
c new grid level goodie (needed since COMPUT does not store CZ or CMY)
      if (jold < 0.and.icount <= icfull) then
        sink=osink
        trimm=otrim
      end if
                  
      write(6,*)"XMOM,YMOM,ZMOM:",XMOM,YMOM,ZMOM
      write(6,*)"CZ,CM:",CZ,CM
      write(6,*)'sink=',sink
      write(6,*)'trim=',trimm
      write(6,*)'xyztrim=',xtrim,ytrim,ztrim
      if (IBLOCK == 1) 
     $ write(601,'(7e15.7)')sink,trimm,xtrim,ytrim,ztrim,CZ,CM

      return
      end
c
c***********************************************************************
      subroutine wplane(x,y,z,l,m,n,ibow,iaft,kwl,awp,amwp,aiwp,
     $ zsum)
c do the waterlineplane
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)

c the hull is on the surface of j=0
      j=0
      k=kwl

c waterlineplane area
      awp=0.0
c longitudinal moment of waterlineplane
      amwp=0.0
c longitudinal inertia of waterlineplane
      aiwp=0.0
c try to figure out the height of the center of flotation
      zsum=0.0

      do i=ibow,iaft-1
c 4 points are not necessarily planar, but anyhow ...
c centrum
      xcen=0.5*(x(i,j,k)+x(i+1,j,k))
      ycen=0.5*(y(i,j,k)+y(i+1,j,k))
      zcen=0.5*(z(i,j,k)+z(i+1,j,k))

c area of the face
      dawp=2.0*ycen*sqrt((x(i+1,j,k)-x(i,j,k))**2 + 
     $ (z(i+1,j,k)-z(i,j,k))**2)

      awp = awp + dawp
      amwp = amwp + xcen*dawp

      if (abs(x(i+1,j,k)-x(i,j,k)) > errb) then
        ak=(y(i+1,j,k)-y(i,j,k))/(x(i+1,j,k)-x(i,j,k))
        aiwp = aiwp + 2.0/3.0*(x(i+1,j,k)**3-x(i,j,k)**3)*
     $   (y(i,j,k)-ak*x(i,j,k)) + 0.5*(x(i+1,j,k)**4-x(i,j,k)**4)*ak
      end if

      zsum=zsum + dawp*zcen
      end do

      return
      end
c
c***********************************************************************
      subroutine disp(x,y,z,l,m,n,ibow,iaft,kkeel,kwl,v,alcb,b,
     $ s0,CZship,CMship,alcf,iflag)
c do the waterlineplane
      USE GLIM
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)

c the hull is on the surface of j=0
      j=0

c volume of the displacement and its center
      v=0.0
c center of the displacement lcb
      alcb=0.0
      b=0.0
c wetted surface
      s0=0.0
      CZship=0.0
      CMship=0.0

      indmax=1
      if (nlim > 0) then
        do ind=1,10
        if (ijklim(1,ind) == -1) goto 28
        indmax=indmax+1
        end do
28      continue
      end if

      do ind=1,indmax
c admittedly stupid but indices should be in arrays to get nice loops
c and they are not
      if (ind == 1) then
        k1=kkeel
        k2=kwl
        i1=ibow
        i2=iaft
      else
        k1=ijklim(6,indmax-1)
        k2=ijklim(7,indmax-1)
        i1=ijklim(2,indmax-1)
        i2=ijklim(3,indmax-1)
      end if

      do k=k1,k2-1
      do i=i1,i2-1
      if (z(i,j,k) > 0.0.and.iflag == 1) goto 99
c 4 points are not necessarily planar, but anyhow ...
c centrum
      xcen=0.25*(x(i,j,k)+x(i+1,j,k)+x(i,j,k+1)+x(i+1,j,k+1))
      ycen=0.25*(y(i,j,k)+y(i+1,j,k)+y(i,j,k+1)+y(i+1,j,k+1))
      zcen=0.25*(z(i,j,k)+z(i+1,j,k)+z(i,j,k+1)+z(i+1,j,k+1))

c area of the face
       call xprd(x(i+1,j,k+1)-x(i,j,k),y(i+1,j,k+1)-y(i,j,k),
     $  z(i+1,j,k+1)-z(i,j,k),x(i,j,k+1)-x(i+1,j,k),
     $  y(i,j,k+1)-y(i+1,j,k),z(i,j,k+1)-z(i+1,j,k),xout,yout,zout)
c y=0 is the symmetry plane
      a=0.5*abs(yout)

      dv=2.0*ycen*a
      v = v + dv
      alcb = alcb + xcen*dv
      b = b + zcen*dv
      s0 = s0 + sqrt(xout*xout + yout*yout + zout*zout)
      CZship=CZship + zcen*zout
      CMship=CMship + zcen*(xcen-alcf)*zout
99    continue
      end do
      end do

      end do

      alcb=alcb/v
      b=b/v
      
      write(6,*)'v,CZship,v/CZship:',v,CZship,v/CZship

      return
      end
      
c
c***********************************************************************
      subroutine momzzz(x,y,z,l,m,n,ibow,iaft,kkeel,kwl,xf,
     $ areine,volmom)
c do the waterlineplane
      USE GLIM
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)

c the hull is on the surface of j=0
      j=0
      k=kwl

c moment of volume
      volmom=0.0
c inertia of area
      areine=0.0

      do i=ibow,iaft-1
c 4 points are not necessarily planar, but anyhow ...
c centrum
      xcen=0.5*(x(i,j,k)+x(i+1,j,k))
      ycen=0.5*(y(i,j,k)+y(i+1,j,k))
      zcen=0.5*(z(i,j,k)+z(i+1,j,k))

c area of the face
      dawp=2.0*ycen*sqrt((x(i+1,j,k)-x(i,j,k))**2 + 
     $ (z(i+1,j,k)-z(i,j,k))**2)

      areine = areine + (xcen-xf)**2*dawp
      end do


      indmax=1
      if (nlim > 0) then
        do ind=1,10
        if (ijklim(1,ind) == -1) goto 28
        indmax=indmax+1
        end do
28      continue
      end if

      do ind=1,indmax
c admittedly stupid but indices should be in arrays to get nice loops
c and they are not
      if (ind == 1) then
        k1=kkeel
        k2=kwl
        i1=ibow
        i2=iaft
      else
        k1=ijklim(6,indmax-1)
        k2=ijklim(7,indmax-1)
        i1=ijklim(2,indmax-1)
        i2=ijklim(3,indmax-1)
      end if

      do k=k1,k2-1
      do i=i1,i2-1
c 4 points are not necessarily planar, but anyhow ...
c centrum
      xcen=0.25*(x(i,j,k)+x(i+1,j,k)+x(i,j,k+1)+x(i+1,j,k+1))
      ycen=0.25*(y(i,j,k)+y(i+1,j,k)+y(i,j,k+1)+y(i+1,j,k+1))
      zcen=0.25*(z(i,j,k)+z(i+1,j,k)+z(i,j,k+1)+z(i+1,j,k+1))

c area of the face
       call xprd(x(i+1,j,k+1)-x(i,j,k),y(i+1,j,k+1)-y(i,j,k),
     $  z(i+1,j,k+1)-z(i,j,k),x(i,j,k+1)-x(i+1,j,k),
     $  y(i,j,k+1)-y(i+1,j,k),z(i,j,k+1)-z(i+1,j,k),xout,yout,zout)
c y=0 is the symmetry plane
      a=0.5*abs(yout)

      dv=2.0*ycen*a
      volmom = volmom + (xcen-xf)*dv
      end do
      end do

      end do

      return
      end
      
c
c***********************************************************************
      function alen3(xvect,yvect,zvect)
c calculate the lenghth of the 3d vector (xvect,yvect,zvect)

      alen3=sqrt(xvect*xvect + yvect*yvect + zvect*zvect)                                       
      
      return
      end
c
c***********************************************************************
      function anorm3(xvect,yvect,zvect)
c normalize the 3d vector (xvect,yvect,zvect)
      errb=1.0e-20

      anorm=sqrt(xvect*xvect + yvect*yvect + zvect*zvect)                                       
      if (anorm > errb) then                                      
        xvect=xvect/anorm                                                   
        yvect=yvect/anorm
        zvect=zvect/anorm
      else
        anorm=0.0
      end if                                                          

      anorm3=anorm
      
      return
      end
c
c***********************************************************************
      subroutine xprd(xv1,yv1,zv1,xv2,yv2,zv2,xv3,yv3,zv3)
c return the cross product of vectors 1 and 2 in vector 3

      xv3=yv1*zv2 - zv1*yv2                                       
      yv3=zv1*xv2 - xv1*zv2                                       
      zv3=xv1*yv2 - yv1*xv2                                       
      
      return
      end
c
c***********************************************************************
C hlp.f
C
      function echok(x,y,z,l,m,n,xi,eta,zeta,i,j,kr,kbot,ktop)
c orhogonalize at ibot               
      real x(-2:l+1,-2:m+1,-2:n+1)           
      real y(-2:l+1,-2:m+1,-2:n+1)           
      real z(-2:l+1,-2:m+1,-2:n+1)           
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n),zeta(0:l,0:m,0:n)

c logical echo
c        echok=amax1(0.0,real(kr-kbot)/ajmax0(ktop-kbot,1))
c HSVA2:
c        echok=amax1(0.0,abs(z(i,j,kr)-z(i,j,kbot))/
c     $   amax1(abs(z(i,j,ktop)-z(i,j,kbot)),0.001))
c physical echo
c        echok=amin1(1.0,2.0*rposik(x,y,z,l,m,n,i,j,kr,kbot,ktop))
c stretching echo
c        echok=amin1(1.0,2.0*sposik(xi,eta,zeta,l,m,n,i,j,kr,kbot,ktop))
        echok=amin1(1.0,sposik(xi,eta,zeta,l,m,n,i,j,kr,kbot,ktop))
        
c      if (kr < ktop) then
c        echok=sposik(xi,eta,zeta,l,m,n,i,j,kr,kbot,ktop)
c      else
c        echok=1.0
c      end if

      return
      end
c
c***********************************************************************
      function sposii(x,y,z,l,m,n,ir,j,k,ibot,itop)
c return the relative position of (i,j,kr) computed along the stretching functions
c i-direction
      real x(0:l,0:m,0:n),y(0:l,0:m,0:n),z(0:l,0:m,0:n)

      sum=0.0

      do 100 i=ibot+1,ir
      sum=sum+sqrt((x(i,j,k)-x(i-1,j,k))*(x(i,j,k)-x(i-1,j,k)) +
     $ (y(i,j,k)-y(i-1,j,k))*(y(i,j,k)-y(i-1,j,k)) +
     $ (z(i,j,k)-z(i-1,j,k))*(z(i,j,k)-z(i-1,j,k)))
100   continue
      psum=sum

      do 150 i=ir+1,itop
      sum=sum+sqrt((x(i,j,k)-x(i-1,j,k))*(x(i,j,k)-x(i-1,j,k)) +
     $ (y(i,j,k)-y(i-1,j,k))*(y(i,j,k)-y(i-1,j,k)) +
     $ (z(i,j,k)-z(i-1,j,k))*(z(i,j,k)-z(i-1,j,k)))
150   continue

      sposii=psum/max(sum,1.0e-9)
  
      return
      end
c
c***********************************************************************
      function sposij(x,y,z,l,m,n,i,jr,k,jbot,jtop)
c return the relative position of (i,j,kr) computed along the stretching functions
c j-direction              
      real x(0:l,0:m,0:n),y(0:l,0:m,0:n),z(0:l,0:m,0:n)

      sum=0.0

      do 100 j=jbot+1,jr
      sum=sum+sqrt((x(i,j,k)-x(i,j-1,k))*(x(i,j,k)-x(i,j-1,k)) +
     $ (y(i,j,k)-y(i,j-1,k))*(y(i,j,k)-y(i,j-1,k)) +
     $ (z(i,j,k)-z(i,j-1,k))*(z(i,j,k)-z(i,j-1,k)))
100   continue
      psum=sum

      do 150 j=jr+1,jtop
      sum=sum+sqrt((x(i,j,k)-x(i,j-1,k))*(x(i,j,k)-x(i,j-1,k)) +
     $ (y(i,j,k)-y(i,j-1,k))*(y(i,j,k)-y(i,j-1,k)) +
     $ (z(i,j,k)-z(i,j-1,k))*(z(i,j,k)-z(i,j-1,k)))
150   continue

      sposij=psum/max(sum,1.0e-9)
  
      return
      end
c
c***********************************************************************
      function sposik(x,y,z,l,m,n,i,j,kr,kbot,ktop)
c return the relative position of (i,j,kr) computed along the stretching functions
c k-direction
      real x(0:l,0:m,0:n),y(0:l,0:m,0:n),z(0:l,0:m,0:n)

      sum=0.0

      do 100 k=kbot+1,kr
      sum=sum+sqrt((x(i,j,k)-x(i,j,k-1))*(x(i,j,k)-x(i,j,k-1)) +
     $ (y(i,j,k)-y(i,j,k-1))*(y(i,j,k)-y(i,j,k-1)) +
     $ (z(i,j,k)-z(i,j,k-1))*(z(i,j,k)-z(i,j,k-1)))
100   continue
      psum=sum

      do 150 k=kr+1,ktop
      sum=sum+sqrt((x(i,j,k)-x(i,j,k-1))*(x(i,j,k)-x(i,j,k-1)) +
     $ (y(i,j,k)-y(i,j,k-1))*(y(i,j,k)-y(i,j,k-1)) +
     $ (z(i,j,k)-z(i,j,k-1))*(z(i,j,k)-z(i,j,k-1)))
150   continue

      sposik=psum/max(sum,1.0e-9)
  
      return
      end
c
c***********************************************************************
      function hlenk(xhull,yhull,zhull,lhull,mhull,nhull,i,j,z0,
     $ kbot,ktop)
c return the curve length computed along the hull up to z0
c k-direction
c if there are multiple points on the line at z=z0 the lowest is chosen
c multiplicity below or above does not matter            
      real xhull(0:lhull,0:mhull,0:nhull)
      real yhull(0:lhull,0:mhull,0:nhull)
      real zhull(0:lhull,0:mhull,0:nhull)
      data err/1.0e-10/

      sum=0.0

      do 150 k=kbot+1,ktop
      dsum=sqrt((xhull(i,j,k)-xhull(i,j,k-1))**2 +
     $ (yhull(i,j,k)-yhull(i,j,k-1))**2 +
     $ (zhull(i,j,k)-zhull(i,j,k-1))**2)
      sum=sum+dsum
      if (zhull(i,j,k) >= z0) then
        al=(zhull(i,j,k)-z0)/max(zhull(i,j,k)-zhull(i,j,k-1),err)
        sum=sum-al*dsum
        goto 200
      end if
150   continue
      call achtun(i,'hlenk',ierr)
200   continue

      hlenk=sum
  
      return
      end
c
c***********************************************************************
      function hlenkr(xhull,yhull,zhull,lhull,mhull,nhull,i,j,z0,
     $ kbot,ktop,llb,llt)
c return the curve length computed along the hull up to z0
c k-direction
c if there are multiple points on the line at z=z0 the highest is chosen
c multiplicity below or above does not matter            
      real xhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real yhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real zhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      logical below
      REAL :: irem = -1,jrem = -1 ! Any illegal value to start with
      data err/1.0e-10/

      below=.true.
      sum=0.0
      sum1=0.0

      do 150 k=kbot+1,ktop
      dsum=sqrt((xhull(i,j,k)-xhull(i,j,k-1))**2 +
     $ (yhull(i,j,k)-yhull(i,j,k-1))**2 +
     $ (zhull(i,j,k)-zhull(i,j,k-1))**2)
      sum=sum+dsum
      if (zhull(i,j,k) <= z0) below=.true.
      if (below.and.zhull(i,j,k) >= z0) then
        al=(zhull(i,j,k)-z0)/max(zhull(i,j,k)-zhull(i,j,k-1),err)
        sum1=sum-al*dsum
        below=.false.
      end if
150   continue
      if (below) sum1=sum

      if (sum1 < err) then
c error: zero curvelength
c use the common area to remember if an error message has already been printed
c don't print the same one twice
c common removed when porting to F90: A small experiment indicates that
c f90 remembers values from the last subr. call, if you get an exhausting
c number of these error messages with the same i and j then you know that 
c this is not so and you must find another way to store irem and jrem locally

        if (irem /= i.or.jrem /= j) then
          call achtun(i,'hlenkr',ierr)
          irem=i
          jrem=j
        end if
        sum1=sum
      end if

      hlenkr=sum1

      return
      end
c
c***********************************************************************
      function hlenkf(xhull,yhull,zhull,lhull,mhull,nhull,i,j,z0,
     $ kbot,ktop,llb,llt)
c return the curve length computed along the hull up to z0
c k-direction
c if there are multiple points on the line at z=z0 the highest is chosen
c multiplicity below or above does not matter
c if z0 < zhull(i,j,ktop) and slope at end negative then force total curve length           
      real xhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real yhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real zhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      logical below
      REAL :: irem = -1,jrem = -1 ! Any illegal value to start with
      data err/1.0e-10/

      below=.true.
      sum=0.0
      sum1=0.0

      do 150 k=kbot+1,ktop
      dsum=sqrt((xhull(i,j,k)-xhull(i,j,k-1))**2 +
     $ (yhull(i,j,k)-yhull(i,j,k-1))**2 +
     $ (zhull(i,j,k)-zhull(i,j,k-1))**2)
      sum=sum+dsum
      if (zhull(i,j,k) <= z0) below=.true.
      if (below.and.zhull(i,j,k) >= z0) then
        al=(zhull(i,j,k)-z0)/max(zhull(i,j,k)-zhull(i,j,k-1),err)
        sum1=sum-al*dsum
        below=.false.
      end if
150   continue
      if (below) sum1=sum

      if (sum1 < err) then
c error: zero curvelength
c use the common area to remember if an error message has already been printed
c don't print the same one twice
c common removed when porting to F90: A small experiment indicates that
c f90 remembers values from the last subr. call, if you get an exhausting
c number of these error messages with the same i and j then you know that 
c this is not so and you must find another way to store irem and jrem locally
        if (irem /= i.or.jrem /= j) then
          call achtun(i,'hlenkf',ierr)
          irem=i
          jrem=j
        end if
        sum1=sum
      end if
      
      if (z0 < zhull(i,j,ktop).and.
     $ zhull(i,j,ktop) < zhull(i,j,ktop-1)) then

        sum1=0.0
        do 250 k=kbot+1,ktop
        dsum=sqrt((xhull(i,j,k)-xhull(i,j,k-1))**2 +
     $   (yhull(i,j,k)-yhull(i,j,k-1))**2 +
     $   (zhull(i,j,k)-zhull(i,j,k-1))**2)
        sum1=sum1+dsum
250     continue
      end if

      hlenkf=sum1

      return
      end
c
c***********************************************************************
      subroutine inthk(xhull,yhull,zhull,lhull,mhull,nhull,i,j,clen,
     $ xp,yp,zp,llb,llt)
c integrate over hull
c k-direction
      real xhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real yhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real zhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)

      sum=0.0
      k=0

100   continue
      k=k+1
      dsum=sqrt(
     $ (xhull(i,j,k)-xhull(i,j,k-1))**2 +
     $ (yhull(i,j,k)-yhull(i,j,k-1))**2 +
     $ (zhull(i,j,k)-zhull(i,j,k-1))**2)
      sum=sum+dsum
      if (sum >= clen) goto 150
      if (k >= nhull) then
        call achtun(i,'inthk',ierr)
        if (ierr /= 0) write(6,*)'curve_length =',sum,clen,k
        sum=clen
        goto 150
      end if
      goto 100
150   continue
      al=(sum-clen)/amax1(dsum,1.0e-10)
      xp=al*xhull(i,j,k-1) + (1.0-al)*xhull(i,j,k)
      yp=al*yhull(i,j,k-1) + (1.0-al)*yhull(i,j,k)
      zp=al*zhull(i,j,k-1) + (1.0-al)*zhull(i,j,k)
  
      return
      end
c
c***********************************************************************
      subroutine achtun(i,subr,ierr)
      USE ACHTNG
      character*(*) subr

      ierr=0
c Do not produce an embarrassing amount of these messages - one is enough
      if (iacht /= 0) return  

      iacht=1
      ierr=1
      write(6,*)'***** ACHTUNG - ACHTUNG *****'
      write(6,*)'Wasser an deck, mann !'
      write(6,*)'Das i-koordinaten sein als',i
      write(6,*)'(Reportieren aus ',subr,')'
      write(6,*)
      
      return
      end
c
c***********************************************************************
      function hlenk0(xhull,yhull,zhull,lhull,mhull,nhull,i,j,x,y,z,
     $ kbot,ktop,llb,llt)
c return the curve length computed along the hull up to x,y,z
c k-direction             
      real xhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real yhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      real zhull(llb:lhull+llt,llb:mhull+llt,llb:nhull+llt)
      data err/1.0e-10/

      distc=1.0e+6
c find the closest segment
      do 100 k=kbot,ktop-1
      dist=pdistl(x,y,z,xhull(i,j,k),yhull(i,j,k),zhull(i,j,k),
     $ xhull(i,j,k+1),yhull(i,j,k+1),zhull(i,j,k+1),xc,yc,zc)
      if (dist < distc) then
        distc=dist
        xcc=xc
        ycc=yc
        zcc=zc
        kc=k
      end if
100   continue

c actually we don't care about the distance 
c but just want to project the point on the hull
      x=xcc
      y=ycc
      z=zcc
      
      sum=alen3(x-xhull(i,j,kc),y-yhull(i,j,kc),z-zhull(i,j,kc))

      do 150 k=kbot+1,kc
      dsum=sqrt((xhull(i,j,k)-xhull(i,j,k-1))**2 +
     $ (yhull(i,j,k)-yhull(i,j,k-1))**2 +
     $ (zhull(i,j,k)-zhull(i,j,k-1))**2)
      sum=sum+dsum
150   continue

      hlenk0=sum
  
      return
      end
c
c***********************************************************************
      function pdistl(x,y,z,x1,y1,z1,x2,y2,z2,xc,yc,zc)
c distance of x,y,z to the line x1,y1,z1 -> x2,y2,z2
c closest point is xc,yc,zc
      data err/1.0e-5/

      vx=x-x1
      vy=y-y1
      vz=z-z1
      ux=x2-x1
      uy=y2-y1
      uz=z2-z1
      u=alen3(ux,uy,uz)
      if (u < err) then
        pdistl=alen3(vx,vy,vz)
        xc=x1
        yc=y1
        zc=z1
        return
      end if
      
c projection of v to u (times |u|)
      v_u=vx*ux+vy*uy+vz*uz
      
      if (v_u <= 0.0) then
        pdistl=alen3(vx,vy,vz)
        xc=x1
        yc=y1
        zc=z1
      else if (v_u >= u**2) then
        xc=x2
        yc=y2
        zc=z2
        pdistl=alen3(x-xc,y-yc,z-zc)
      else
        xc=x1+v_u*ux/u**2
        yc=y1+v_u*uy/u**2
        zc=z1+v_u*uz/u**2
        pdistl=alen3(x-xc,y-yc,z-zc)
      end if
      return
      end
c
c***********************************************************************
      subroutine limzxy(i,j,z,diff,limit,jlimf,xi,eta,l,m,n,igo,x,y)
c bulb and aft limitters
c damping wrt j
      USE GLIM
      real xi(0:l,0:m,0:n),eta(0:l,0:m,0:n)
      real x(-2:l+1,-2:m+1,-2:n+1),y(-2:l+1,-2:m+1,-2:n+1)

      pi=acos(-1.0)
      igo=0

c actually the troubel is in another spot so ib is not needed      
c      if (ib /= 0) then
cc if starting from COMPUT we will do the first round without limitters to
cc achieve the wave form of the previous grid level
c        ib=0
c	return
c      end if
      
      if (ia == 1) goto 500 ! 2D limitter (user-damping)
c original 1D limitter with damping in j-direction
      if (j == 0) then
        do lime=1,nlim
        if (i >= iblim(lime) .and. i <= itlim(lime) .and. j == 0 .and.
     $   (diff+z <= zlim(i-iblim(lime),0,lime) 
     $   .or. limf(lime) == 1)) then
          limit=1 ! limitter on for this j-loop
          jlimf=jlim(lime) ! damp from j=0 to j=jlimf
	  diff=0.0
          igo=1
        else
          limit=0 ! limitter off for this j-loop
        end if
        end do
      end if
      if (limit == 1 .and. jlimf == 0) igo=1
c        if (limit == 1 .and. j < jlimf) diff=diff*j/jlimf
c the region where limiting is applied is highly clustered so unless
c we take clustering into account the z-coordinate will become highly curved
c which will result more easily in negative cell volumes
      if (limit == 1 .and. j < jlimf) then
        ramp=eta(i,j,n)/eta(i,jlimf,n) ! damp from j=0 to j=jlimf
c oh shit, this is so hard again - let's do this on physical domain then
	d1=sqrt((x(i,j,n)-x(i,0,n))**2 + (y(i,j,n)-y(i,0,n))**2)
	d2=sqrt((x(i,jlimf,n)-x(i,0,n))**2 + (y(i,jlimf,n)-y(i,0,n))**2)
	ramp=d1/d2

c ramp must stay zero as long as possible but smoothly approach unity
c let's give it a form
        if (ramp < 1.0-1.0e-3) then
	  ramp=(0.5*(1.0-cos(ramp*pi)))**2 
	else
	  ramp=1.0
	end if

        diff=diff*ramp ! damp from j=0 to j=jlimf
      end if
      return
      
500   continue
      lima=-1
      do lime=1,nlim
      if (i >= iblim(lime) .and. i <= itlim(lime) .and. j <= jlim(lime)
     $ .and. (diff+z <= zlim(i-iblim(lime),j,lime) 
     $ .or. limf(lime) == 1)) lima=lime
      end do
      if (lima /= -1) then
c j-damper
        cf = 1.0 - eta(i,j,n)/eta(i,jlim(lima),n)
        cfj = amin1(cf*2.0,1.0) ! 50% of the region is damped

	cfkb=1.0
c ibot-damper
        if (iblim(lima) > 0) then
          cf = (xi(i,j,n)-xi(iblim(lima),j,n))/
     $     (xi(itlim(lima),j,n)-xi(iblim(lima),j,n))
          cfkb = amin1(cf*10.0,1.0) ! 10% of the region is damped
	end if

	cfkt=1.0
c itop-damper
        if (itlim(lima) < l) then
          cf = 1.0 - (xi(i,j,n)-xi(iblim(lima),j,n))/
     $       (xi(itlim(lima),j,n)-xi(iblim(lima),j,n))
          cfkt = amin1(cf*5.0,1.0) ! 20% of the region is damped
	end if
	cf = amin1(cfj,cfkb,cfkt)
        diff=(1.0-cf)*diff + cf*(zlim(i-iblim(lima),j,lima)-z)
      end if

      return
      end
      
C
C***********************************************************************
C skewness.f
C
      SUBROUTINE gskew3(X,Y,Z,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,smin,
     $ mini,minj,mink,nleft,ibneg,itneg,jbneg,jtneg,kbneg,ktneg,iglobl)
      real x(-2:l+1,-2:m+1,-2:n+1)
      real y(-2:l+1,-2:m+1,-2:n+1)
      real z(-2:l+1,-2:m+1,-2:n+1)

      smin=2.0
      nleft=0
      ibneg=l
      jbneg=m
      kbneg=n
      itneg=0
      jtneg=0
      ktneg=0

      do k=kbot,ktop-1
      do j=jbot,jtop-1
      do i=ibot,itop-1
c Kordulla and Vinokur say:
c      call volume(X,Y,Z,l,m,n,i,j,k,s)
c Petri K. says:
      call petriv(X,Y,Z,l,m,n,i,j,k,s,1)
      if (s < smin) then
        smin=s
        mini=i
        minj=j
        mink=k
      end if
      if (s < 0.0) then
        nleft=nleft+1
        ibneg=min(ibneg,i)
        jbneg=min(jbneg,j)
        kbneg=min(kbneg,k)
        itneg=max(itneg,i)
        jtneg=max(jtneg,j)
        ktneg=max(ktneg,k)
      end if
      end do
      end do
      end do

      RETURN
      END
c                                                                      
c***********************************************************************
      subroutine petriv(x,y,z,l,m,n,i,j,k,v,mu)
c     *****************

c ... cell face geometrical properties, cell volumes and cell
c ... centerpoint coordinates are defined.

      real :: x(-2:l+1,-2:m+1,-2:n+1)
      real :: y(-2:l+1,-2:m+1,-2:n+1)
      real :: z(-2:l+1,-2:m+1,-2:n+1)
      REAL :: X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X4,Y4,Z4,
     +        AXX,AYY,AZZ,RDIAGX,RDIAGY,RDIAGZ,RD2AGX,RD2AGY,RD2AGZ,
     +        AXX2,AYY2,AZZ2,X5,Y5,Z5,X6,Y6,Z6,X7,Y7,Z7,X8,Y8,Z8,
     +        XCE,YCE,ZCE

c ... diagonal components:
      rdiagx = x(i+mu,j+mu,k+mu)-x(i,j,k)
      rdiagy = y(i+mu,j+mu,k+mu)-y(i,j,k)
      rdiagz = z(i+mu,j+mu,k+mu)-z(i,j,k)

c ... cell face a1 (i-direction):

c ... corner points coordinates:
      x1 = dble(x(i,j,k))
      y1 = dble(y(i,j,k))
      z1 = dble(z(i,j,k))
      x2 = dble(x(i,j,k+mu))
      y2 = dble(y(i,j,k+mu))
      z2 = dble(z(i,j,k+mu))
      x3 = dble(x(i,j+mu,k+mu))
      y3 = dble(y(i,j+mu,k+mu))
      z3 = dble(z(i,j+mu,k+mu))
      x4 = dble(x(i,j+mu,k))
      y4 = dble(y(i,j+mu,k))
      z4 = dble(z(i,j+mu,k))

      x5 = dble(x(i+mu,j,k))
      y5 = dble(y(i+mu,j,k))
      z5 = dble(z(i+mu,j,k))
      x6 = dble(x(i+mu,j,k+mu))
      y6 = dble(y(i+mu,j,k+mu))
      z6 = dble(z(i+mu,j,k+mu))
      x7 = dble(x(i+mu,j+mu,k+mu))
      y7 = dble(y(i+mu,j+mu,k+mu))
      z7 = dble(z(i+mu,j+mu,k+mu))
      x8 = dble(x(i+mu,j+mu,k))
      y8 = dble(y(i+mu,j+mu,k))
      z8 = dble(z(i+mu,j+mu,k))

               XCE = .125*(X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8)
               YCE = .125*(Y1 + Y2 + Y3 + Y4 + Y5 + Y6 + Y7 + Y8)
               ZCE = .125*(Z1 + Z2 + Z3 + Z4 + Z5 + Z6 + Z7 + Z8)
C ... Diagonal Components:
               RDIAGX = XCE-.5*(X1 + X2)
               RDIAGY = YCE-.5*(Y1 + Y2)
               RDIAGZ = ZCE-.5*(Z1 + Z2)
               RD2AGX = XCE-.5*(X7 + X8)
               RD2AGY = YCE-.5*(Y7 + Y8)
               RD2AGZ = ZCE-.5*(Z7 + Z8)
C ... Cell Face Area Components:
               AXX = 0.5*((Z3-Z1)*(Y4-Y2)-(Y3-Y1)*(Z4-Z2))
               AYY = 0.5*((X3-X1)*(Z4-Z2)-(Z3-Z1)*(X4-X2))
               AZZ = 0.5*((Y3-Y1)*(X4-X2)-(X3-X1)*(Y4-Y2))

               AXX2 = -0.5*((Z7-Z5)*(Y8-Y6)-(Y7-Y5)*(Z8-Z6))
               AYY2 = -0.5*((X7-X5)*(Z8-Z6)-(Z7-Z5)*(X8-X6))
               AZZ2 = -0.5*((Y7-Y5)*(X8-X6)-(X7-X5)*(Y8-Y6))
c ... volume increment:
      v = REAL(
     &              RDIAGX*AXX + RDIAGY*AYY +RDIAGZ*AZZ + 
     &              RD2AGX*AXX2+ RD2AGY*AYY2+RD2AGZ*AZZ2)

c ... cell face a2 (j-direction):

      x1 = dble(x(i,j,k))
      y1 = dble(y(i,j,k))
      z1 = dble(z(i,j,k))
      x2 = dble(x(i+mu,j,k))
      y2 = dble(y(i+mu,j,k))
      z2 = dble(z(i+mu,j,k))
      x3 = dble(x(i+mu,j,k+mu))
      y3 = dble(y(i+mu,j,k+mu))
      z3 = dble(z(i+mu,j,k+mu))
      x4 = dble(x(i,j,k+mu))
      y4 = dble(y(i,j,k+mu))
      z4 = dble(z(i,j,k+mu))

      x5 = dble(x(i,j+mu,k))
      y5 = dble(y(i,j+mu,k))
      z5 = dble(z(i,j+mu,k))
      x6 = dble(x(i+mu,j+mu,k))
      y6 = dble(y(i+mu,j+mu,k))
      z6 = dble(z(i+mu,j+mu,k))
      x7 = dble(x(i+mu,j+mu,k+mu))
      y7 = dble(y(i+mu,j+mu,k+mu))
      z7 = dble(z(i+mu,j+mu,k+mu))
      x8 = dble(x(i,j+mu,k+mu))
      y8 = dble(y(i,j+mu,k+mu))
      z8 = dble(z(i,j+mu,k+mu))

               XCE = .125*(X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8)
               YCE = .125*(Y1 + Y2 + Y3 + Y4 + Y5 + Y6 + Y7 + Y8)
               ZCE = .125*(Z1 + Z2 + Z3 + Z4 + Z5 + Z6 + Z7 + Z8)
C ... Diagonal Components:
               RDIAGX = XCE-.5*(X1 + X2)
               RDIAGY = YCE-.5*(Y1 + Y2)
               RDIAGZ = ZCE-.5*(Z1 + Z2)
               RD2AGX = XCE-.5*(X7 + X8)
               RD2AGY = YCE-.5*(Y7 + Y8)
               RD2AGZ = ZCE-.5*(Z7 + Z8)
C ... Cell Face Area Components:
               AXX = 0.5*((Z3-Z1)*(Y4-Y2)-(Y3-Y1)*(Z4-Z2))
               AYY = 0.5*((X3-X1)*(Z4-Z2)-(Z3-Z1)*(X4-X2))
               AZZ = 0.5*((Y3-Y1)*(X4-X2)-(X3-X1)*(Y4-Y2))

               AXX2 = -0.5*((Z7-Z5)*(Y8-Y6)-(Y7-Y5)*(Z8-Z6))
               AYY2 = -0.5*((X7-X5)*(Z8-Z6)-(Z7-Z5)*(X8-X6))
               AZZ2 = -0.5*((Y7-Y5)*(X8-X6)-(X7-X5)*(Y8-Y6))
c ... add a volume increment.
      v = v+REAL(
     &              RDIAGX*AXX + RDIAGY*AYY +RDIAGZ*AZZ + 
     &              RD2AGX*AXX2+ RD2AGY*AYY2+RD2AGZ*AZZ2)

c ... cell face a3 (k-direction):

      x1 = dble(x(i,j,k))
      y1 = dble(y(i,j,k))
      z1 = dble(z(i,j,k))
      x2 = dble(x(i,j+mu,k))
      y2 = dble(y(i,j+mu,k))
      z2 = dble(z(i,j+mu,k))
      x3 = dble(x(i+mu,j+mu,k))
      y3 = dble(y(i+mu,j+mu,k))
      z3 = dble(z(i+mu,j+mu,k))
      x4 = dble(x(i+mu,j,k))
      y4 = dble(y(i+mu,j,k))
      z4 = dble(z(i+mu,j,k))

      x5 = dble(x(i,j,k+mu))
      y5 = dble(y(i,j,k+mu))
      z5 = dble(z(i,j,k+mu))
      x6 = dble(x(i,j+mu,k+mu))
      y6 = dble(y(i,j+mu,k+mu))
      z6 = dble(z(i,j+mu,k+mu))
      x7 = dble(x(i+mu,j+mu,k+mu))
      y7 = dble(y(i+mu,j+mu,k+mu))
      z7 = dble(z(i+mu,j+mu,k+mu))
      x8 = dble(x(i+mu,j,k+mu))
      y8 = dble(y(i+mu,j,k+mu))
      z8 = dble(z(i+mu,j,k+mu))

               XCE = .125*(X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8)
               YCE = .125*(Y1 + Y2 + Y3 + Y4 + Y5 + Y6 + Y7 + Y8)
               ZCE = .125*(Z1 + Z2 + Z3 + Z4 + Z5 + Z6 + Z7 + Z8)
C ... Diagonal Components:
               RDIAGX = XCE-.5*(X1 + X2)
               RDIAGY = YCE-.5*(Y1 + Y2)
               RDIAGZ = ZCE-.5*(Z1 + Z2)
               RD2AGX = XCE-.5*(X7 + X8)
               RD2AGY = YCE-.5*(Y7 + Y8)
               RD2AGZ = ZCE-.5*(Z7 + Z8)
C ... Cell Face Area Components:
               AXX = 0.5*((Z3-Z1)*(Y4-Y2)-(Y3-Y1)*(Z4-Z2))
               AYY = 0.5*((X3-X1)*(Z4-Z2)-(Z3-Z1)*(X4-X2))
               AZZ = 0.5*((Y3-Y1)*(X4-X2)-(X3-X1)*(Y4-Y2))

               AXX2 = -0.5*((Z7-Z5)*(Y8-Y6)-(Y7-Y5)*(Z8-Z6))
               AYY2 = -0.5*((X7-X5)*(Z8-Z6)-(Z7-Z5)*(X8-X6))
               AZZ2 = -0.5*((Y7-Y5)*(X8-X6)-(X7-X5)*(Y8-Y6))
c ... add a volume increment and scale the result properly.
      v = (v+REAL(
     &              RDIAGX*AXX + RDIAGY*AYY +RDIAGZ*AZZ + 
     &              RD2AGX*AXX2+ RD2AGY*AYY2+RD2AGZ*AZZ2))/3.0

      return
      end
c                                                                      
c***********************************************************************
      SUBROUTINE sskew3(X,Y,Z,l,m,n,ibot,itop,jbot,jtop,kbot,ktop,smin,
     $ mini,minj,mink,nleft,ibneg,itneg,jbneg,jtneg,kbneg,ktneg,iglobl)
      real x(0:l,0:m,0:n)
      real y(0:l,0:m,0:n)
      real z(0:l,0:m,0:n)

      smin=2.0
      nleft=0
      ibneg=l
      jbneg=m
      kbneg=n
      itneg=0
      jtneg=0
      ktneg=0

      do k=kbot,ktop-1
      do j=jbot,jtop-1
      do i=ibot,itop-1
c Kordulla and Vinokur say:
c      call svolum(X,Y,Z,l,m,n,i,j,k,s)
c Petri K. says:
      call spetrv(X,Y,Z,l,m,n,i,j,k,s,1)
      if (s < smin) then
        smin=s
        mini=i
        minj=j
        mink=k
      end if
      if (s < 0.0) then
        nleft=nleft+1
        ibneg=min(ibneg,i)
        jbneg=min(jbneg,j)
        kbneg=min(kbneg,k)
        itneg=max(itneg,i)
        jtneg=max(jtneg,j)
        ktneg=max(ktneg,k)
      end if
      end do
      end do
      end do

      if (iglobl == 0) then
        ibneg=0
        jbneg=0
        kbneg=0
        itneg=l
        jtneg=m
        ktneg=n
      else
        ibneg=max(ibneg-iglobl,0)
        jbneg=max(jbneg-iglobl,0)
        kbneg=max(kbneg-iglobl,0)
        itneg=min(itneg+1+iglobl,l)
        jtneg=min(jtneg+1+iglobl,m)
        ktneg=min(ktneg+1+iglobl,n)
      end if

      RETURN
      END
c                                                                      
c***********************************************************************
      subroutine spetrv(x,y,z,l,m,n,i,j,k,v,mu)
c     *****************

c ... cell face geometrical properties, cell volumes and cell
c ... centerpoint coordinates are defined.

      real :: x(0:l,0:m,0:n)
      real :: y(0:l,0:m,0:n)
      real :: z(0:l,0:m,0:n)
      REAL :: X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X4,Y4,Z4,
     +        AXX,AYY,AZZ,RDIAGX,RDIAGY,RDIAGZ,RD2AGX,RD2AGY,RD2AGZ,
     +        AXX2,AYY2,AZZ2,X5,Y5,Z5,X6,Y6,Z6,X7,Y7,Z7,X8,Y8,Z8,
     +        XCE,YCE,ZCE

c ... diagonal components:
      rdiagx = x(i+mu,j+mu,k+mu)-x(i,j,k)
      rdiagy = y(i+mu,j+mu,k+mu)-y(i,j,k)
      rdiagz = z(i+mu,j+mu,k+mu)-z(i,j,k)

c ... cell face a1 (i-direction):

c ... corner points coordinates:
      x1 = dble(x(i,j,k))
      y1 = dble(y(i,j,k))
      z1 = dble(z(i,j,k))
      x2 = dble(x(i,j,k+mu))
      y2 = dble(y(i,j,k+mu))
      z2 = dble(z(i,j,k+mu))
      x3 = dble(x(i,j+mu,k+mu))
      y3 = dble(y(i,j+mu,k+mu))
      z3 = dble(z(i,j+mu,k+mu))
      x4 = dble(x(i,j+mu,k))
      y4 = dble(y(i,j+mu,k))
      z4 = dble(z(i,j+mu,k))

      x5 = dble(x(i+mu,j,k))
      y5 = dble(y(i+mu,j,k))
      z5 = dble(z(i+mu,j,k))
      x6 = dble(x(i+mu,j,k+mu))
      y6 = dble(y(i+mu,j,k+mu))
      z6 = dble(z(i+mu,j,k+mu))
      x7 = dble(x(i+mu,j+mu,k+mu))
      y7 = dble(y(i+mu,j+mu,k+mu))
      z7 = dble(z(i+mu,j+mu,k+mu))
      x8 = dble(x(i+mu,j+mu,k))
      y8 = dble(y(i+mu,j+mu,k))
      z8 = dble(z(i+mu,j+mu,k))

               XCE = .125*(X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8)
               YCE = .125*(Y1 + Y2 + Y3 + Y4 + Y5 + Y6 + Y7 + Y8)
               ZCE = .125*(Z1 + Z2 + Z3 + Z4 + Z5 + Z6 + Z7 + Z8)
C ... Diagonal Components:
               RDIAGX = XCE-.5*(X1 + X2)
               RDIAGY = YCE-.5*(Y1 + Y2)
               RDIAGZ = ZCE-.5*(Z1 + Z2)
               RD2AGX = XCE-.5*(X7 + X8)
               RD2AGY = YCE-.5*(Y7 + Y8)
               RD2AGZ = ZCE-.5*(Z7 + Z8)
C ... Cell Face Area Components:
               AXX = 0.5*((Z3-Z1)*(Y4-Y2)-(Y3-Y1)*(Z4-Z2))
               AYY = 0.5*((X3-X1)*(Z4-Z2)-(Z3-Z1)*(X4-X2))
               AZZ = 0.5*((Y3-Y1)*(X4-X2)-(X3-X1)*(Y4-Y2))

               AXX2 = -0.5*((Z7-Z5)*(Y8-Y6)-(Y7-Y5)*(Z8-Z6))
               AYY2 = -0.5*((X7-X5)*(Z8-Z6)-(Z7-Z5)*(X8-X6))
               AZZ2 = -0.5*((Y7-Y5)*(X8-X6)-(X7-X5)*(Y8-Y6))
c ... volume increment:
      v = REAL(
     &              RDIAGX*AXX + RDIAGY*AYY +RDIAGZ*AZZ + 
     &              RD2AGX*AXX2+ RD2AGY*AYY2+RD2AGZ*AZZ2)

c ... cell face a2 (j-direction):

      x1 = dble(x(i,j,k))
      y1 = dble(y(i,j,k))
      z1 = dble(z(i,j,k))
      x2 = dble(x(i+mu,j,k))
      y2 = dble(y(i+mu,j,k))
      z2 = dble(z(i+mu,j,k))
      x3 = dble(x(i+mu,j,k+mu))
      y3 = dble(y(i+mu,j,k+mu))
      z3 = dble(z(i+mu,j,k+mu))
      x4 = dble(x(i,j,k+mu))
      y4 = dble(y(i,j,k+mu))
      z4 = dble(z(i,j,k+mu))

      x5 = dble(x(i,j+mu,k))
      y5 = dble(y(i,j+mu,k))
      z5 = dble(z(i,j+mu,k))
      x6 = dble(x(i+mu,j+mu,k))
      y6 = dble(y(i+mu,j+mu,k))
      z6 = dble(z(i+mu,j+mu,k))
      x7 = dble(x(i+mu,j+mu,k+mu))
      y7 = dble(y(i+mu,j+mu,k+mu))
      z7 = dble(z(i+mu,j+mu,k+mu))
      x8 = dble(x(i,j+mu,k+mu))
      y8 = dble(y(i,j+mu,k+mu))
      z8 = dble(z(i,j+mu,k+mu))

               XCE = .125*(X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8)
               YCE = .125*(Y1 + Y2 + Y3 + Y4 + Y5 + Y6 + Y7 + Y8)
               ZCE = .125*(Z1 + Z2 + Z3 + Z4 + Z5 + Z6 + Z7 + Z8)
C ... Diagonal Components:
               RDIAGX = XCE-.5*(X1 + X2)
               RDIAGY = YCE-.5*(Y1 + Y2)
               RDIAGZ = ZCE-.5*(Z1 + Z2)
               RD2AGX = XCE-.5*(X7 + X8)
               RD2AGY = YCE-.5*(Y7 + Y8)
               RD2AGZ = ZCE-.5*(Z7 + Z8)
C ... Cell Face Area Components:
               AXX = 0.5*((Z3-Z1)*(Y4-Y2)-(Y3-Y1)*(Z4-Z2))
               AYY = 0.5*((X3-X1)*(Z4-Z2)-(Z3-Z1)*(X4-X2))
               AZZ = 0.5*((Y3-Y1)*(X4-X2)-(X3-X1)*(Y4-Y2))

               AXX2 = -0.5*((Z7-Z5)*(Y8-Y6)-(Y7-Y5)*(Z8-Z6))
               AYY2 = -0.5*((X7-X5)*(Z8-Z6)-(Z7-Z5)*(X8-X6))
               AZZ2 = -0.5*((Y7-Y5)*(X8-X6)-(X7-X5)*(Y8-Y6))
c ... add a volume increment.
      v = v+REAL(
     &              RDIAGX*AXX + RDIAGY*AYY +RDIAGZ*AZZ + 
     &              RD2AGX*AXX2+ RD2AGY*AYY2+RD2AGZ*AZZ2)

c ... cell face a3 (k-direction):

      x1 = dble(x(i,j,k))
      y1 = dble(y(i,j,k))
      z1 = dble(z(i,j,k))
      x2 = dble(x(i,j+mu,k))
      y2 = dble(y(i,j+mu,k))
      z2 = dble(z(i,j+mu,k))
      x3 = dble(x(i+mu,j+mu,k))
      y3 = dble(y(i+mu,j+mu,k))
      z3 = dble(z(i+mu,j+mu,k))
      x4 = dble(x(i+mu,j,k))
      y4 = dble(y(i+mu,j,k))
      z4 = dble(z(i+mu,j,k))

      x5 = dble(x(i,j,k+mu))
      y5 = dble(y(i,j,k+mu))
      z5 = dble(z(i,j,k+mu))
      x6 = dble(x(i,j+mu,k+mu))
      y6 = dble(y(i,j+mu,k+mu))
      z6 = dble(z(i,j+mu,k+mu))
      x7 = dble(x(i+mu,j+mu,k+mu))
      y7 = dble(y(i+mu,j+mu,k+mu))
      z7 = dble(z(i+mu,j+mu,k+mu))
      x8 = dble(x(i+mu,j,k+mu))
      y8 = dble(y(i+mu,j,k+mu))
      z8 = dble(z(i+mu,j,k+mu))

               XCE = .125*(X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8)
               YCE = .125*(Y1 + Y2 + Y3 + Y4 + Y5 + Y6 + Y7 + Y8)
               ZCE = .125*(Z1 + Z2 + Z3 + Z4 + Z5 + Z6 + Z7 + Z8)
C ... Diagonal Components:
               RDIAGX = XCE-.5*(X1 + X2)
               RDIAGY = YCE-.5*(Y1 + Y2)
               RDIAGZ = ZCE-.5*(Z1 + Z2)
               RD2AGX = XCE-.5*(X7 + X8)
               RD2AGY = YCE-.5*(Y7 + Y8)
               RD2AGZ = ZCE-.5*(Z7 + Z8)
C ... Cell Face Area Components:
               AXX = 0.5*((Z3-Z1)*(Y4-Y2)-(Y3-Y1)*(Z4-Z2))
               AYY = 0.5*((X3-X1)*(Z4-Z2)-(Z3-Z1)*(X4-X2))
               AZZ = 0.5*((Y3-Y1)*(X4-X2)-(X3-X1)*(Y4-Y2))

               AXX2 = -0.5*((Z7-Z5)*(Y8-Y6)-(Y7-Y5)*(Z8-Z6))
               AYY2 = -0.5*((X7-X5)*(Z8-Z6)-(Z7-Z5)*(X8-X6))
               AZZ2 = -0.5*((Y7-Y5)*(X8-X6)-(X7-X5)*(Y8-Y6))
c ... add a volume increment and scale the result properly.
      v = (v+REAL(
     &              RDIAGX*AXX + RDIAGY*AYY +RDIAGZ*AZZ + 
     &              RD2AGX*AXX2+ RD2AGY*AYY2+RD2AGZ*AZZ2))/3.0

      return
      end
